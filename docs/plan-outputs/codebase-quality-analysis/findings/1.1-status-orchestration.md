# Agent S1 Findings: Status & Orchestration Subsystem

## Summary

The status and orchestration subsystem demonstrates good architectural separation with clear source-of-truth documentation, but contains multiple DRY violations (duplicate functions and patterns), inconsistent error handling patterns, and unused command implementations. Key areas of concern: duplicate `formatDuration` implementations, duplicate plan path reading logic, inconsistent null checks, and lock/async handling disparities between sync and async variants.

---

## DRY Violations

### Duplicate `formatDuration` Function Implementation
- **Location:** `scripts/lib/status-manager.js:400` and `scripts/lib/timestamp-utils.js:233`
- **Description:** Identical `formatDuration()` function implemented in two files with same logic (ms < 1000, < 60000, < 3600000, else hours format). Both versions are exported and available for use.
- **Recommendation:** Extract to a shared utilities module (e.g., `scripts/lib/format-utils.js`) and import in both files to maintain single source of truth.

### Duplicate Plan Path Reading Pattern
- **Location:** `scripts/status-cli.js:62-72` (`getActivePlanPath`), `scripts/plan-orchestrator.js:39-47` (`getActivePlan`), and `scripts/lib/status-manager.js` imports
- **Description:** Three independent implementations reading `.claude/current-plan.txt` with nearly identical try-catch patterns and null handling. Creates maintenance burden when pointer file path changes.
- **Recommendation:** Create centralized `scripts/lib/plan-pointer.js` module with single `getActivePlanPath()` function and import everywhere.

### Duplicate Output Directory Pointer Reading
- **Location:** `scripts/plan-orchestrator.js:52-58` (`getOutputDir`), `scripts/lib/status-manager.js:33-37` (`getCurrentOutputDir`), `scripts/lib/plan-output-utils.js:33-34` (CURRENT_OUTPUT_PATH constant)
- **Description:** Multiple implementations reading `.claude/current-plan-output.txt` with different function names and slight variations.
- **Recommendation:** Standardize on single location and function name across all modules.

### Duplicate Task Status Marking Functions
- **Location:** `scripts/lib/status-manager.js:297-341` (four mark* functions), `scripts/status-cli.js:155-229` (four cmd* functions)
- **Description:** `markTaskStarted`, `markTaskCompleted`, `markTaskFailed`, `markTaskSkipped` in status-manager simply delegate to `updateTaskStatus()`. Similar pattern in status-cli command handlers. Wrappers add minimal value.
- **Recommendation:** Consider if wrapper functions are necessary or if callers should use `updateTaskStatus()` directly with clearer semantics.

### Duplicate Plan Path Validation Logic
- **Location:** Multiple files - `status-cli.js:694-697`, `plan-orchestrator.js:404-408`, `status-manager.js:55-61`
- **Description:** Each file independently checks if plan path exists, reads content, validates it. Three separate implementations of the same validation sequence.
- **Recommendation:** Extract to `scripts/lib/plan-validation.js` with function like `validatePlanPath(path)`.

---

## Bugs & Issues

### Unchecked Lock Release in Async Operations
- **Location:** `scripts/lib/plan-output-utils.js:813-817` (updateTaskStatusWithLock finally block)
- **Severity:** Medium
- **Description:** In the finally block, `await release()` is called without verification that release function is callable. The lock may have been acquired with different states. While there's a try-catch, a release function might not exist if `loadStatusWithLock` failed.
- **Recommendation:** Add guard: `if (release && typeof release === 'function')` before calling release.

### Race Condition in Lock Cleanup Logic
- **Location:** `scripts/lib/plan-output-utils.js:282-316` (acquireLock)
- **Severity:** Medium
- **Description:** `cleanStaleLock()` is called inside `acquireLock()`, but the cleanup happens before proper-lockfile's stale option processes it. This could create a race where lock is cleaned then immediately recreated by another process. The stale option in `LOCK_OPTIONS` (line 45) should handle this automatically, making the manual cleanup redundant and potentially harmful.
- **Recommendation:** Remove manual stale lock cleanup; trust proper-lockfile's built-in stale option. The extra `isLockStale()` call is unnecessary overhead.

### Silent Error Suppression in Exception Handling
- **Location:** `scripts/lib/plan-output-utils.js:515-520` (loadStatusWithLock), `scripts/lib/plan-output-utils.js:805-816` (updateTaskStatusWithLock)
- **Severity:** Low
- **Description:** In `loadStatusWithLock`, if lock fails, it attempts to read and parse without lock but doesn't propagate the parse error clearly. The `return { status, release: () => {} }` masks that the file exists but is not locked.
- **Recommendation:** Add explicit error logging or return error indicator when lock acquisition fails for critical operations.

### Summary Drift Auto-Fix Without Transactional Guarantee
- **Location:** `scripts/lib/plan-output-utils.js:741-746` (updateTaskStatus), `scripts/lib/plan-output-utils.js:805-809` (updateTaskStatusWithLock)
- **Severity:** Medium
- **Description:** After updating a task, `validateSummary(status, true)` auto-recalculates summary. However, if this recalculation reveals drift, it's silently fixed and saved without explicit notification to caller. Drift indicates a bug elsewhere in the code.
- **Recommendation:** Return validation result to caller and log drift as warning. Consider error threshold - if drift occurs too frequently, should fail loudly.

### Missing Null Check in Array Operations
- **Location:** `scripts/lib/plan-output-utils.js:425-462` (rebuildStatusFromMarkdown)
- **Severity:** Low
- **Description:** When rebuilding from markdown, `tasks` array is populated but if no tasks are found, function returns null without clearing potential stale state. Code logs warning but continues processing.
- **Recommendation:** Add explicit check: if tasks.length === 0, return null with error message explaining why no tasks were parsed.

### Inconsistent Error Messages Across Sync/Async Variants
- **Location:** `scripts/lib/plan-output-utils.js:701-749` (sync version) vs `scripts/lib/plan-output-utils.js:760-819` (async version)
- **Severity:** Low
- **Description:** Both `updateTaskStatus` and `updateTaskStatusWithLock` have nearly identical logic but different return patterns. Sync returns boolean, async returns Promise<boolean>. Error logging is identical but async version has extra finally block that could hide errors.
- **Recommendation:** Consolidate logic or ensure consistent error propagation in both versions.

---

## Inconsistencies

### Inconsistent Lock Pattern Between Functions
- **Files:** `scripts/lib/plan-output-utils.js`
- **Description:**
  - `loadStatusWithLock()` (line 506): Returns `{status, release}` object
  - `saveStatusWithLock()` (line 617): Takes status, acquires lock internally, saves, releases
  - `updateTaskStatusWithLock()` (line 760): Uses `loadStatusWithLock()` pattern
  - `batchUpdateTasks()` (line 838): Uses `loadStatusWithLock()` pattern

  Inconsistent patterns: some functions return release, others manage lock internally. This creates cognitive load and error-prone code.
- **Recommendation:** Standardize on one pattern: either always return release function, or always manage lock internally. Prefer internal management for simpler API.

### Inconsistent Status Object Property Names
- **Files:** `scripts/lib/plan-output-utils.js` and `scripts/lib/status-manager.js`
- **Description:** Tasks sometimes use `findingsPath`, sometimes `findings`. Extra fields added with `Object.assign()` without schema validation. Example: `markTaskCompleted` uses `findingsPath`, but `getTaskStatusWithFallback` also looks for `findingsPath`.
- **Recommendation:** Define and enforce a schema for task status objects using JSON Schema (already imported but not used consistently).

### Inconsistent Naming: `currentPhase` vs `current_phase`
- **Files:** Multiple files use `currentPhase` (camelCase) as property name
- **Description:** Most status properties follow camelCase (e.g., `lastUpdatedAt`, `startedAt`), but property is called `currentPhase`. Consistent across codebase but differs from other similar properties like `lastErrorAt`.
- **Recommendation:** Rename to `current_phase` for consistency, or document why this one is different.

### Inconsistent Import Patterns
- **Location:** `scripts/status-cli.js:40-53`, `scripts/plan-orchestrator.js:29-30`
- **Description:** status-cli imports all destructured at top, plan-orchestrator only imports what it needs. status-cli imports but doesn't use all exports (e.g., `ensureSummaryKeys`, `validateSummary`).
- **Recommendation:** Audit imports; remove unused ones. Consider import-sorting convention.

### Inconsistent Error Handling in Timestamp Utils
- **Location:** `scripts/lib/timestamp-utils.js:57-113` (recordTaskTiming)
- **Severity:** Low
- **Description:** Function doesn't validate `timing` object structure. If `timing.completedAt` or `timing.startedAt` are invalid dates, `new Date()` calls succeed but calculations produce NaN. No exception thrown.
- **Recommendation:** Add validation: check that timing object has required ISO date strings before using.

---

## Unused Code

### Unused Command Implementations in status-cli.js
- **Location:** `scripts/status-cli.js:566-587`, `scripts/status-cli.js:591-602`, `scripts/status-cli.js:607-616`
- **Description:**
  - `cmdRetryable()` - imports `getRetryableTasks` in switch statement (line 567)
  - `cmdExhausted()` - imports `getExhaustedTasks` (line 580)
  - `cmdIncrementRetry()` - imports `incrementRetryCount` (line 597)
  - `cmdDetectStuck()` - imports `detectAndMarkStuckTasks` (line 608)

  These commands are implemented and dispatched in main switch statement (lines 753-767) but help text (lines 621-676) and documentation don't mention them prominently. They're likely functional but appear as "orphaned" commands not integrated into main workflow.
- **Recommendation:** Either document and promote these commands as first-class features, or if deprecated, remove them entirely.

### Unused Function: `getOutputDir` in plan-orchestrator
- **Location:** `scripts/plan-orchestrator.js:52-58`
- **Description:** Function `getOutputDir()` is defined and called once at line 64, but result is used only to load status. The standalone function isn't exported and doesn't appear to be necessary.
- **Recommendation:** Inline the logic into `loadStatus()` call.

### Unused Function: `mergePlanWithStatus`
- **Location:** `scripts/plan-orchestrator.js:196-217`
- **Description:** Function is defined but never called in the file. It merges plan structure with status data, but the flow uses different pattern via `loadTasks()` which handles merging internally.
- **Recommendation:** Remove or document why it's kept as alternative implementation.

### Unused Return Values
- **Location:** `scripts/lib/plan-output-utils.js:425` and other recovery functions
- **Description:** `rebuildStatusFromMarkdown()` is called in `loadStatus()` line 382, and the result is returned. However, the function is not exported (line 1225-1274), so it can't be used externally.
- **Recommendation:** Either export for external use, or keep as internal-only with comment clarifying.

### Dead Code: Duplicate Summary Key Handling
- **Location:** `scripts/lib/plan-output-utils.js:395-401` (in loadStatus)
- **Description:** Code checks if keys were added via `ensureSummaryKeys()` and sets `addedKeys = normalizedKeys.length > originalKeys.length`. This check is redundant because immediately after, we validate with `validateSummary()`. If keys were added, validation would catch the mismatch anyway.
- **Recommendation:** Simplify: remove the addedKeys check, let validateSummary handle it entirely.

### Unused Exports in plan-output-utils.js
- **Location:** `scripts/lib/plan-output-utils.js:1253-1257` (Lock utilities section)
- **Description:** Functions `isLockStale()`, `cleanStaleLock()`, `isLocked()` are exported but appear unused by status-cli.js and plan-orchestrator.js. They're internal implementation details.
- **Recommendation:** Consider whether these should be internal (non-exported) or if there's a use case for external consumers. If exported, document the contract.

---

## Additional Observations

### Positive Patterns
1. **Good documentation:** Clear comments about source of truth (status.json vs markdown)
2. **Atomic writes:** Use of `writeFileAtomic()` prevents corruption
3. **Backup strategy:** Creates `.bak` files before writes
4. **Comprehensive status schema:** Fields for timing, retry tracking, findings paths
5. **Recovery mechanisms:** Fallback to backup, rebuild from markdown on corruption

### Areas for Future Improvement
1. **Configuration centralization:** Lock timeouts, stale thresholds, retry limits are constants scattered in code
2. **Schema validation:** planStatusSchema.json is imported but not actively used for validation
3. **Logging consistency:** Mix of `console.error`, `console.warn`, `console.log` without structured logging
4. **Testing:** Test files exist but error handling in production code is not well covered (try-catch blocks with limited recovery)
