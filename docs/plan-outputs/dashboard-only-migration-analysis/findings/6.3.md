# Task 6.3: Backend Changes Needed to Support Dashboard-Only

## Overview

This document identifies all backend changes required to support a dashboard-only workflow, organized by component. Changes are categorized as:

- **NEW**: New functionality to implement
- **MODIFY**: Existing code to modify
- **CONFIG**: Configuration changes

---

## 1. API Server Changes (`scripts/api-server.js`)

### 1.1 New Endpoints Required

| Endpoint | Method | Purpose | Priority |
|----------|--------|---------|----------|
| `/api/templates` | GET | List available plan templates | P0 |
| `/api/templates/:name` | GET | Get template details and content | P0 |
| `/api/plans` | POST | Create new plan from template | P0 |
| `/api/plans/:name/tasks/:taskId/implement` | POST | Trigger single task implementation | P0 |
| `/api/plans/:name/tasks/:taskId/explain` | POST | Get task explanation | P1 |
| `/api/plans/:name/tasks/:taskId/verify` | POST | Verify task completion | P1 |
| `/api/plans/:name/archive` | POST | Archive completed plan | P1 |
| `/api/plans/:name/findings` | GET | List all findings for plan | P1 |
| `/api/plans/:name/findings/:taskId` | GET | Get specific task findings | P1 |
| `/api/activity` | GET | List activity events | P1 |
| `/api/worktrees` | POST | Create new worktree | P1 |
| `/api/worktrees/:name` | DELETE | Remove worktree | P1 |
| `/api/dashboard/summary` | GET | Dashboard overview data | P1 |
| `/api/orchestrators` | GET | List all orchestrators | P1 |
| `/api/orchestrators/:id` | GET | Get orchestrator details | P1 |
| `/api/orchestrators/:id/pause` | POST | Pause orchestrator | P1 |
| `/api/orchestrators/:id/resume` | POST | Resume orchestrator | P1 |

### 1.2 Template Endpoints Implementation

**GET /api/templates**

```javascript
app.get('/api/templates', async (req, res) => {
  const templatesDir = path.join(__dirname, '../.claude/templates/plans');
  const templates = [];

  try {
    const files = await fs.readdir(templatesDir);

    for (const file of files) {
      if (!file.endsWith('.md')) continue;

      const filePath = path.join(templatesDir, file);
      const content = await fs.readFile(filePath, 'utf8');
      const name = file.replace('.md', '');

      // Extract title from first H1
      const titleMatch = content.match(/^#\s+(.+)$/m);
      const title = titleMatch ? titleMatch[1] : name;

      // Extract variables ({{variable}} patterns)
      const variableMatches = content.match(/\{\{(\w+)\}\}/g) || [];
      const variables = [...new Set(variableMatches.map(v => v.replace(/[{}]/g, '')))];

      // Extract description from first paragraph
      const descMatch = content.match(/^#.+\n\n(.+?)(\n\n|$)/s);
      const description = descMatch ? descMatch[1].substring(0, 200) : '';

      templates.push({ name, title, description, variables, path: filePath });
    }

    res.json({ templates });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

**POST /api/plans**

```javascript
app.post('/api/plans', async (req, res) => {
  const { name, template, variables = {}, description } = req.body;

  // Validation
  if (!name) return res.status(400).json({ error: 'Plan name required' });
  if (!/^[a-z0-9-]+$/.test(name)) {
    return res.status(400).json({ error: 'Invalid plan name (use lowercase, numbers, hyphens)' });
  }

  const planPath = path.join('docs/plans', `${name}.md`);
  const outputDir = path.join('docs/plan-outputs', name);

  // Check for existing plan
  if (await fileExists(planPath)) {
    return res.status(409).json({ error: 'Plan already exists' });
  }

  try {
    let content;

    if (template) {
      // Load template
      const templatePath = path.join('.claude/templates/plans', `${template}.md`);
      content = await fs.readFile(templatePath, 'utf8');

      // Substitute variables
      for (const [key, value] of Object.entries(variables)) {
        content = content.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value);
      }
    } else {
      // Create blank plan
      content = `# ${name}\n\n${description || ''}\n\n## Phase 1: Setup\n- [ ] 1.1 First task\n`;
    }

    // Write plan file
    await fs.mkdir(path.dirname(planPath), { recursive: true });
    await fs.writeFile(planPath, content);

    // Initialize status.json
    await fs.mkdir(outputDir, { recursive: true });
    await planStatus.initializePlanStatus(planPath);

    // Create git branch if configured
    const gitConfig = await worktreeUtils.loadGitWorkflowConfig();
    if (gitConfig.strategy === 'branch-per-plan') {
      const branchName = `${gitConfig.branch_prefix || 'plan/'}${name}`;
      await exec(`git checkout -b ${branchName}`);
    }

    res.json({
      success: true,
      plan: {
        name,
        path: planPath,
        statusPath: path.join(outputDir, 'status.json')
      }
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 1.3 Task Implementation Endpoint

**POST /api/plans/:name/tasks/:taskId/implement**

```javascript
const activeSessions = new Map();

app.post('/api/plans/:name/tasks/:taskId/implement', async (req, res) => {
  const { name, taskId } = req.params;
  const { autonomous = true, timeout = 300000 } = req.body;

  // Generate session ID
  const sessionId = `sess-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Spawn orchestrator in single-task mode
  const args = [
    'python3', path.join(__dirname, 'plan_orchestrator.py'),
    '--plan', `docs/plans/${name}.md`,
    '--task', taskId,
    '--single-task',
    '--no-tui',
    '--daemon'
  ];

  if (autonomous) args.push('--autonomous');

  const child = spawn(args[0], args.slice(1), {
    cwd: path.join(__dirname, '..'),
    stdio: ['ignore', 'pipe', 'pipe'],
    detached: true
  });

  activeSessions.set(sessionId, {
    process: child,
    taskId,
    planName: name,
    startedAt: new Date(),
    output: []
  });

  // Collect output for WebSocket broadcast
  child.stdout.on('data', (data) => {
    const session = activeSessions.get(sessionId);
    if (session) {
      session.output.push(data.toString());
      wss.clients.forEach(client => {
        if (client.sessionId === sessionId) {
          client.send(JSON.stringify({ type: 'log', data: data.toString() }));
        }
      });
    }
  });

  child.on('close', (code) => {
    wss.clients.forEach(client => {
      if (client.sessionId === sessionId) {
        client.send(JSON.stringify({
          type: code === 0 ? 'completed' : 'failed',
          code
        }));
      }
    });
    activeSessions.delete(sessionId);
  });

  res.json({
    success: true,
    sessionId,
    wsEndpoint: `/ws/sessions/${sessionId}`
  });
});
```

### 1.4 WebSocket Enhancements

**New WebSocket Endpoints:**

| Endpoint | Purpose |
|----------|---------|
| `/ws/sessions/:sessionId` | Task implementation progress |
| `/ws/events` | Global event stream |
| `/ws/orchestrators/:id` | Orchestrator-specific updates |

**Enhanced Event Types:**

```javascript
// Add to WebSocket message types
const WS_EVENTS = {
  // Existing
  STATUS: 'status',
  ALL_PLANS: 'all-plans',
  HEARTBEAT: 'heartbeat',

  // New
  TASK_STARTED: 'task:started',
  TASK_COMPLETED: 'task:completed',
  TASK_FAILED: 'task:failed',
  TOOL_STARTED: 'tool:started',
  TOOL_COMPLETED: 'tool:completed',
  ACTIVITY_NEW: 'activity:new',
  ORCHESTRATOR_STATUS: 'orchestrator:status',
  ORCHESTRATOR_PROGRESS: 'orchestrator:progress'
};
```

### 1.5 Missing Endpoint Implementations

**GET /api/plans/:name/findings**

```javascript
app.get('/api/plans/:name/findings', async (req, res) => {
  const findingsDir = path.join('docs/plan-outputs', req.params.name, 'findings');

  try {
    const files = await fs.readdir(findingsDir);
    const findings = [];

    for (const file of files) {
      if (!file.endsWith('.md')) continue;
      const taskId = file.replace('.md', '');
      const content = await fs.readFile(path.join(findingsDir, file), 'utf8');
      const stats = await fs.stat(path.join(findingsDir, file));

      findings.push({
        taskId,
        fileName: file,
        size: stats.size,
        lastModified: stats.mtime,
        preview: content.substring(0, 500)
      });
    }

    res.json({ findings });
  } catch (error) {
    if (error.code === 'ENOENT') {
      res.json({ findings: [] });
    } else {
      res.status(500).json({ error: error.message });
    }
  }
});
```

**GET /api/dashboard/summary**

```javascript
app.get('/api/dashboard/summary', async (req, res) => {
  try {
    const plans = await scanPlans();
    const registry = await loadOrchestratorRegistry();

    let totalTasks = 0, completed = 0, pending = 0, failed = 0, inProgress = 0;

    for (const plan of plans) {
      if (plan.progress) {
        totalTasks += plan.progress.total || 0;
        completed += plan.progress.completed || 0;
        pending += plan.progress.pending || 0;
        failed += plan.progress.failed || 0;
        inProgress += plan.progress.in_progress || 0;
      }
    }

    const runningOrchestrators = registry.instances.filter(i => i.status === 'running');

    res.json({
      plans: {
        total: plans.length,
        active: runningOrchestrators.length,
        completed: plans.filter(p => p.progress?.percentage === 100).length
      },
      tasks: {
        total: totalTasks,
        completed,
        pending,
        failed,
        inProgress
      },
      orchestrators: {
        running: runningOrchestrators.length,
        recent: runningOrchestrators.slice(0, 5)
      },
      activity: await getRecentActivity(10)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

---

## 2. Plan Orchestrator Changes (`scripts/plan_orchestrator.py`)

### 2.1 New Command-Line Arguments

```python
# Add to argument parser

parser.add_argument('--single-task', action='store_true',
    help='Execute only the specified --task, then exit')

parser.add_argument('--session-id', type=str,
    help='API session ID for progress tracking')

parser.add_argument('--no-commit', action='store_true',
    help='Disable auto-commit after task completion')
```

### 2.2 Single Task Mode Implementation

```python
def run_single_task_mode(args):
    """Execute a single task and exit."""
    if not args.task:
        raise ValueError("--task required with --single-task mode")

    # Load plan status
    status = load_status(args.plan)
    task = next((t for t in status['tasks'] if t['id'] == args.task), None)

    if not task:
        raise ValueError(f"Task {args.task} not found in plan")

    if task['status'] != 'pending':
        raise ValueError(f"Task {args.task} is {task['status']}, not pending")

    # Mark task started
    mark_task_started(args.plan, args.task)

    try:
        # Execute task with Claude
        result = execute_task(args.plan, task, autonomous=args.autonomous)

        # Mark complete
        mark_task_completed(args.plan, args.task, notes=result.get('notes'))

        # Auto-commit if enabled
        if not args.no_commit:
            auto_commit_task(args.plan, args.task, task['description'])

        return 0

    except Exception as e:
        mark_task_failed(args.plan, args.task, error=str(e))
        return 1


if args.single_task:
    sys.exit(run_single_task_mode(args))
```

### 2.3 Git Auto-Commit Implementation

```python
import subprocess

def auto_commit_task(plan_path: str, task_id: str, description: str):
    """Commit changes after task completion."""
    config = load_git_workflow_config()

    if not config.get('auto_commit', {}).get('enabled', True):
        return

    try:
        # Check for uncommitted changes
        result = subprocess.run(
            ['git', 'status', '--porcelain'],
            capture_output=True, text=True, check=True
        )

        if not result.stdout.strip():
            logging.debug(f"No changes to commit for task {task_id}")
            return

        # Stage all changes
        subprocess.run(['git', 'add', '-A'], check=True)

        # Build commit message
        plan_name = Path(plan_path).stem
        template = config.get('auto_commit', {}).get(
            'commit_message_template',
            '[{plan}] task {task_id}: {description}'
        )
        message = template.format(
            plan=plan_name,
            task_id=task_id,
            description=description[:50]
        )

        # Commit
        subprocess.run(['git', 'commit', '-m', message], check=True)
        logging.info(f"Auto-committed changes for task {task_id}")

    except subprocess.CalledProcessError as e:
        logging.warning(f"Auto-commit failed for task {task_id}: {e}")
        # Don't fail the task
```

### 2.4 Progress Streaming for API

```python
import sys
import json

def emit_progress(event_type: str, data: dict, session_id: str = None):
    """Emit progress event for API consumption."""
    event = {
        'type': event_type,
        'timestamp': datetime.utcnow().isoformat(),
        'session_id': session_id,
        **data
    }
    # Write to stdout for API server to capture
    print(json.dumps(event), flush=True)


# Usage in task execution
emit_progress('task:started', {'task_id': task_id}, args.session_id)
emit_progress('tool:started', {'tool': tool_name, 'args': args}, args.session_id)
emit_progress('tool:completed', {'tool': tool_name, 'result': result}, args.session_id)
emit_progress('task:completed', {'task_id': task_id, 'duration': duration}, args.session_id)
```

---

## 3. Plan Status Library Changes (`scripts/lib/plan-status.js`)

### 3.1 New Functions Required

```javascript
// Template parsing
async function parseTemplateVariables(templatePath) {
  const content = await fs.readFile(templatePath, 'utf8');
  const matches = content.match(/\{\{(\w+)\}\}/g) || [];
  return [...new Set(matches.map(m => m.replace(/[{}]/g, '')))];
}

// Activity logging
async function logActivity(planPath, event) {
  const outputDir = getOutputDir(planPath);
  const activityPath = path.join(outputDir, 'activity.json');

  let activity = [];
  try {
    activity = JSON.parse(await fs.readFile(activityPath, 'utf8'));
  } catch (e) { /* New file */ }

  activity.push({
    ...event,
    timestamp: new Date().toISOString()
  });

  // Keep last 1000 events
  if (activity.length > 1000) {
    activity = activity.slice(-1000);
  }

  await fs.writeFile(activityPath, JSON.stringify(activity, null, 2));
}

// Archive plan
async function archivePlan(planPath) {
  const archiveDir = path.join('docs/plans/archive');
  await fs.mkdir(archiveDir, { recursive: true });

  const fileName = path.basename(planPath);
  const timestamp = new Date().toISOString().split('T')[0];
  const archiveName = `${fileName.replace('.md', '')}-${timestamp}.md`;

  await fs.rename(planPath, path.join(archiveDir, archiveName));

  return { archived: true, archivePath: path.join(archiveDir, archiveName) };
}
```

---

## 4. Configuration Changes

### 4.1 Git Workflow Config (`.claude/git-workflow.json`)

Add new settings:

```json
{
  "api": {
    "enabled": true,
    "port": 3100,
    "host": "localhost",
    "cors_origins": ["http://localhost:3000"]
  },
  "auto_commit": {
    "enabled": true,
    "on_task_complete": true,
    "on_task_fail": false,
    "commit_message_template": "[{plan}] task {task_id}: {description}"
  },
  "dashboard": {
    "allow_plan_creation": true,
    "allow_task_implementation": true,
    "allow_plan_archive": true
  }
}
```

### 4.2 Orchestrator Registry Schema

Extend registry to track more metadata:

```json
{
  "instances": [
    {
      "id": "orch-123",
      "plan": "my-plan",
      "status": "running",
      "pid": 12345,
      "started_at": "2024-01-01T00:00:00Z",
      "mode": "batch",
      "current_task": "2.1",
      "session_id": "sess-456",
      "api_initiated": true
    }
  ]
}
```

---

## 5. New Files Required

| File | Purpose | Priority |
|------|---------|----------|
| `scripts/lib/activity-logger.js` | Activity event logging | P1 |
| `scripts/lib/template-parser.js` | Parse plan templates | P0 |
| `scripts/lib/session-manager.js` | Track active Claude sessions | P0 |

---

## 6. Backend Change Summary

### By Priority

| Priority | Category | Changes |
|----------|----------|---------|
| **P0** | API Endpoints | 4 new endpoints (templates, plans POST, implement) |
| **P0** | Orchestrator | Single-task mode, auto-commit |
| **P0** | Config | auto_commit settings |
| **P1** | API Endpoints | 10 new endpoints (findings, activity, archive, etc.) |
| **P1** | WebSocket | Enhanced event types, session streaming |
| **P1** | Status Library | Activity logging, archive function |

### Effort Estimate

| Component | P0 Changes | P1 Changes | Total |
|-----------|------------|------------|-------|
| API Server | 2 days | 3 days | 5 days |
| Orchestrator | 1 day | 1 day | 2 days |
| Status Library | 0.5 day | 1 day | 1.5 days |
| Configuration | 0.5 day | 0.5 day | 1 day |
| **Total** | **4 days** | **5.5 days** | **9.5 days** |

---

## 7. Testing Requirements

### Unit Tests

- [ ] Template listing and parsing
- [ ] Plan creation with variables
- [ ] Single-task execution mode
- [ ] Auto-commit functionality
- [ ] Activity logging
- [ ] Archive operation

### Integration Tests

- [ ] API → Orchestrator → Status flow
- [ ] WebSocket session streaming
- [ ] Git commit during execution
- [ ] Error handling and recovery

### E2E Tests

- [ ] Create plan via API → View in dashboard
- [ ] Implement task via API → Monitor progress
- [ ] Archive plan → Verify hidden from list
