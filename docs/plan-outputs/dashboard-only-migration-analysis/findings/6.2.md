# Task 6.2: Design Approach for Critical Missing Features

## Overview

This document provides detailed technical designs for the three P0 (Critical) features identified in task 6.1 that must be implemented before CLI/TUI can be removed:

1. **Git Auto-Commit Integration** (Backend)
2. **Plan Creation Wizard** (Frontend + Backend)
3. **Task Implementation Trigger** (Frontend + Backend)

---

## 1. Git Auto-Commit Integration

### Problem Statement

When the orchestrator completes a task, changes are made to files but not committed to git. Users must manually commit changes, risking:
- Work loss if system crashes
- No audit trail per task
- Difficult to rollback individual tasks

### Design Goals

- Auto-commit after each task completion
- Commit message includes plan/task context
- Handle failures gracefully (don't block execution)
- Configurable enable/disable

### Technical Approach

#### Option A: Backend Enhancement (Recommended)

Enhance `plan_orchestrator.py` to call git commit after task completion.

**Pros:**
- Single point of implementation
- Works with existing orchestrator flow
- No dashboard changes needed

**Cons:**
- Python git operations
- May conflict with git-queue.js

**Implementation:**

```python
# In plan_orchestrator.py, after task completion

import subprocess

def auto_commit_task(plan_name: str, task_id: str, task_description: str):
    """Commit changes after task completion."""
    try:
        # Check if there are changes to commit
        result = subprocess.run(
            ["git", "status", "--porcelain"],
            capture_output=True, text=True
        )
        if not result.stdout.strip():
            return  # Nothing to commit

        # Stage all changes
        subprocess.run(["git", "add", "-A"], check=True)

        # Create commit with plan context
        commit_msg = f"[{plan_name}] task {task_id}: {task_description}"
        subprocess.run(
            ["git", "commit", "-m", commit_msg],
            check=True
        )
        logging.info(f"Auto-committed changes for task {task_id}")

    except subprocess.CalledProcessError as e:
        logging.warning(f"Auto-commit failed for task {task_id}: {e}")
        # Don't fail the task, just log the warning
```

**Configuration:**

Add to `.claude/git-workflow.json`:

```json
{
  "auto_commit": {
    "enabled": true,
    "on_task_complete": true,
    "on_task_fail": false,
    "include_plan_context": true,
    "commit_message_template": "[{plan}] task {task_id}: {description}"
  }
}
```

#### Option B: API Server Enhancement

Add a commit endpoint that dashboard can call.

**Endpoint:** `POST /api/plans/:name/commit`

**Request:**
```json
{
  "taskId": "1.1",
  "message": "optional custom message"
}
```

**Response:**
```json
{
  "success": true,
  "commitHash": "abc123",
  "filesChanged": 5
}
```

**Use Case:** Dashboard triggers commit after task completion event.

### Recommended Approach

**Use Option A** (Backend Enhancement) because:
- Automatic, no dashboard interaction needed
- Works with headless/daemon mode
- Consistent with existing orchestrator behavior

### Implementation Steps

1. Add `auto_commit_task()` function to `plan_orchestrator.py`
2. Call it after `markTaskCompleted()` in execution loop
3. Add configuration schema to git-workflow.json
4. Handle edge cases (merge conflicts, detached HEAD)
5. Add logging for audit trail

---

## 2. Plan Creation Wizard

### Problem Statement

Users cannot create new plans from the dashboard. They must:
1. Use CLI: `/plan:create`
2. Manually create markdown files
3. Initialize status.json manually

This blocks dashboard-only workflows.

### Design Goals

- Template browser with preview
- Variable substitution support
- Validation before save
- Auto-initialize status.json
- Redirect to new plan after creation

### Technical Approach

#### Frontend Components

**1. PlanCreationDialog (Modal)**

```tsx
interface PlanCreationDialogProps {
  open: boolean;
  onClose: () => void;
  onSuccess: (planName: string) => void;
}

function PlanCreationDialog({ open, onClose, onSuccess }: PlanCreationDialogProps) {
  const [step, setStep] = useState<'template' | 'config' | 'preview'>('template');
  const [selectedTemplate, setSelectedTemplate] = useState<string | null>(null);
  const [planName, setPlanName] = useState('');
  const [variables, setVariables] = useState<Record<string, string>>({});

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle>Create New Plan</DialogTitle>
        </DialogHeader>

        {step === 'template' && (
          <TemplateSelector
            onSelect={(template) => {
              setSelectedTemplate(template);
              setStep('config');
            }}
          />
        )}

        {step === 'config' && (
          <PlanConfigForm
            template={selectedTemplate}
            planName={planName}
            onPlanNameChange={setPlanName}
            variables={variables}
            onVariablesChange={setVariables}
            onNext={() => setStep('preview')}
            onBack={() => setStep('template')}
          />
        )}

        {step === 'preview' && (
          <PlanPreview
            template={selectedTemplate}
            planName={planName}
            variables={variables}
            onConfirm={handleCreate}
            onBack={() => setStep('config')}
          />
        )}
      </DialogContent>
    </Dialog>
  );
}
```

**2. TemplateSelector**

```tsx
function TemplateSelector({ onSelect }: { onSelect: (template: string) => void }) {
  const { data: templates, isLoading } = useTemplates();

  return (
    <div className="grid grid-cols-2 gap-4">
      {templates?.map((template) => (
        <TemplateCard
          key={template.name}
          template={template}
          onClick={() => onSelect(template.name)}
        />
      ))}
    </div>
  );
}
```

**3. PlanConfigForm**

```tsx
interface PlanConfigFormProps {
  template: string;
  planName: string;
  onPlanNameChange: (name: string) => void;
  variables: Record<string, string>;
  onVariablesChange: (vars: Record<string, string>) => void;
  onNext: () => void;
  onBack: () => void;
}

function PlanConfigForm(props: PlanConfigFormProps) {
  const { data: templateVars } = useTemplateVariables(props.template);

  return (
    <form className="space-y-4">
      <div>
        <Label htmlFor="planName">Plan Name</Label>
        <Input
          id="planName"
          value={props.planName}
          onChange={(e) => props.onPlanNameChange(e.target.value)}
          placeholder="my-new-feature"
        />
      </div>

      {templateVars?.map((variable) => (
        <div key={variable.name}>
          <Label htmlFor={variable.name}>{variable.label}</Label>
          <Input
            id={variable.name}
            value={props.variables[variable.name] || ''}
            onChange={(e) => props.onVariablesChange({
              ...props.variables,
              [variable.name]: e.target.value
            })}
            placeholder={variable.placeholder}
          />
          <p className="text-sm text-muted-foreground">{variable.description}</p>
        </div>
      ))}

      <div className="flex justify-between">
        <Button variant="outline" onClick={props.onBack}>Back</Button>
        <Button onClick={props.onNext}>Preview</Button>
      </div>
    </form>
  );
}
```

#### Backend API Endpoints

**1. GET /api/templates**

List available plan templates.

```json
{
  "templates": [
    {
      "name": "feature-implementation",
      "title": "Feature Implementation",
      "description": "Standard feature implementation plan",
      "variables": ["feature_name", "target_path"],
      "path": ".claude/templates/plans/feature-implementation.md"
    }
  ]
}
```

**2. GET /api/templates/:name**

Get template content and metadata.

```json
{
  "name": "feature-implementation",
  "title": "Feature Implementation",
  "content": "# {{feature_name}} Implementation Plan\n...",
  "variables": [
    {
      "name": "feature_name",
      "label": "Feature Name",
      "description": "Name of the feature to implement",
      "required": true
    }
  ]
}
```

**3. POST /api/plans**

Create a new plan.

**Request:**
```json
{
  "name": "my-new-feature",
  "template": "feature-implementation",
  "variables": {
    "feature_name": "User Authentication",
    "target_path": "src/auth"
  }
}
```

**Response:**
```json
{
  "success": true,
  "plan": {
    "name": "my-new-feature",
    "path": "docs/plans/my-new-feature.md",
    "statusPath": "docs/plan-outputs/my-new-feature/status.json"
  }
}
```

**Implementation Steps:**

1. Scan `.claude/templates/plans/` for templates
2. Parse template for `{{variable}}` placeholders
3. Substitute variables
4. Write to `docs/plans/{name}.md`
5. Initialize `docs/plan-outputs/{name}/status.json`
6. Create plan branch if git workflow enabled

### Validation Rules

| Rule | Check |
|------|-------|
| Plan name unique | No existing file with same name |
| Plan name valid | Alphanumeric + hyphens only |
| Required variables | All required variables provided |
| Template exists | Template file found |

### UI Flow

```
[Plans Page]
    → [+ Create Plan] button
    → [Plan Creation Dialog]
        → Step 1: Select Template (grid of template cards)
        → Step 2: Configure (plan name + template variables)
        → Step 3: Preview (rendered markdown preview)
        → [Create] → API call → Redirect to new plan
```

---

## 3. Task Implementation Trigger

### Problem Statement

Users cannot execute individual tasks from the dashboard. Current options:
1. Start full orchestrator (executes all pending tasks)
2. Use CLI: `/plan:implement 1.1`

Dashboard needs direct task execution for fine-grained control.

### Design Goals

- "Implement" button on each pending task
- Real-time progress feedback
- Handle completion/failure
- Update task status in UI

### Technical Approach

#### Design Option A: Claude Session via API (Recommended)

Spawn a Claude session via API, stream output back via WebSocket.

**Flow:**
```
Dashboard                 API Server              Claude
    |                         |                      |
    | POST /tasks/:id/impl    |                      |
    |------------------------>|                      |
    |                         | spawn claude session |
    |                         |--------------------->|
    |   WebSocket progress    |                      |
    |<========================| stream output        |
    |                         |<---------------------|
    |   task completed event  |                      |
    |<------------------------|                      |
```

#### Frontend Implementation

**1. TaskActions Component Enhancement**

```tsx
function TaskActions({ task, orchestratorId }: TaskActionsProps) {
  const implementMutation = useImplementTask();
  const [isImplementing, setIsImplementing] = useState(false);

  const handleImplement = async () => {
    setIsImplementing(true);
    try {
      await implementMutation.mutateAsync({
        orchestratorId,
        taskId: task.id
      });
      // Task completion handled via WebSocket event
    } catch (error) {
      toast.error(`Failed to implement task: ${error.message}`);
    } finally {
      setIsImplementing(false);
    }
  };

  return (
    <div className="flex gap-2">
      {task.status === 'pending' && (
        <Button
          size="sm"
          onClick={handleImplement}
          disabled={isImplementing}
        >
          {isImplementing ? (
            <>
              <Loader2 className="h-4 w-4 animate-spin mr-1" />
              Implementing...
            </>
          ) : (
            <>
              <Play className="h-4 w-4 mr-1" />
              Implement
            </>
          )}
        </Button>
      )}

      {task.status === 'pending' && (
        <Button size="sm" variant="outline" onClick={() => onExplain(task.id)}>
          <Info className="h-4 w-4 mr-1" />
          Explain
        </Button>
      )}

      {task.status === 'completed' && (
        <Button size="sm" variant="outline" onClick={() => onVerify(task.id)}>
          <CheckCircle className="h-4 w-4 mr-1" />
          Verify
        </Button>
      )}
    </div>
  );
}
```

**2. Implementation Progress Modal**

```tsx
function ImplementationProgress({ taskId, onClose }: ImplementationProgressProps) {
  const [logs, setLogs] = useState<string[]>([]);
  const [status, setStatus] = useState<'running' | 'completed' | 'failed'>('running');

  // Subscribe to WebSocket for task progress
  useWebSocket({
    url: `/ws/tasks/${taskId}`,
    onMessage: (event) => {
      if (event.type === 'log') {
        setLogs(prev => [...prev, event.data]);
      }
      if (event.type === 'completed') {
        setStatus('completed');
      }
      if (event.type === 'failed') {
        setStatus('failed');
      }
    }
  });

  return (
    <Dialog open onOpenChange={onClose}>
      <DialogContent className="max-w-2xl h-[600px]">
        <DialogHeader>
          <DialogTitle>
            Implementing Task {taskId}
            <StatusBadge status={status} />
          </DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-auto font-mono text-sm bg-black text-green-400 p-4 rounded">
          {logs.map((log, i) => (
            <div key={i}>{log}</div>
          ))}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose}>
            {status === 'running' ? 'Run in Background' : 'Close'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

#### Backend API Endpoints

**1. POST /api/plans/:name/tasks/:taskId/implement**

Start implementation of a specific task.

**Request:**
```json
{
  "autonomous": true,
  "timeout": 300000
}
```

**Response:**
```json
{
  "success": true,
  "sessionId": "sess-123",
  "wsEndpoint": "/ws/sessions/sess-123"
}
```

**Implementation:**

```javascript
// In api-server.js

app.post('/api/plans/:name/tasks/:taskId/implement', async (req, res) => {
  const { name, taskId } = req.params;
  const { autonomous = true, timeout = 300000 } = req.body;

  try {
    // Validate task exists and is pending
    const status = await planStatus.loadStatus(name);
    const task = status.tasks.find(t => t.id === taskId);

    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }

    if (task.status !== 'pending') {
      return res.status(400).json({ error: `Task is ${task.status}, not pending` });
    }

    // Generate session ID
    const sessionId = `sess-${Date.now()}`;

    // Spawn Claude session for this task
    const args = [
      'python3', 'scripts/plan_orchestrator.py',
      '--plan', `docs/plans/${name}.md`,
      '--task', taskId,
      '--single-task',
      '--no-tui',
      '--session-id', sessionId
    ];

    if (autonomous) args.push('--autonomous');

    const child = spawn(args[0], args.slice(1), {
      cwd: process.cwd(),
      stdio: ['ignore', 'pipe', 'pipe']
    });

    // Track session
    activeSessions.set(sessionId, {
      process: child,
      taskId,
      planName: name,
      startedAt: new Date()
    });

    // Stream output to WebSocket subscribers
    child.stdout.on('data', (data) => {
      broadcastToSession(sessionId, { type: 'log', data: data.toString() });
    });

    child.on('close', (code) => {
      const status = code === 0 ? 'completed' : 'failed';
      broadcastToSession(sessionId, { type: status });
      activeSessions.delete(sessionId);
    });

    res.json({
      success: true,
      sessionId,
      wsEndpoint: `/ws/sessions/${sessionId}`
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

**2. WebSocket /ws/sessions/:sessionId**

Real-time session output streaming.

**Events:**
```typescript
type SessionEvent =
  | { type: 'log', data: string }
  | { type: 'tool_call', name: string, args: any }
  | { type: 'completed', duration: number }
  | { type: 'failed', error: string };
```

### Orchestrator Enhancement

Add `--single-task` mode to `plan_orchestrator.py`:

```python
parser.add_argument('--single-task', action='store_true',
    help='Execute only the specified task, then exit')
parser.add_argument('--session-id', type=str,
    help='Session ID for API tracking')
```

**Execution Logic:**

```python
if args.single_task and args.task:
    # Execute single task mode
    task = get_task_by_id(args.task)
    execute_task(task)
    sys.exit(0 if task.status == 'completed' else 1)
```

---

## Implementation Summary

| Feature | Frontend | Backend | Effort |
|---------|----------|---------|--------|
| Git Auto-Commit | None | Medium | 1-2 days |
| Plan Creation | High | Medium | 2-3 days |
| Task Implementation | Medium | High | 3-5 days |

### Dependencies

```
Git Auto-Commit (independent)
                              ↓
Plan Creation ← (can proceed in parallel) → Task Implementation
                              ↓
                 Dashboard-Only Ready
```

### Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Git conflicts during auto-commit | Queue commits, skip on conflict |
| Template variable validation | Server-side validation before save |
| Claude session timeouts | Configurable timeout, graceful failure |
| Concurrent task execution | One task per plan at a time (lock) |

---

## Acceptance Criteria

### Git Auto-Commit
- [ ] Changes committed after each task completion
- [ ] Commit message includes plan and task context
- [ ] Failures logged but don't block execution
- [ ] Configurable via git-workflow.json

### Plan Creation Wizard
- [ ] Template list loads from filesystem
- [ ] Variables extracted and displayed
- [ ] Plan name validation (unique, valid chars)
- [ ] Plan file and status.json created
- [ ] Redirect to new plan after creation

### Task Implementation Trigger
- [ ] "Implement" button on pending tasks
- [ ] Real-time log streaming in modal
- [ ] Task status updates on completion
- [ ] Error handling with user feedback
- [ ] Background execution option
