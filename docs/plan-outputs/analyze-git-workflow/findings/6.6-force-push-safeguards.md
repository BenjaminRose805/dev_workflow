# Task 6.6: Safeguards Against Force Push and History Rewrite

## Executive Summary

Force push (`git push --force`) and history rewriting operations (`git rebase`, `git reset`, `git commit --amend`) are high-risk operations that can cause irreversible data loss. This analysis designs a **multi-layer protection system** for the plan orchestration environment.

**Key Recommendation:** Implement command-level blocking, branch protection integration, and recovery mechanisms. The orchestrator should NEVER perform force push operations by default.

---

## 1. Risk Assessment

### 1.1 Dangerous Operations

| Operation | Risk Level | Data Loss Type |
|-----------|------------|----------------|
| `git push --force` | CRITICAL | Remote history overwritten |
| `git push --force-with-lease` | HIGH | Remote history overwritten (safer) |
| `git reset --hard` | HIGH | Local commits + changes lost |
| `git reset --mixed` | MEDIUM | Commits lost, changes unstaged |
| `git rebase` (on shared branch) | HIGH | Shared history rewritten |
| `git commit --amend` (after push) | HIGH | Divergent history created |
| `git clean -fd` | MEDIUM | Untracked files deleted |
| `git checkout -f` | MEDIUM | Local changes discarded |

### 1.2 Impact in Orchestrator Context

| Scenario | Impact | Recovery Difficulty |
|----------|--------|-------------------|
| Force push plan branch | HIGH | Reflog recovery, team disruption |
| Force push main/master | CRITICAL | May lose team work |
| Reset during task execution | HIGH | Partial task state, confused status.json |
| Rebase plan branch | MEDIUM | Commit SHAs change, tracking breaks |
| Amend after phase commit | MEDIUM | Divergent history if pushed |

### 1.3 Orchestrator-Specific Risks

1. **Autonomous execution**: AI may suggest force push as "fix"
2. **Status tracking**: SHA-based tracking breaks after rebase
3. **Rollback corruption**: Task rollback depends on consistent history
4. **Team workflows**: Force push affects all collaborators

---

## 2. Protection Layers

### Layer 1: Command Blocking (Local)

Prevent dangerous commands from executing in the orchestrator context.

```bash
#!/bin/bash
# .git/hooks/pre-push

# Check for force push attempts
while read local_ref local_sha remote_ref remote_sha; do
    # Detect force push
    if [ "$remote_sha" != "0000000000000000000000000000000000000000" ]; then
        # Remote ref exists, check if we're rewriting history
        merge_base=$(git merge-base "$local_sha" "$remote_sha" 2>/dev/null)
        if [ "$merge_base" != "$remote_sha" ]; then
            echo "ERROR: Force push detected!"
            echo "  Local: $local_sha"
            echo "  Remote: $remote_sha"
            echo "  Merge base: $merge_base"
            echo ""
            echo "Force push is blocked by orchestrator policy."
            echo "Use --no-verify to bypass (NOT RECOMMENDED)."
            exit 1
        fi
    fi
done
```

### Layer 2: Git Alias Overrides

```bash
# In .gitconfig or project-local config
[alias]
    # Safe alternatives
    force-push = "!echo 'Force push is disabled. Use: git push --force-with-lease' && false"
    push-force = "!echo 'Force push is disabled. Use: git push --force-with-lease' && false"

    # Audit wrappers
    reset = "!f() { echo '[AUDIT] git reset $@' >> .git/audit.log; git reset-real \"$@\"; }; f"
```

### Layer 3: Branch Protection (GitHub/GitLab)

```yaml
# .github/branch-protection.yml (GitHub Actions format)
protection:
  main:
    required_pull_request_reviews: true
    required_status_checks: true
    enforce_admins: true
    restrictions:
      users: []
      teams: []
    allow_force_pushes: false         # KEY SETTING
    allow_deletions: false

  "plan/*":
    allow_force_pushes: false         # Protect plan branches too
    required_status_checks: false     # Less strict than main
```

### Layer 4: Orchestrator Command Filtering

```javascript
// In /plan:implement or orchestrator subprocess

const BLOCKED_COMMANDS = [
    'git push --force',
    'git push -f',
    'git reset --hard',
    'git rebase',  // Interactive rebase on shared branches
    'git commit --amend',  // After push
];

const ALLOWED_WITH_WARNING = [
    'git push --force-with-lease',
    'git reset --soft',
    'git reset --mixed',
];

function validateGitCommand(command) {
    const normalized = command.toLowerCase().trim();

    for (const blocked of BLOCKED_COMMANDS) {
        if (normalized.includes(blocked)) {
            throw new Error(`BLOCKED: "${blocked}" is not allowed in orchestrator mode`);
        }
    }

    for (const warning of ALLOWED_WITH_WARNING) {
        if (normalized.includes(warning)) {
            console.warn(`WARNING: "${warning}" detected. Proceed with caution.`);
            return { allowed: true, warning: true };
        }
    }

    return { allowed: true, warning: false };
}
```

---

## 3. Force Push Prevention

### 3.1 Never Force Push from Orchestrator

The orchestrator should NEVER include `--force` in push commands:

```javascript
// WRONG
execSync('git push --force origin plan/my-plan');

// RIGHT
execSync('git push origin plan/my-plan');

// If conflicts exist, report to user
if (pushResult.includes('rejected')) {
    console.error('Push rejected - remote has changes');
    console.error('Run: git pull --rebase origin plan/my-plan');
    return { status: 'blocked', reason: 'remote_conflict' };
}
```

### 3.2 Force-With-Lease as Fallback

If force push is truly needed (rare), use `--force-with-lease`:

```bash
# Instead of:
git push --force origin plan/my-plan

# Use:
git push --force-with-lease origin plan/my-plan

# --force-with-lease checks that remote hasn't changed since last fetch
# This prevents overwriting others' work
```

### 3.3 User Confirmation for Force Operations

```
⚠ DANGEROUS OPERATION REQUESTED

You are attempting: git push --force-with-lease origin plan/my-plan

This will overwrite remote history. Potential consequences:
  • Other collaborators' local branches will be out of sync
  • Any work pushed by others may be lost
  • CI/CD pipelines may fail or produce incorrect results

Current state:
  Local:  abc1234 "task(1.5): Add logout"
  Remote: def5678 "task(1.4): Add refresh tokens"

Are you sure? Type 'FORCE' to confirm: _
```

---

## 4. History Rewrite Safeguards

### 4.1 Amend Protection

```javascript
function isAmendSafe() {
    // Check if HEAD has been pushed
    const result = execSync('git status -sb').toString();

    if (result.includes('ahead')) {
        // Ahead of remote - amend is safe
        return { safe: true };
    }

    if (result.includes('behind') || !result.includes('[')) {
        // Behind or in sync - amend would require force push
        return {
            safe: false,
            reason: 'HEAD has been pushed. Amending would require force push.'
        };
    }

    return { safe: true };
}
```

### 4.2 Rebase Protection

```javascript
const PROTECTED_BRANCHES = ['main', 'master', 'develop'];

function isRebaseSafe(targetBranch) {
    const currentBranch = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();

    // Never rebase protected branches
    if (PROTECTED_BRANCHES.includes(currentBranch)) {
        return {
            safe: false,
            reason: `Cannot rebase protected branch: ${currentBranch}`
        };
    }

    // Check if branch is shared (has remote tracking)
    const trackingResult = execSync(`git rev-parse --abbrev-ref ${currentBranch}@{upstream} 2>/dev/null || echo "none"`);
    if (trackingResult.toString().trim() !== 'none') {
        return {
            safe: false,
            reason: 'Branch has remote tracking. Rebase would rewrite shared history.',
            suggestion: 'Use merge instead: git merge ' + targetBranch
        };
    }

    return { safe: true };
}
```

### 4.3 Reset Protection

```javascript
function isResetSafe(mode, target) {
    // --hard always dangerous without explicit backup
    if (mode === '--hard') {
        const hasUncommittedChanges = execSync('git status --porcelain').toString().trim();
        if (hasUncommittedChanges) {
            return {
                safe: false,
                reason: 'Uncommitted changes would be lost',
                suggestion: 'Stash changes first: git stash push -u'
            };
        }
    }

    // Check if resetting past pushed commits
    const currentSha = execSync('git rev-parse HEAD').toString().trim();
    const targetSha = execSync(`git rev-parse ${target}`).toString().trim();

    // TODO: Compare with remote to detect pushed commits
    // that would be "lost" from local history

    return { safe: true };
}
```

---

## 5. Recovery Mechanisms

### 5.1 Reflog Recovery

Git's reflog maintains history of HEAD changes for 90 days:

```bash
# View reflog
git reflog

# Output:
# abc1234 HEAD@{0}: commit: task(1.5): Add logout
# def5678 HEAD@{1}: commit: task(1.4): Add refresh tokens
# ghi9012 HEAD@{2}: reset: moving to HEAD~2  <-- Accidental reset!

# Recover from accidental reset
git reset --hard HEAD@{1}  # Go back to previous state
```

### 5.2 Automatic Backup Before Dangerous Operations

```javascript
async function createBackupBranch(reason) {
    const currentBranch = getCurrentBranch();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupName = `backup/${currentBranch}-${timestamp}`;

    execSync(`git branch ${backupName}`);
    console.log(`Created backup branch: ${backupName}`);

    // Log the backup
    const logEntry = {
        timestamp: new Date().toISOString(),
        branch: currentBranch,
        backup: backupName,
        reason: reason,
        sha: execSync('git rev-parse HEAD').toString().trim()
    };

    fs.appendFileSync('.git/backup-log.json',
        JSON.stringify(logEntry) + '\n');

    return backupName;
}
```

### 5.3 Remote Recovery

If force push has occurred:

```bash
# On GitHub, check "Activity" tab for previous SHA
# Or use GitHub's branch protection to block force push

# From local reflog of another collaborator:
git fetch origin
git checkout plan/my-plan
git reflog show origin/plan/my-plan
# Find the SHA before force push

# Restore:
git reset --hard <previous-sha>
git push --force-with-lease origin plan/my-plan
```

---

## 6. Orchestrator-Specific Safeguards

### 6.1 Status.json SHA Tracking

Track commit SHAs in status.json to detect history changes:

```json
{
    "tasks": [
        {
            "id": "1.1",
            "status": "completed",
            "commitSha": "abc1234",
            "completedAt": "2025-12-24T10:00:00Z"
        }
    ],
    "git": {
        "lastKnownHead": "abc1234",
        "branchName": "plan/my-plan"
    }
}
```

### 6.2 History Consistency Check

```javascript
function validateHistoryConsistency() {
    const status = readStatusJson();
    const currentHead = execSync('git rev-parse HEAD').toString().trim();

    // Check if any completed task SHAs are missing from history
    for (const task of status.tasks) {
        if (task.status === 'completed' && task.commitSha) {
            const exists = execSync(`git cat-file -t ${task.commitSha} 2>/dev/null || echo "missing"`);
            if (exists.toString().trim() === 'missing') {
                return {
                    valid: false,
                    reason: `Task ${task.id} commit ${task.commitSha} no longer exists in history`,
                    suggestion: 'History may have been rewritten. Check git reflog.'
                };
            }
        }
    }

    return { valid: true };
}
```

### 6.3 Pre-Session Validation

Before starting orchestration:

```javascript
async function preSessionValidation() {
    // 1. Check history consistency
    const historyCheck = validateHistoryConsistency();
    if (!historyCheck.valid) {
        console.error(`History inconsistency: ${historyCheck.reason}`);
        return false;
    }

    // 2. Check for divergent history
    const divergence = checkBranchDivergence();
    if (divergence.behind > 0) {
        console.warn(`Branch is ${divergence.behind} commits behind remote`);
        console.warn('Consider: git pull --rebase');
    }

    // 3. Check for force push markers
    const forcePushDetected = checkForcePosition();
    if (forcePushDetected) {
        console.error('Remote history appears to have been force pushed');
        return false;
    }

    return true;
}
```

---

## 7. Claude Code Integration

### 7.1 Instruction in CLAUDE.md

```markdown
## Git Safety Rules

NEVER use these commands in autonomous mode:
- `git push --force` or `git push -f`
- `git reset --hard` (without explicit user confirmation)
- `git rebase` on branches with remote tracking
- `git commit --amend` on pushed commits

ALWAYS prefer:
- Regular `git push` (let it fail if rejected)
- `git reset --soft` to uncommit while keeping changes
- `git merge` instead of rebase for shared branches
- New commits instead of amending pushed history
```

### 7.2 Tool Call Filtering

The orchestrator could filter Claude's bash commands:

```javascript
// Intercept Bash tool calls
function filterBashCommand(command) {
    if (command.includes('--force') && command.includes('push')) {
        return {
            blocked: true,
            reason: 'Force push is blocked by safety policy',
            alternative: command.replace('--force', '').trim()
        };
    }

    if (command.includes('reset --hard')) {
        return {
            blocked: true,
            reason: 'Hard reset is blocked. Use --soft or --mixed.',
            alternative: command.replace('--hard', '--soft')
        };
    }

    return { blocked: false };
}
```

---

## 8. Branch Protection Rules

### 8.1 GitHub Branch Protection

```
Repository Settings → Branches → Branch protection rules

Rule: main
  ☑ Require pull request reviews before merging
  ☑ Require status checks to pass before merging
  ☑ Include administrators
  ☐ Allow force pushes → DISABLED
  ☐ Allow deletions → DISABLED

Rule: plan/*
  ☐ Require pull request reviews
  ☐ Require status checks
  ☐ Allow force pushes → DISABLED
  ☐ Allow deletions → Consider DISABLED
```

### 8.2 GitLab Protected Branches

```yaml
# .gitlab-ci.yml or via UI
protected_branches:
  main:
    push_access_level: maintainer
    merge_access_level: developer
    allow_force_push: false
    code_owner_approval_required: true

  "plan/*":
    push_access_level: developer
    merge_access_level: developer
    allow_force_push: false
```

### 8.3 Server-Side Hooks

```bash
#!/bin/bash
# server-side: hooks/update

refname="$1"
oldrev="$2"
newrev="$3"

# Block force pushes on protected patterns
protected_refs="^refs/heads/(main|master|plan/)"

if [[ $refname =~ $protected_refs ]]; then
    # Check for force push (oldrev is not ancestor of newrev)
    if ! git merge-base --is-ancestor "$oldrev" "$newrev" 2>/dev/null; then
        echo "ERROR: Force push to $refname is not allowed"
        exit 1
    fi
fi

exit 0
```

---

## 9. Audit Trail

### 9.1 Operation Logging

```javascript
function logDangerousOperation(operation, details) {
    const entry = {
        timestamp: new Date().toISOString(),
        operation: operation,
        user: process.env.USER || 'unknown',
        branch: getCurrentBranch(),
        headBefore: execSync('git rev-parse HEAD').toString().trim(),
        details: details,
        source: 'orchestrator'  // or 'manual', 'ci'
    };

    fs.appendFileSync('orchestrator.log',
        `[DANGER] ${JSON.stringify(entry)}\n`);
}

// Example usage
logDangerousOperation('reset', {
    mode: '--hard',
    target: 'HEAD~3',
    filesLost: 15
});
```

### 9.2 Alert Configuration

```yaml
# orchestrator.config.yaml
alerts:
  dangerous_operations:
    - type: force_push
      action: block
      notify: true
    - type: hard_reset
      action: warn
      require_confirmation: true
    - type: history_rewrite
      action: warn
      create_backup: true
```

---

## 10. Summary

### Protection Matrix

| Operation | Default Behavior | With Flag | Audit |
|-----------|-----------------|-----------|-------|
| `push --force` | BLOCK | BLOCK | Yes |
| `push --force-with-lease` | WARN | ALLOW with confirm | Yes |
| `reset --hard` | WARN | ALLOW with confirm | Yes |
| `reset --soft/--mixed` | ALLOW | ALLOW | Yes |
| `rebase` (shared branch) | BLOCK | WARN | Yes |
| `rebase` (local only) | ALLOW | ALLOW | No |
| `commit --amend` (unpushed) | ALLOW | ALLOW | No |
| `commit --amend` (pushed) | WARN | BLOCK | Yes |

### Implementation Priority

1. **CRITICAL:** Command blocking in orchestrator (push --force)
2. **HIGH:** Pre-push hook for local protection
3. **HIGH:** Branch protection on remote (GitHub/GitLab)
4. **MEDIUM:** Automatic backup before dangerous ops
5. **MEDIUM:** History consistency validation
6. **LOW:** Audit logging and alerts

### Key Design Principles

1. **Defense in Depth:** Multiple layers of protection
2. **Fail Closed:** Block by default, allow explicitly
3. **Recoverability:** Always maintain recovery options (reflog, backups)
4. **Visibility:** Log all dangerous operations
5. **User Control:** Allow override with explicit confirmation

**Estimated Implementation Effort:** 8-10 hours total.
