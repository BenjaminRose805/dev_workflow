# Task 1.5: Conflict Resolution Analysis

## Overview

This analysis examines conflict scenarios that can arise during automated plan execution and evaluates strategies to prevent, detect, and resolve them. The analysis considers the current system architecture, including file locking mechanisms, parallel execution capabilities, and git integration patterns.

## 1. Parallel Plans on Same Codebase

### 1.1 Conflict Scenarios

**Scenario A: Different Files, Same Branch**
- Plan A modifies `src/auth.js`
- Plan B modifies `src/payments.js`
- Both working on `master` branch simultaneously
- **Conflict Type:** Git merge conflicts when both try to commit
- **Current State:** NOT PREVENTED - no branch isolation exists

**Scenario B: Same Files, Different Plans**
- Plan A refactors `src/utils.js` (line 10-50)
- Plan B adds features to `src/utils.js` (line 60-100)
- **Conflict Type:** Textual git conflicts + semantic conflicts (shared dependencies)
- **Current State:** NOT PREVENTED - no file-level claiming system

**Scenario C: Overlapping Dependencies**
- Plan A updates `package.json` (adds library X)
- Plan B updates `package.json` (adds library Y)
- **Conflict Type:** Structural conflicts in JSON files
- **Current State:** HIGH RISK - JSON merge conflicts common

### 1.2 Branch-Based Isolation Strategy

**Recommended Approach:**
```bash
# Plan A
git checkout -b plan/architecture-review
# ... execute tasks ...
git add -A && git commit -m "task 1.1: ..."

# Plan B (concurrent)
git checkout -b plan/implement-authentication
# ... execute tasks ...
git add -A && git commit -m "task 1.1: ..."
```

**Benefits:**
- Complete isolation during execution
- Parallel plans cannot interfere
- Conflicts deferred to merge time (controlled)
- Easy rollback per plan (delete branch)

**Drawbacks:**
- Merge conflicts still occur (just later)
- Base branch (master) diverges during long plans
- Need rebase/merge strategy
- Branch management overhead

### 1.3 Single-Branch Conflicts

**Current System (No Branch Isolation):**
- All plans commit to `master`
- First commit wins, second gets conflict
- Requires manual conflict resolution mid-execution
- High risk of corrupting plan state

**Conflict Example:**
```bash
# Plan A completes task 1.1
git add src/auth.js
git commit -m "task 1.1: Add middleware"

# Plan B completes task 1.1 (different plan)
git add src/auth.js  # Modified independently
git commit -m "task 1.1: Add validators"
# ERROR: Working tree has uncommitted changes
# Plan B orchestrator crashes or requires manual intervention
```

### 1.4 Merge Sequencing and Priority

**Without Priority System:**
- Plans merge in completion order (first-come-first-served)
- No consideration of plan importance or dependencies

**With Priority System:**
```json
{
  "plan": "critical-security-fix",
  "priority": "high",
  "mergeBehavior": "rebase-and-merge",
  "conflictStrategy": "pause-for-manual"
}
```

**Recommended Sequencing:**
1. **Critical fixes** - Merge immediately upon completion
2. **Feature plans** - Merge in dependency order
3. **Refactoring plans** - Merge last (broadest changes)

## 2. Concurrent Edits

### 2.1 Human Developer Editing While Plan Runs

**Scenario A: Developer Edits Different Files**
- Plan is modifying `src/backend/`
- Developer edits `src/frontend/`
- **Risk:** Low if branches separate concerns
- **Detection:** Git status shows uncommitted changes in working tree

**Scenario B: Developer Edits Same Files**
- Plan is refactoring `src/utils.js`
- Developer fixes bug in `src/utils.js`
- **Risk:** HIGH - developer's work will be overwritten or create conflict
- **Detection:** File modification time checks, git diff

**Current Protection:**
- `proper-lockfile` prevents concurrent status.json writes
- NO protection for source file conflicts
- /plan:implement doesn't check for uncommitted changes before starting

**Recommended Protection:**
```bash
# Before starting plan execution
git diff-index --quiet HEAD -- || {
  echo "ERROR: Uncommitted changes detected. Commit or stash before running plan."
  exit 1
}

# Alternative: Auto-stash pattern
if ! git diff-index --quiet HEAD --; then
  git stash push -m "Auto-stash before plan: $PLAN_NAME"
  echo "Stashed uncommitted changes. Run 'git stash pop' to restore."
fi
```

### 2.2 Multiple Agents/Workers in Orchestrator

**Current Architecture:**
- `parallel-agents.js` runs up to 5 concurrent agents (configurable)
- Each agent can execute file operations (Edit, Write)
- status.json protected by `proper-lockfile`
- Source files NOT protected by locks

**Conflict Scenarios:**

**File-Level Conflicts:**
```javascript
// Agent 1 (task 1.1)
Edit('src/utils.js', { old: 'function foo()', new: 'function foo(x)' })

// Agent 2 (task 1.2) - CONCURRENT
Edit('src/utils.js', { old: 'function bar()', new: 'function bar(y)' })

// Result: Whichever Edit executes first wins
// Second Edit may fail if old_string no longer matches
// OR succeeds but overwrites Agent 1's changes
```

**Race Condition Protection:**

Current system has:
- **status.json** - Protected by `proper-lockfile` with retry logic
- **Atomic writes** - Uses temp file + rename pattern
- **Source files** - No locking mechanism
- **Git operations** - No coordination between agents

**Recommended Enhancement:**
```javascript
// File-level claim system
const FileClaims = {
  claim: async (filePath, agentId) => {
    // Try to acquire exclusive lock on file
    const lockPath = `${filePath}.lock`;
    await lockfile.lock(lockPath, { ... });
    return { release: async () => { ... } };
  }
};

// Usage in agent
const claim = await FileClaims.claim('src/utils.js', task.id);
try {
  // Perform edits
  await Edit('src/utils.js', ...);
} finally {
  await claim.release();
}
```

### 2.3 External CI/CD Modifying Files

**Scenario: Auto-Formatters Running During Plan Execution**

**Conflict:**
1. Plan commits task 1.1 -> triggers CI
2. CI reformats code and pushes to branch
3. Plan commits task 1.2 -> `git push` rejected (remote has changes)
4. Orchestrator needs to pull -> potential merge conflicts

**Current State:**
- No CI/CD integration in current system
- /plan:implement doesn't push to remote
- Python orchestrator doesn't interact with git

**Recommended Safeguards:**
```bash
# Before each commit
git fetch origin
git diff HEAD origin/$(git branch --show-current) --quiet || {
  echo "Remote branch has diverged. Pull and resolve conflicts."
  exit 1
}
```

### 2.4 Race Conditions in File Modifications

**Scenario: Read-Modify-Write Race**

```javascript
// Agent 1 reads
const content = await Read('config.json'); // { "port": 3000 }
// Agent 2 reads (same content)
const content = await Read('config.json'); // { "port": 3000 }

// Agent 1 modifies and writes
const updated = { ...content, timeout: 5000 };
await Write('config.json', JSON.stringify(updated)); // { "port": 3000, "timeout": 5000 }

// Agent 2 modifies and writes (OVERWRITES Agent 1's change)
const updated = { ...content, retries: 3 };
await Write('config.json', JSON.stringify(updated)); // { "port": 3000, "retries": 3 }

// Result: timeout field lost
```

**Current Protection:** NONE for source files

**Recommended Solution:**
```javascript
// Optimistic locking with version check
const { content, version } = await Read('config.json');
// ... modify content ...
await Write('config.json', newContent, { expectedVersion: version });
// Fails if version changed (another agent wrote)
```

## 3. Conflict Detection

### 3.1 Early Detection vs Merge-Time Detection

**Early Detection (Preventive):**
```bash
# Before starting task
git fetch origin
git merge-base --is-ancestor origin/master HEAD || {
  echo "Branch has diverged from master. Rebase required."
  exit 1
}

# Before file edit
if [ -f "$FILE.lock" ]; then
  echo "File $FILE is locked by another task"
  exit 1
fi
```

**Pros:**
- Prevents wasted work
- Fails fast
- Clearer error messages

**Cons:**
- More checks = slower execution
- May block unnecessarily (false positives)

**Merge-Time Detection (Deferred):**
```bash
# After all tasks complete
git merge master || {
  echo "Merge conflicts detected. Manual resolution required."
  git merge --abort
  exit 1
}
```

**Pros:**
- Fewer interruptions during execution
- Natural git conflict resolution tools
- May auto-resolve many conflicts

**Cons:**
- Discover conflicts after hours of work
- Requires manual intervention at worst time
- May lose uncommitted changes

**Recommended Hybrid Approach:**
1. **Pre-flight check** - Verify clean state before plan starts
2. **Per-phase check** - Check for divergence between phases
3. **Merge-time resolution** - Use git's conflict resolution at merge

### 3.2 File-Level vs Line-Level Conflicts

**File-Level Detection:**
```bash
# Check if file was modified in both branches
git diff --name-only master...plan/feature-x
# Output: src/utils.js

git diff --name-only master...plan/feature-y
# Output: src/utils.js

# CONFLICT: Both plans modified same file
```

**Line-Level Detection:**
```bash
# Check if same lines modified
git diff master...plan/feature-x -- src/utils.js | grep "@@"
# Output: @@ -10,5 +10,8 @@ (lines 10-15)

git diff master...plan/feature-y -- src/utils.js | grep "@@"
# Output: @@ -50,3 +50,6 @@ (lines 50-53)

# NO CONFLICT: Different line ranges
```

**Semantic Conflict (Not Detectable by Git):**
```javascript
// Plan A renames function
function calculateTotal(items) { ... }

// Plan B calls old function name
const result = calculatePrice(cartItems); // ERROR: calculatePrice undefined
```

**Detection Strategy:**
- **File-level** - Simple, fast, conservative (may false-positive)
- **Line-level** - More accurate, still misses semantic conflicts
- **Semantic** - Requires testing/linting, run after merge

**Recommended:**
1. File-level pre-check (early warning)
2. Line-level at merge (git handles)
3. Semantic via CI/CD (tests after merge)

### 3.3 Automated Conflict Scanning

**Proposed Tool:**
```bash
#!/bin/bash
# scripts/scan-conflicts.sh

CURRENT_BRANCH=$(git branch --show-current)
BASE_BRANCH=${1:-master}

echo "Scanning for conflicts between $CURRENT_BRANCH and $BASE_BRANCH..."

# Get files modified in current branch
MODIFIED_FILES=$(git diff --name-only $BASE_BRANCH...$CURRENT_BRANCH)

# Check each file for potential conflicts
for FILE in $MODIFIED_FILES; do
  # Check if file was also modified in base branch since divergence
  BASE_COMMIT=$(git merge-base $BASE_BRANCH $CURRENT_BRANCH)
  BASE_CHANGES=$(git diff --name-only $BASE_COMMIT..$BASE_BRANCH -- $FILE)

  if [ -n "$BASE_CHANGES" ]; then
    echo "Warning: Potential conflict in $FILE"
    # Try merge simulation
    git merge-tree $BASE_COMMIT $BASE_BRANCH $CURRENT_BRANCH | grep -q "<<<<<" && {
      echo "   -> Confirmed conflict (overlapping changes)"
    }
  fi
done
```

**Integration Points:**
1. Run before `/plan:set` (switch plans) - "New plan may conflict with uncommitted work"
2. Run before `/plan:complete` (merge) - "Merge will have conflicts"
3. Run periodically in orchestrator - "Divergence detected, rebase recommended"

## 4. Conflict Resolution Strategies

### 4.1 Automatic Resolution Rules

**Git Merge Strategies:**

```bash
# Strategy 1: Ours (keep current plan's changes)
git merge -s ours master

# Strategy 2: Theirs (keep master's changes)
git merge -X theirs master

# Strategy 3: Union (combine both, may break)
git merge -X union master
```

**When to Auto-Resolve:**
- Non-overlapping line changes in same file
- File added in one branch, modified in other
- Whitespace-only conflicts (`-Xignore-space-change`)
- NOT for overlapping logic changes
- NOT for structural conflicts (JSON, YAML)
- NOT for conflicting imports/dependencies

**Recommended Auto-Resolve Rules:**
```json
{
  "autoResolve": {
    "whitespace": true,
    "generatedFiles": {
      "patterns": ["package-lock.json", "*.min.js"],
      "strategy": "theirs"
    },
    "configFiles": {
      "patterns": ["*.json", "*.yaml"],
      "strategy": "manual"
    }
  }
}
```

### 4.2 Pause and Prompt for Human Resolution

**Detection Point:**
```bash
git merge plan/feature-x || {
  # Merge failed with conflicts
  CONFLICTS=$(git diff --name-only --diff-filter=U)
  echo "Merge conflicts in: $CONFLICTS"
  echo "Resolve manually and run: git merge --continue"

  # Pause orchestrator
  exit 2  # Special exit code = "paused for manual intervention"
}
```

**Orchestrator Handling:**
```python
# plan_orchestrator.py

result = run_git_merge(plan_branch)
if result.returncode == 2:  # Paused for manual resolution
    self.tui.set_status("Paused: Merge conflicts require manual resolution")
    self.tui.show_instructions([
        "1. Resolve conflicts in another terminal",
        "2. Run: git merge --continue",
        "3. Resume orchestrator with: --continue"
    ])
    return PAUSE_EXIT_CODE
```

**Resume After Manual Resolution:**
```bash
# User resolves conflicts
git add src/utils.js
git merge --continue

# Resume orchestrator
python scripts/plan_orchestrator.py --continue
```

### 4.3 Abort and Retry Strategies

**Abort Scenarios:**
1. Unresolvable conflicts
2. User cancels plan
3. Too many failed retry attempts

**Abort Strategy:**
```bash
# Clean abort - preserve state
git merge --abort
git checkout master
git branch -D plan/failed-plan  # Optional: delete branch

# Preserve work for later
git checkout plan/failed-plan
git tag "paused/failed-plan-$(date +%Y%m%d)"
git checkout master
```

**Retry with Rebase:**
```bash
# Instead of merge, try rebase (may succeed where merge failed)
git checkout plan/feature-x
git rebase master || {
  # Rebase conflict
  echo "Conflict in: $(git diff --name-only --diff-filter=U)"
  echo "Resolve and run: git rebase --continue"
}
```

### 4.4 Conflict-Free by Design

**File Locking System:**
```javascript
// Claim files before modification
const { claimFiles } = require('./file-claims');

async function executeTask(task) {
  const files = task.targetFiles; // ['src/auth.js', 'src/middleware.js']

  const claim = await claimFiles(files, {
    timeout: 30000,
    onConflict: 'wait' // or 'fail-fast'
  });

  try {
    // Execute task (guaranteed exclusive access)
    await implementTask(task);
  } finally {
    await claim.release();
  }
}
```

**File Claim Registry:**
```json
// .claude/file-claims.json
{
  "claims": [
    {
      "file": "src/auth.js",
      "taskId": "1.1",
      "planId": "implement-authentication",
      "claimedAt": "2024-12-24T10:00:00Z",
      "expiresAt": "2024-12-24T10:30:00Z"
    }
  ]
}
```

**Benefits:**
- Prevents concurrent edits to same file
- Clear ownership (which task modified which file)
- Automatic deadlock detection (circular claims)
- Stale claim cleanup (expired claims auto-released)

**Drawbacks:**
- Overhead (claim/release operations)
- Potential deadlock if tasks claim multiple files
- False serialization (tasks that could run in parallel don't)

## 5. Recovery from Conflicts

### 5.1 Stash and Reapply Patterns

**Stash Before Plan Switch:**
```bash
# /plan:set switching from plan A to plan B

# 1. Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
  # 2. Stash with descriptive message
  STASH_MSG="plan-switch: $(cat .claude/current-plan.txt) -> $NEW_PLAN"
  git stash push -m "$STASH_MSG"

  # 3. Store stash reference
  STASH_REF=$(git rev-parse stash@{0})
  echo "$STASH_REF" > ".claude/stash-refs/$CURRENT_PLAN.txt"
fi

# 4. Switch to new plan branch
git checkout plan/$NEW_PLAN || git checkout -b plan/$NEW_PLAN
```

**Reapply When Resuming:**
```bash
# /plan:set switching back to plan A

git checkout plan/$PLAN_A

# Check for saved stash
STASH_FILE=".claude/stash-refs/$PLAN_A.txt"
if [ -f "$STASH_FILE" ]; then
  STASH_REF=$(cat "$STASH_FILE")
  git stash apply "$STASH_REF" || {
    echo "Conflict applying stash. Resolve manually."
    exit 1
  }
  rm "$STASH_FILE"
fi
```

### 5.2 Conflict State Persistence

**Store Conflict State in status.json:**
```json
{
  "conflictState": {
    "detected": "2024-12-24T10:00:00Z",
    "type": "merge",
    "source": "plan/feature-x",
    "target": "master",
    "conflictFiles": [
      {
        "path": "src/utils.js",
        "ourVersion": "abc123",
        "theirVersion": "def456",
        "baseVersion": "789abc"
      }
    ],
    "resolutionStatus": "pending",
    "pausedAt": "task 3.2"
  }
}
```

### 5.3 Resuming After Manual Resolution

**Orchestrator Resume Flow:**
```python
# plan_orchestrator.py --continue

# 1. Check for paused state
status = get_status()
if status.conflict_state and status.conflict_state['resolutionStatus'] == 'pending':
    # 2. Verify git state is clean
    result = subprocess.run(['git', 'status', '--porcelain'], capture_output=True)
    if result.stdout.strip():
        print("ERROR: Working tree has uncommitted changes")
        print("Complete conflict resolution and commit before resuming")
        return 1

    # 3. Mark conflict resolved
    mark_conflict_resolved(status)

# 4. Continue with next task
task = get_next_task()
execute_task(task)
```

### 5.4 Partial Completion Handling

**Checkpoint Strategy:**
```bash
# After each task completion
git add -A
git commit -m "task $TASK_ID: $DESCRIPTION"
git tag "checkpoint/task-$TASK_ID"

# If conflict during task 3.2 execution
# Rollback to last successful task (3.1)
git reset --hard checkpoint/task-3.1
```

**Recovery Granularities:**
```json
{
  "recoveryPoints": {
    "per-task": true,
    "per-phase": true,
    "per-batch": false,
    "pre-merge": true
  }
}
```

## 6. Recommendations

### 6.1 Immediate Implementation (Phase 1)

**1. Branch Per Plan**
- Create `plan/{plan-name}` branch when plan starts
- All task commits go to plan branch
- Prevents parallel plan conflicts

**2. Pre-Flight Checks**
- Verify clean working tree before plan execution
- Check for uncommitted changes before plan switch
- Fail fast if git state is dirty

**3. File-Level Locking for status.json**
- Already implemented via `proper-lockfile`
- Continue using for concurrent agent safety

### 6.2 Near-Term Implementation (Phase 2)

**4. Stash/Unstash on Plan Switch**
- Auto-stash uncommitted work when switching plans
- Restore stash when resuming previous plan
- Store stash references in `.claude/stash-refs/`

**5. Conflict Detection Scanning**
- Periodic check for base branch divergence
- Warn if merge will have conflicts
- Suggest rebase before conflicts accumulate

**6. Per-Task Commits with Tags**
- Commit after each task completion
- Tag each commit: `checkpoint/task-{id}`
- Enable rollback to any task

### 6.3 Long-Term Implementation (Phase 3)

**7. Pause/Resume on Conflicts**
- Detect merge conflicts
- Pause orchestrator with clear instructions
- Resume after manual resolution

**8. File Claim System**
- Prevent concurrent edits to same source file
- Extend `proper-lockfile` pattern to all files
- Handle claim expiration and deadlock

**9. Semantic Conflict Detection**
- Run tests after merge
- Lint checks for undefined references
- CI/CD integration for validation

### 6.4 Advanced Features (Phase 4)

**10. Automatic Conflict Resolution**
- Simple conflicts (whitespace, generated files)
- Configurable strategies per file pattern
- Fall back to manual for complex conflicts

**11. Merge Strategies**
- Support multiple merge strategies (merge, rebase, squash)
- Per-plan configuration
- Priority-based merge ordering

**12. Distributed Locking**
- Support multiple machines (not just processes)
- Network-based lock coordination
- Handle network partitions gracefully

## 7. Summary Matrix

| Scenario | Risk Level | Current State | Recommended Solution | Priority |
|----------|-----------|---------------|----------------------|----------|
| Parallel plans, different files | MEDIUM | No isolation | Branch per plan | HIGH |
| Parallel plans, same files | HIGH | No isolation | Branch per plan + merge strategies | HIGH |
| Human edits during plan | HIGH | No protection | Pre-flight checks + stash | HIGH |
| Concurrent agents | MEDIUM | status.json locked | File claim system | MEDIUM |
| External CI/CD changes | LOW | No CI integration | Fetch before commit + conflict detection | LOW |
| Read-modify-write races | MEDIUM | No protection | File locking or optimistic locking | MEDIUM |
| Merge conflicts | HIGH | No handling | Pause/resume with manual resolution | HIGH |
| Semantic conflicts | MEDIUM | No detection | Post-merge testing | MEDIUM |
| Lost work on interruption | HIGH | No auto-save | Per-task commits + tags | HIGH |
| Conflict during task | HIGH | No recovery | Rollback to last checkpoint | MEDIUM |

## 8. Key Insights

1. **Branch isolation is essential** - The single biggest conflict preventer is branch-per-plan strategy. This should be implemented first.

2. **File locking prevents most concurrent edit issues** - Extending the existing `proper-lockfile` pattern to source files would eliminate most race conditions.

3. **Early detection is cheaper than late recovery** - Pre-flight checks and periodic divergence scanning catch conflicts before they cause problems.

4. **Manual resolution is sometimes necessary** - Complex semantic conflicts require human judgment. The system should make manual resolution easy, not try to avoid it entirely.

5. **Git's built-in conflict resolution is powerful** - Leverage git merge/rebase tools rather than reinventing conflict detection.

6. **Per-task commits enable fine-grained rollback** - Combined with tags, this provides safety without performance cost.

7. **Stash/unstash enables plan switching** - Simple pattern that preserves work-in-progress when context switching.

8. **Testing catches semantic conflicts** - No amount of git sophistication replaces running tests after merge.
