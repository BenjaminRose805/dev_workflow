# Task 3.5: Atomic Commits Analysis

## Overview

This analysis examines what constitutes an "atomic commit" in the context of the plan orchestration system, where an AI agent automatically commits code changes after completing tasks.

## Executive Summary

**Key Finding:** The orchestrator already implements per-task commits, creating a strong foundation for atomic commits. However, "atomicity" requires more than just one commit per task - it requires that each commit represents a **complete, self-contained, working unit of change**.

**Definition:** An atomic commit in the plan orchestrator represents:
1. One logical change (single task from plan)
2. Functional completeness (all files needed)
3. Build validity (code compiles)
4. Test stability (existing tests pass)
5. Self-containment (no dependency on uncommitted changes)
6. Reversibility (can be reverted cleanly)

---

## 1. Atomicity in Git Context

### Properties of Atomic Commits

| Property | Description | Why It Matters |
|----------|-------------|----------------|
| Single responsibility | One logical change | Precise rollback |
| Compilable | Code builds | CI/CD safety |
| Tests pass | No regressions | Quality guarantee |
| Self-contained | No uncommitted dependencies | Cherry-pick/revert |
| Documented | Clear commit message | Human understanding |

### Why Atomicity Matters for Automated Commits

1. **No human oversight** - Commits happen automatically
2. **Rollback is primary recovery** - Per-task rollback via `git revert`
3. **Parallel execution** - Each parallel task must be independently valid
4. **Long-running plans** - Every commit is a resumable savepoint

---

## 2. What Constitutes a Complete Unit of Work?

### Task-Level Atomicity (Default)

Each task = one atomic commit.

**Good example:**
```markdown
- [ ] 1.1 Create User model with validation
- [ ] 1.2 Add JWT middleware
- [ ] 1.3 Implement login endpoint
```

Each task:
- Has clear scope (one model, one middleware, one endpoint)
- Produces 1-3 files
- Completes in 5-15 minutes
- Results in compilable, testable code

### When Tasks Are Too Large

**Problem:**
```markdown
- [ ] 2.1 Refactor authentication system (50 files)
```

**Solution: Split into sub-tasks**
```markdown
- [ ] 2.1.1 Extract shared types
- [ ] 2.1.2 Refactor middleware
- [ ] 2.1.3 Update routes
- [ ] 2.1.4 Update tests
```

Each sub-task commits independently.

### When Tasks Must Be Co-Committed

**Problem:**
```markdown
- [ ] 3.1 Add database column: user.email_verified
- [ ] 3.2 Add migration for email_verified
```

Task 3.1 without 3.2 = broken schema.

**Solution: Merge tasks**
```markdown
- [ ] 3.1 Add email_verified column with migration
```

---

## 3. Task Types and Atomicity

| Task Type | Example | Atomic? | Verification |
|-----------|---------|---------|--------------|
| Single file creation | "Create auth.ts" | ✓ Yes | Syntax check |
| Multi-file module | "Create auth module" | ✓ Yes | Build + imports |
| Refactoring (small) | "Rename function" | ✓ Yes | Tests pass |
| Refactoring (large) | "Restructure 50 files" | ✗ No | Split required |
| Analysis only | "Document patterns" | ✓ Yes | No verification |
| Test + impl | "Add function with tests" | ✓ Yes | Tests pass |
| Partial feature | "Add backend (frontend later)" | ~ Depends | Phase boundary |

---

## 4. Dependencies and Atomicity

### Independent Tasks (Each Is Atomic)
```markdown
- [ ] 1.1 Create User model
- [ ] 1.2 Create Product model
- [ ] 1.3 Create Order model
```

Can revert any without affecting others.

### Dependent Tasks (Cascade Rollback Needed)
```markdown
- [ ] 2.1 Create auth types
- [ ] 2.2 Create auth service (uses 2.1)
- [ ] 2.3 Create auth controller (uses 2.2)
```

Each is atomic, BUT reverting 2.1 breaks 2.2 and 2.3.

**Implication:** Need dependency-aware rollback (cascade revert).

### Circular Dependencies (Must Be Co-Committed)
```markdown
- [ ] 3.1 Create User model (references Post)
- [ ] 3.2 Create Post model (references User)
```

Neither compiles alone → merge into single task.

---

## 5. Verification and Atomicity

### Verification Policies

| Level | Speed | Confidence | When to Use |
|-------|-------|------------|-------------|
| None | Fastest | Lowest | Analysis/docs |
| Build check | Fast | Medium | Code creation |
| Test suite | Slow | High | Critical paths |
| Full CI | Slowest | Highest | Pre-merge |

### Recommended Default: Build Verification

```bash
npm run type-check  # Fast (~10s)
if [ $? -eq 0 ]; then
  git commit -m "task 1.2: ..."
else
  markTaskFailed(taskId, 'Build failed')
fi
```

**Overhead:** 17 min for 100-task plan (vs 200 min for full tests)

**Catches:** 80% of issues (syntax errors, import issues)

---

## 6. Task Size Guidelines

| Estimated Scope | Action |
|----------------|--------|
| 1-3 files, < 15 min | Perfect size |
| 5-10 files, 30-60 min | Good size |
| 10-15 files, 1-2 hours | Consider splitting |
| > 15 files, > 2 hours | **Must split** |

### Orchestrator Enforcement

```javascript
const metrics = estimateTaskComplexity(task);
if (metrics.estimatedFiles > 15) {
  console.warn(`Task ${taskId} may be too large`);
  console.warn(`Recommend: /plan:split ${taskId}`);
}
```

---

## 7. Edge Cases

### Empty Commits (No File Changes)
- Analysis tasks produce findings, no code
- **Recommendation:** Skip commit, update status.json only

### Partial Task Completion (Crash)
- Session crashed mid-task
- **Recommendation:** Discard partial work, retry task
- Don't commit broken state

### Generated Files
- package-lock.json, build artifacts
- **Recommendation:** Include lock files in same commit
- Ignore build artifacts via .gitignore

---

## 8. Recommendations

### 8.1 Definition of Atomic Commit

An atomic commit in the plan orchestrator:

1. ✓ One task = one commit
2. ✓ All files needed for change to work
3. ✓ Code builds without errors
4. ✓ Existing tests pass
5. ✓ No uncommitted dependencies
6. ✓ Can be reverted without breaking dependents

### 8.2 Guidelines for Task Authors

1. **Keep tasks small** - Target 5-15 files, 30-60 min
2. **Make tasks complete** - Include tests, docs, config
3. **One logical change** - Don't mix unrelated changes
4. **Handle dependencies** - Mark dependent tasks clearly
5. **Split large tasks** - Use sub-tasks (2.1.1, 2.1.2)
6. **Avoid partial implementations** - No WIP tasks

### 8.3 Guidelines for Orchestrator

1. **Verify before commit** - Build check minimum
2. **Detect oversized tasks** - Warn if > 15 files
3. **Skip empty commits** - Analysis tasks
4. **Discard partial on failure** - Don't commit broken code

### 8.4 Verification Policy

| Task Type | Verification |
|-----------|-------------|
| Analysis/docs | None |
| Code creation | Build check |
| Refactoring | Build check |
| Critical | Full tests |
| Before merge | Full CI |

---

## 9. Implementation Checklist

- [ ] Add build verification to `/plan:implement`
- [ ] Add task size estimation heuristics
- [ ] Implement verification level detection
- [ ] Add empty commit detection
- [ ] Update task author guidelines
- [ ] Add dependency tracking for cascade rollback

---

## 10. Success Metrics

| Metric | Target |
|--------|--------|
| Build pass rate | > 95% |
| Test pass rate | > 90% |
| Revert success rate | > 95% |
| Tasks > 15 files | < 10% |
| Commits per task | Avg 1.0 |

---

## 11. Conclusion

**Atomicity is critical for the orchestrator** because:
- Automated commits have no human review
- Rollback is primary recovery mechanism
- Parallel execution requires independent validity

**The current per-task commit model is correct**, but needs:
1. Build verification before commit
2. Task size guidelines for authors
3. Skip empty commits
4. Discard partial work on failure

**Key insight:** Atomic commits are not just "one commit per task" - they're commits that represent complete, working, reversible changes.
