# Task 2.1: Branch-Per-Plan Approach Analysis

## Overview

This analysis evaluates the **branch-per-plan** strategy as a git workflow for the plan orchestration system. Based on Phase 0 current state analysis and Phase 1 requirements gathering, this approach is being assessed against user scenarios (solo developer, team developer, OSS contributor), rollback requirements (task/phase/plan level), and history preferences (granular vs clean).

---

## 1. Definition: What is Branch-Per-Plan?

### Core Concept

**Branch-Per-Plan** means each plan execution occurs on a dedicated git branch, isolated from the main branch and other plans.

### Branching Structure

```
main (or master)
  |
  |-- plan/implement-authentication      (Plan 1 - in progress)
  |-- plan/refactor-api-layer            (Plan 2 - in progress)
  |-- plan/add-logging                   (Plan 3 - completed, not merged)
  |
  (merged plans shown in main history)
```

### Lifecycle

1. **Creation**: Branch created when plan starts (`/plan:set <plan-name>`)
2. **Execution**: All task commits happen on this branch
3. **Isolation**: Changes don't affect main or other plan branches
4. **Completion**: Branch merged to main when plan completes
5. **Cleanup**: Branch deleted (optionally preserved via tag)

### Naming Convention

**Recommended format:**
```bash
plan/{plan-name}
plan/{category}/{plan-name}  # For organization
```

**Examples:**
```
plan/implement-authentication
plan/feature/add-dark-mode
plan/refactor/api-cleanup
plan/bugfix/memory-leak-fix
```

### Commands

```bash
# Start plan - creates branch
/plan:set implement-auth
# -> git checkout -b plan/implement-auth

# Switch to existing plan - switches branch
/plan:set another-plan
# -> git checkout plan/another-plan (or create if new)

# Execute task - commits to current plan branch
/plan:implement 1.1
# -> Task execution
# -> git add -A && git commit -m "task 1.1: ..."

# Complete plan - merge to main
/plan:complete
# -> git checkout main
# -> git merge --squash plan/implement-auth
# -> git commit -m "Plan: implement-auth (squashed)"
# -> git branch -D plan/implement-auth

# Abandon plan - delete branch
/plan:abandon
# -> git checkout main
# -> git branch -D plan/implement-auth
```

---

## 2. Advantages (10 Concrete Benefits)

### 2.1 Perfect Isolation

**Benefit:** Each plan's work is completely isolated from other plans and the main branch.

**Concrete example:**
```bash
# Working on plan A
git checkout plan/refactor-database
# Make 20 commits, modify 50 files

# Urgent bugfix needed - switch to plan B
git checkout -b plan/urgent-security-fix
# Work is pristine (no contamination from plan A)
# Fix bug, commit, merge to main

# Return to plan A
git checkout plan/refactor-database
# All 20 commits and 50 file changes intact
```

**Impact:**
- No accidental mixing of unrelated changes
- Main branch stays stable during long-running plans
- Can demonstrate/test main without plan changes

**Score: 10/10** - Critical for multi-plan workflows

### 2.2 Zero-Risk Rollback

**Benefit:** Complete plan abandonment is trivial and safe.

**Concrete example:**
```bash
# Plan executed 100 tasks across 5 phases
git log plan/failed-approach --oneline
# 100 commits visible

# Plan approach was fundamentally wrong
git checkout main
git branch -D plan/failed-approach
# All 100 commits discarded instantly
# Main branch untouched
# Zero history pollution
```

**Comparison to trunk-based:**
```bash
# Same scenario on main branch (trunk-based)
git log --oneline -100
# Must revert 100 commits individually
git revert abc123..def456  # Range revert
# Creates 100 revert commits (history pollution)
# OR destructive reset (unsafe)
```

**Impact:**
- Psychological safety to experiment
- Failed approaches cost nothing
- No "revert commits" polluting history

**Score: 10/10** - Enables fearless experimentation

### 2.3 Parallel Plan Execution

**Benefit:** Multiple plans can be in progress simultaneously without interference.

**Concrete example:**
```bash
# Monday: Start feature plan
git checkout -b plan/add-oauth
# ... work on OAuth (3 commits)

# Tuesday: Urgent documentation needed
git checkout -b plan/update-readme
# ... update docs (2 commits)
# Complete and merge
git checkout main && git merge --squash plan/update-readme

# Wednesday: Back to OAuth
git checkout plan/add-oauth
# Continue from where you left off (still 3 commits)

# Thursday: New refactoring plan
git checkout -b plan/refactor-auth
# ... work in parallel
```

**Use cases:**
- Context switching between plans
- Waiting for external input (review, approval)
- Background tasks while main work continues
- Team members on different plans

**Impact:**
- Increased productivity (no blocking)
- Natural task interleaving
- Mirrors real work patterns

**Score: 9/10** - Essential for real-world workflows

### 2.4 Clean Main Branch History

**Benefit:** Main branch shows only completed, verified work.

**Concrete example:**
```bash
# Main branch history (branch-per-plan)
git log main --oneline
a1b2c3d Plan: add-logging (squashed) - 15 tasks
e4f5g6h Plan: refactor-api (squashed) - 22 tasks
i7j8k9l Plan: implement-auth (squashed) - 18 tasks

# Main branch history (trunk-based with task commits)
git log main --oneline
z9y8x7w task 3.8: Update logging config
v6u5t4s task 3.7: Add log rotation
...
(hundreds of task commits)
```

**Benefits:**
- Easy to understand project evolution
- Readable `git log` output
- Clear revert points (revert entire plan)
- Professional appearance for public repos

**Impact:**
- Team collaboration easier
- Code review focused on plan-level changes
- Deployment tracking clearer

**Score: 8/10** - High value for teams and public repos

### 2.5 Natural Checkpoint for Verification

**Benefit:** Plan branches serve as quality gates before integration.

**Concrete example:**
```bash
# Plan completed on branch, not yet merged
git checkout plan/new-feature

# Run comprehensive verification
npm test                    # All tests pass
npm run lint               # No linting errors
npm run build              # Build succeeds
npm run security-audit     # No vulnerabilities

# Verification passed - safe to merge
git checkout main
git merge --squash plan/new-feature

# If verification failed:
# Stay on branch, fix issues, verify again
# Never pollutes main with broken code
```

**Impact:**
- Main branch always deployable
- Failed verification doesn't contaminate
- Matches CI/CD best practices

**Score: 9/10** - Critical for quality assurance

### 2.6 Granular History Preserved During Execution

**Benefit:** Per-task commits available during plan execution for debugging and rollback.

**Concrete example:**
```bash
# During plan execution on branch
git log plan/implement-auth --oneline
d1e2f3g task 1.5: Add logout endpoint
c4a5b6h task 1.4: Implement refresh tokens
i7j8k9l task 1.3: Create JWT middleware
m1n2o3p task 1.2: Add user model
q4r5s6t task 1.1: Setup auth structure

# Task 1.4 introduced bug - rollback just that task
git revert c4a5b6h
# Retry task with fix
/plan:implement 1.4
```

**After merge to main:**
```bash
git log main --oneline
a1b2c3d Plan: implement-auth (squashed) - 5 tasks

# Granular history preserved in tag
git tag archive/plan-implement-auth <branch-before-delete>
git log archive/plan-implement-auth --oneline
# Still shows all 5 task commits
```

**Impact:**
- Best of both worlds: granular + clean
- Debugging capabilities retained
- Rollback available when needed

**Score: 10/10** - Solves the granularity vs cleanliness tradeoff

### 2.7 Team Collaboration Alignment

**Benefit:** Matches standard GitHub/GitLab feature branch workflow.

**Concrete example:**
```bash
# Team workflow
git checkout -b plan/add-payment-processing
# ... execute 20 tasks (20 commits)

# Push branch for code review
git push origin plan/add-payment-processing

# Create pull request
gh pr create --title "Add payment processing" --body "..."
# PR shows 20 commits (reviewable individually)
# CI runs on branch (not main)

# After review approval
# GitHub: "Squash and merge" button
# Result: 1 commit on main, 20 commits in PR history
```

**Team benefits:**
- Code review before merge
- CI/CD testing on branch
- Branch protection on main (no direct pushes)
- Rollback = revert merge commit

**Impact:**
- Industry standard workflow
- Tool support (GitHub, GitLab, Bitbucket)
- Team onboarding easier

**Score: 10/10** - Essential for team workflows

### 2.8 Conflict Isolation

**Benefit:** Merge conflicts detected at completion, not during execution.

**Concrete example:**
```bash
# Scenario: Two plans modifying overlapping files
# Plan A (started Monday)
git checkout -b plan/refactor-auth
# Modifies: src/auth/middleware.js, src/auth/utils.js

# Plan B (started Tuesday, completed Wednesday)
git checkout -b plan/add-logging
# Modifies: src/auth/middleware.js (different lines)
git checkout main
git merge --squash plan/add-logging  # Merges cleanly

# Plan A (completed Thursday)
git checkout main
git merge --squash plan/refactor-auth
# CONFLICT in src/auth/middleware.js
# Resolve now (at integration time, not during execution)
```

**Impact:**
- Uninterrupted plan execution
- Conflicts resolved at logical boundaries
- Failed conflict resolution doesn't block other work

**Score: 8/10** - Significant workflow improvement

### 2.9 Easy Plan Resume After Interruption

**Benefit:** Plan state preserved perfectly across sessions.

**Concrete example:**
```bash
# Friday afternoon: Start long plan
git checkout -b plan/database-migration
/plan:implement 1.1
/plan:implement 1.2
# ... (10 commits)
# Need to leave for weekend

# Monday morning: Resume exactly where you left off
git checkout plan/database-migration
/plan:status
# Shows tasks 1.1-1.10 completed, 1.11 next
/plan:implement 1.11
# Continues seamlessly
```

**Impact:**
- Resilience to interruptions
- No lost work
- Clear state tracking

**Score: 9/10** - Critical for reliability

### 2.10 Archive and Reference

**Benefit:** Completed plans can be archived with full history for future reference.

**Concrete example:**
```bash
# Before deleting branch, create archive tag
git tag archive/plan-implement-auth plan/implement-auth
git push origin archive/plan-implement-auth

# Delete branch
git branch -D plan/implement-auth

# 6 months later: Need to see how auth was implemented
git log archive/plan-implement-auth --oneline
# Shows all 25 task commits

# Find specific task implementation
git show archive/plan-implement-auth:src/auth/middleware.js

# Compare specific tasks
git diff archive/plan-implement-auth~5 archive/plan-implement-auth~4
# Shows exactly what task changed
```

**Use cases:**
- Onboarding (show how feature was built)
- Debugging (find when behavior changed)
- Forensics (audit trail for compliance)
- Learning (reference past implementations)

**Impact:**
- Knowledge preservation
- Debugging historical issues
- Compliance and auditing

**Score: 7/10** - Valuable for long-term projects

---

## 3. Disadvantages (7 Challenges/Limitations)

### 3.1 Branch Management Overhead

**Challenge:** Users must understand and manage git branches.

**Complexity added:**
```bash
# Commands user must learn/remember:
git checkout -b plan/name        # Create branch
git checkout plan/name           # Switch branches
git branch -l                    # List branches
git branch -D plan/name          # Delete branch
git merge --squash plan/name     # Merge with squash

# OR rely on orchestrator:
/plan:set name                   # Orchestrator handles branching
/plan:complete                   # Orchestrator handles merge
/plan:abandon                    # Orchestrator handles cleanup
```

**Error scenarios:**
```bash
# Forgot to switch branches
# Working on main instead of plan branch
git branch  # Shows * main (oops!)
# Manual recovery needed

# Created branch manually with wrong name
git checkout -b my-plan
# Orchestrator expects plan/my-plan
# Status tracking confused
```

**Mitigation:**
- Orchestrator handles ALL branching (user never runs git checkout)
- `/plan:set` creates/switches automatically
- `/plan:status` shows current branch
- Safeguards prevent commits to main

**Impact:** Medium - Solvable with automation

**Severity: 6/10** - Higher for git novices, lower for experienced devs

### 3.2 Orphaned Branches

**Challenge:** Incomplete plans leave branches that accumulate over time.

**Scenario:**
```bash
# Over 6 months:
git branch -l
  plan/experiment-1 (abandoned)
  plan/experiment-2 (abandoned)
  plan/feature-a (completed but not merged/deleted)
  plan/feature-b (in progress)
  plan/feature-c (waiting on external input)
  plan/bugfix-1 (abandoned)
  plan/bugfix-2 (completed, forgot to delete)
* main
```

**Consequences:**
- Clutter in branch list
- Confusion about which plans are active
- Disk space (minimal but accumulates)
- Namespace pollution

**Cleanup required:**
```bash
# Manual cleanup
git branch -D plan/experiment-1 plan/experiment-2 plan/bugfix-1

# OR automated cleanup script
git branch --merged main | grep "plan/" | xargs git branch -D
git branch --no-merged main | grep "plan/" | while read branch; do
  # Check last commit date
  last_commit=$(git log -1 --format=%ct $branch)
  now=$(date +%s)
  age=$(( (now - last_commit) / 86400 ))
  if [ $age -gt 30 ]; then
    echo "Stale branch: $branch (last commit $age days ago)"
    # Optionally delete or archive
  fi
done
```

**Mitigation:**
- `/plan:complete` auto-deletes branch
- `/plan:abandon` prompts for deletion
- `/plan:cleanup` command lists stale branches
- Weekly reminder about orphaned branches

**Impact:** Low - Nuisance but not critical

**Severity: 4/10** - Manageable with discipline/automation

### 3.3 Merge Conflicts at Integration

**Challenge:** Conflicts surface when merging plan to main, potentially after significant work.

**Scenario:**
```bash
# Plan started last week
git checkout -b plan/refactor-payment
# ... 50 commits over 5 days ...

# Meanwhile, main branch evolved
# (teammate merged 3 other plans)
git log main --oneline --since="5 days ago"
# 15 new commits on main

# Try to merge plan
git checkout main
git merge --squash plan/refactor-payment
# CONFLICT (content): Merge conflict in src/payment/processor.js
# CONFLICT (content): Merge conflict in src/payment/validator.js
# CONFLICT (content): Merge conflict in package-lock.json
```

**Resolution burden:**
```bash
# Must resolve conflicts manually
# Edit files, choose correct changes
# Test that resolution didn't break anything
# Commit resolution

# If conflicts are severe:
# Option 1: Resolve on main
git add .
git commit -m "Plan: refactor-payment (squashed, with conflict resolution)"

# Option 2: Rebase plan branch on main first
git checkout plan/refactor-payment
git rebase main  # Resolve conflicts incrementally
git checkout main
git merge --squash plan/refactor-payment  # Now clean
```

**Risk:**
- Late discovery of conflicts (after days of work)
- Resolution complexity grows with plan duration
- Broken integration despite passing tests on branch

**Mitigation:**
- Regularly sync plan branch with main
- Pre-merge conflict detection
- Automated tests on merged result before commit

**Impact:** Medium - Can delay plan completion

**Severity: 7/10** - Significant pain point for long-running plans

### 3.4 Mental Model Complexity

**Challenge:** Users must track which branch they're on and what it represents.

**Confusion scenarios:**
```bash
# "Where am I?"
git branch
  plan/feature-a
* plan/feature-b
  plan/feature-c
# Which plan am I working on?

# "What's on main vs my branch?"
git diff main  # Too much output (shows all plan changes)

# "What changes are staged?"
git status
# Shows modified files but not which task they're for
```

**Learning curve:**
- Understand branches (conceptual)
- Know how to check current branch
- Understand working directory vs branch vs commit
- Differentiate local vs remote branches
- Understand merge vs rebase

**Mitigation:**
- Orchestrator abstracts git details
- `/plan:status` shows current plan + branch
- TUI displays current branch prominently
- Prevent operations on wrong branch

**Impact:** Medium - Steeper learning curve

**Severity: 5/10** - Offset by tooling/automation

### 3.5 Requires Enforced Discipline

**Challenge:** Workflow breaks if users commit to wrong branch or skip steps.

**Breaking scenarios:**
```bash
# 1. User commits directly to main (bypasses branch isolation)
git checkout main
git commit -m "Quick fix"
# Plan execution corrupted (main diverged unexpectedly)

# 2. User forgets to merge completed plan
git branch -l
  plan/completed-feature (finished 2 months ago)
* main
# Feature was completed but never integrated

# 3. User manually merges without squash
git checkout main
git merge plan/feature  # Forgot --squash
# 50 task commits now on main (defeats clean history)
```

**Enforcement needed:**
```bash
# Pre-commit hook: Prevent commits to main
if [ "$(git branch --show-current)" = "main" ]; then
  echo "ERROR: Direct commits to main not allowed"
  echo "Use /plan:set to create a plan branch"
  exit 1
fi
```

**Impact:** High - Workflow integrity depends on compliance

**Severity: 8/10** - Critical to address with automation

### 3.6 Lost Context on Squash

**Challenge:** Squashing loses individual commit messages and granular history from main branch.

**What's lost:**
```bash
# Before squash (on plan branch)
git log plan/implement-auth --oneline
a1b2c3d task 1.5: Add logout endpoint (34s)
e4f5g6h task 1.4: Implement token refresh (28s)
i7j8k9l task 1.3: Create JWT validation middleware (45s)
m1n2o3p task 1.2: Add User model with password hashing (52s)
q4r5s6t task 1.1: Setup authentication directory structure (12s)

# After squash (on main)
git log main --oneline -1
x9y8z7w Plan: implement-auth (squashed) - 5 tasks

# Lost information:
# - Which files changed in each task
# - Time spent per task
# - Task-level descriptions
# - Incremental evolution of solution
```

**Mitigation:**
- Archive tags preserve granular history
- Enhanced squash message includes task summary
- Link to plan outputs for details

**Impact:** Medium - Mitigable with tags and documentation

**Severity: 6/10** - Solved by hybrid approach

### 3.7 Remote Sync Complexity

**Challenge:** Pushing/pulling plan branches adds coordination overhead.

**Scenarios:**
```bash
# Solo dev, multiple machines
# Machine A: Create plan branch
git checkout -b plan/my-feature
git push -u origin plan/my-feature

# Machine B: Switch to same plan
git fetch origin
git checkout plan/my-feature

# Later on Machine A: More commits
git commit -m "task 1.5: ..."
git push

# Machine B: Must pull before continuing
git pull  # Or conflicts arise
```

**Mitigation:**
- `/plan:set` handles remote tracking automatically
- `/plan:complete` deletes remote branch
- Solo dev mode: Skip remote push unless requested

**Impact:** Low for solo dev, Medium for teams

**Severity: 5/10** - Manageable with automation

---

## 4. Complexity Assessment

### 4.1 Implementation Effort

**Components to modify:**

| Component | Change Required | Estimated Effort | Complexity |
|-----------|----------------|------------------|------------|
| `/plan:set` | Branch creation/switching logic | 2-3 hours | Medium |
| `/plan:implement` | Verify on correct branch, commit logic | 1-2 hours | Low |
| `/plan:batch` | Branch awareness, commit aggregation | 2-3 hours | Medium |
| `/plan:complete` (new) | Squash merge, branch cleanup, tag creation | 4-5 hours | High |
| `/plan:abandon` (new) | Branch deletion, confirmation prompts | 1-2 hours | Low |
| `/plan:status` | Show current branch, divergence from main | 1-2 hours | Low |
| Git utility functions | Branch checks, safety validations | 2-3 hours | Medium |
| Pre-commit hook | Prevent commits to main | 1 hour | Low |
| Status tracking | Map plan to branch in status.json | 1 hour | Low |
| Error handling | Wrong branch detection, recovery | 2-3 hours | Medium |
| Documentation | User guide, examples, troubleshooting | 2-3 hours | Low |

**Total estimated effort: 20-30 hours**

**Complexity score: 6/10** (Medium) - Significant but manageable

### 4.2 Mental Model Complexity

**Simplified mental model (with orchestrator abstraction):**

For **solo developers**:
```
"A plan is a workspace. When you start a plan, you're in its workspace.
Changes stay in that workspace until you say the plan is done.
If the plan doesn't work out, you can throw away the whole workspace."
```

Commands they need:
- `/plan:set my-plan` - "Start working on my-plan"
- `/plan:implement 1.1` - "Do task 1.1" (auto-commits)
- `/plan:complete` - "This plan is done, add it to the main codebase"
- `/plan:abandon` - "Throw away this plan's changes"

**Git knowledge required: 1/10** (almost none)

For **team developers**:

Additional concepts:
```
"Your plan workspace is shared with teammates (via remote).
When you complete a plan, it goes through code review before joining main.
Other teammates' plans don't affect yours until they merge."
```

**Git knowledge required: 4/10** (basic understanding of branches, remotes, PRs)

### 4.3 Git Expertise Required

**Minimum knowledge by role:**

**Solo developer (using orchestrator):** Required expertise: 2/10 (Very basic)
**Solo developer (manual git):** Required expertise: 5/10 (Intermediate)
**Team developer:** Required expertise: 7/10 (Proficient)
**Plan orchestrator maintainer:** Required expertise: 9/10 (Advanced)

### 4.4 Overall Complexity Score

**Overall complexity: 5.0/10 (Medium)**

**Verdict:** Branch-per-plan is **moderately complex** but:
- Complexity frontloaded in implementation (one-time cost)
- Abstraction layer (orchestrator) reduces user-facing complexity
- Scales well (complexity doesn't increase with usage)
- Standard industry practice (developers likely familiar)

---

## 5. Best Suited Scenarios

### 5.1 Ideal Use Cases (High Fit)

| Scenario | Fit Score | Rationale |
|----------|-----------|-----------|
| Team development with code review | 10/10 | Branch-per-plan = feature branch (1:1 mapping) |
| Long-running plans (days/weeks) | 10/10 | Main branch stays stable during long development |
| Experimental/risky plans | 10/10 | Zero risk to main, easy to abandon |
| Parallel plan work (context switching) | 9/10 | Each plan isolated in own branch |
| Open source contribution | 9/10 | Matches fork + feature branch workflow |

### 5.2 Moderate Fit Scenarios

| Scenario | Fit Score | Rationale |
|----------|-----------|-----------|
| Solo developer, short plans (< 5 tasks) | 6/10 | Overhead of branching may exceed benefits |
| Rapid prototyping / spikes | 6/10 | Branching good for isolation but may slow rapid iteration |

### 5.3 Poor Fit Scenarios

| Scenario | Fit Score | Rationale |
|----------|-----------|-----------|
| True trunk-based development | 2/10 | Branching delays integration to main |
| Non-git workflows | 1/10 | Branch-per-plan designed for git branching model |

### 5.4 Decision Matrix

```
Should I use branch-per-plan?

[Team project?]
    ├─ YES → Use it (Score: 10/10)
    └─ NO → Continue below

[Long plan? (> 10 tasks or > 1 day)]
    ├─ YES → Use it (Score: 10/10)
    └─ NO → Continue below

[Risky/experimental?]
    ├─ YES → Use it (Score: 10/10)
    └─ NO → Continue below

[Need parallel plans?]
    ├─ YES → Use it (Score: 9/10)
    └─ NO → Default to branch-per-plan (Score: 8/10)

[Trunk-based CI/CD requirement?]
    └─ YES → Don't use (Score: 2/10)
```

---

## 6. Comparison to Alternatives

### 6.1 vs Trunk-Based Development

| Aspect | Branch-Per-Plan | Trunk-Based | Winner |
|--------|----------------|-------------|--------|
| **Isolation** | High | None | Branch-per-plan |
| **Rollback** | Easy | Hard | Branch-per-plan |
| **Parallel plans** | Supported | Not supported | Branch-per-plan |
| **Main branch stability** | High | Low | Branch-per-plan |
| **Simplicity** | Medium | High | Trunk-based |
| **Team coordination** | Easier | Harder | Branch-per-plan |
| **Code review** | Natural (PR) | Awkward | Branch-per-plan |
| **History cleanliness** | Clean (squashed) | Messy | Branch-per-plan |

**Overall: Branch-per-plan wins 8 categories, Trunk-based wins 4**

### 6.2 vs Branch-Per-Phase

| Aspect | Branch-Per-Plan | Branch-Per-Phase | Analysis |
|--------|----------------|------------------|----------|
| **Branch count** | 1 per plan | 5-7 per plan | Phase has more overhead |
| **Granular rollback** | Task-level | Phase-level | Depends on need |
| **Merge frequency** | Once | 5-7 times | Phase has more merge points |
| **Mental model** | Simpler | Complex | Plan is simpler |
| **Setup complexity** | Medium | High | Plan is simpler |

**Recommendation:** Branch-per-plan with **phase tags** as compromise

### 6.3 vs Feature Flags

| Aspect | Branch-Per-Plan | Feature Flags | Analysis |
|--------|----------------|---------------|----------|
| **Code in production** | No | Yes (disabled) | Flags deploy earlier |
| **Rollback mechanism** | Delete branch | Toggle flag off | Both easy |
| **Code review** | Before merge | After commit | Branches better |
| **Setup complexity** | Medium | High | Branches simpler |
| **Gradual rollout** | Not supported | Supported | Flags enable |

**Recommendation:** Both (Complementary) - branches for development, flags for deployment

---

## 7. Risk Assessment

### 7.1 Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Branch divergence from main | High | Medium | Regular rebase/merge |
| Orphaned branches accumulating | Medium | Low | Auto-delete on complete |
| User commits to wrong branch | Medium | High | Pre-commit hook |
| Lost work due to branch deletion | Low | High | Archive tag before delete |
| Merge conflicts break automation | Medium | High | Conflict detection |

### 7.2 Overall Risk Level

**Overall risk: Medium** (Manageable with proper implementation)

**Critical mitigations:**
1. Pre-commit hook (prevent wrong branch)
2. Archive tags (prevent data loss)
3. Clear error messages (reduce confusion)
4. Conflict detection (warn before merge)

---

## 8. Recommendation

### 8.1 Overall Assessment

**Branch-per-plan is RECOMMENDED as the default git workflow strategy for the plan orchestration system.**

**Score: 9/10**

### 8.2 When to Use Branch-Per-Plan

**Strongly recommended:**
- Team development (code review required)
- Long-running plans (> 10 tasks or > 1 day)
- Plans with high rollback risk (refactoring, deletions)
- Parallel plan work (context switching)
- Open source contributions

**Recommended:**
- Solo development on production projects
- Medium-sized plans (5-10 tasks)
- Plans requiring verification gates

**Optional (consider alternatives):**
- Solo developer, experimental project, short plans (< 5 tasks)

### 8.3 Implementation Strategy

**Phase 1: Core branching (MVP)**
- `/plan:set` creates/switches branches
- `/plan:implement` commits to plan branch
- Manual merge to main
- Estimated: 5-8 hours

**Phase 2: Automated completion**
- `/plan:complete` command with squash merge
- Archive tagging before deletion
- Estimated: 4-6 hours

**Phase 3: Safety and UX**
- Pre-commit hook
- Branch validation
- Conflict detection
- Estimated: 4-6 hours

**Phase 4: Advanced features**
- PR creation
- Remote sync
- Stale branch cleanup
- Estimated: 6-8 hours

**Total: 20-30 hours** (can be incremental)

### 8.4 Configuration Flexibility

**Recommended configuration options:**

```json
{
  "git_workflow": {
    "strategy": "branch-per-plan",
    "branch_prefix": "plan/",
    "auto_commit": true,
    "commit_template": "task",
    "merge_strategy": "squash",
    "archive_branches": true,
    "archive_retention_days": 90,
    "enforce_branch": true,
    "sync_remote": false
  }
}
```

---

## Conclusion

**Branch-per-plan provides the optimal balance** of isolation, rollback capability, clean history, and team collaboration for the plan orchestration system. While it introduces moderate complexity (branch management, merge workflow), this is offset by significant benefits and can be largely abstracted through the orchestrator interface.

**Key strengths:**
- Perfect isolation for parallel plans
- Zero-risk plan abandonment
- Clean main branch history (squash merge)
- Industry-standard workflow (aligns with PR/code review)
- Granular history preserved for debugging (via archive tags)

**Key challenges:**
- Branch management overhead (mitigated by orchestrator automation)
- Merge conflicts at integration (mitigated by early detection)
- Learning curve for git novices (mitigated by abstraction)

**Overall verdict: STRONGLY RECOMMENDED** for implementation as the default git workflow strategy.
