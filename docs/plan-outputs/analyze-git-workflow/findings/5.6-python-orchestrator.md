# Task 5.6: Python Orchestrator Changes for Branch Management

## Executive Summary

The Python orchestrator (`scripts/plan_orchestrator.py`) requires **5 key enhancements** to support git workflow integration. Changes focus on branch validation, switch_plan.py integration, and session-level git state management.

**Estimated Effort:** 8-12 hours total implementation.

---

## 1. Current Architecture Analysis

### File Structure

```
scripts/
├── plan_orchestrator.py     # Main orchestration loop (736 lines)
├── switch_plan.py           # Plan switching utility (366 lines)
└── lib/
    ├── tui.py               # Rich TUI manager
    ├── claude_runner.py     # Streaming Claude execution (179 lines)
    └── status_monitor.py    # status.json watcher (115 lines)
```

### Key Classes

| Class | Responsibility | Git Integration Needed |
|-------|---------------|----------------------|
| `PlanOrchestrator` | Main execution loop | Branch validation, session tracking |
| `PlanStatus` | Plan state representation | Branch name, divergence info |
| `StreamingClaudeRunner` | Claude CLI execution | None (delegates to /plan:implement) |
| `StatusMonitor` | status.json watcher | Git metadata observation |

### Current Git Usage

**None.** The Python orchestrator currently has zero git integration:
- No branch checking
- No uncommitted changes detection
- No pre-session validation
- Relies entirely on `/plan:implement` for commit behavior

---

## 2. Required Changes

### 2.1 Branch Validation on Session Start

**Location:** `PlanOrchestrator.run()` (line 384-591)

**Purpose:** Verify correct branch before starting orchestration.

**Implementation:**

```python
def validate_git_state(self) -> tuple[bool, str]:
    """Validate git state before starting orchestration.

    Returns:
        (valid, message) - whether state is valid and explanatory message
    """
    try:
        # Get current branch
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True, text=True, timeout=10
        )
        current_branch = result.stdout.strip()

        # Get expected branch from status.json
        status = self.get_status()
        if not status:
            return False, "Could not get plan status"

        # Derive expected branch name
        plan_name = Path(status.plan_path).stem
        expected_branch = f"plan/{plan_name}"

        # Check if on correct branch
        if current_branch != expected_branch:
            # Check if expected branch exists
            exists_result = subprocess.run(
                ["git", "rev-parse", "--verify", expected_branch],
                capture_output=True, timeout=10
            )

            if exists_result.returncode == 0:
                return False, f"Not on plan branch. Current: {current_branch}, Expected: {expected_branch}"
            else:
                # Branch doesn't exist - orchestrator should NOT create branches
                # That's /plan:set's responsibility
                return False, f"Plan branch '{expected_branch}' does not exist. Run /plan:set first."

        return True, f"On correct branch: {current_branch}"

    except subprocess.TimeoutExpired:
        return False, "Git command timed out"
    except FileNotFoundError:
        return True, "Git not available (not a git repository)"
    except Exception as e:
        return False, f"Git validation failed: {e}"
```

**Integration Point (in `run()`):**

```python
def run(self) -> int:
    self.start_time = time.time()

    # NEW: Validate git state
    valid, message = self.validate_git_state()
    if not valid:
        self.logger.error(message)
        if self.use_tui:
            self.tui.set_status(f"Error: {message}")
            time.sleep(3)
        return 1

    # Existing status check continues...
    status = self.get_status()
```

---

### 2.2 PlanStatus Git Extensions

**Location:** `PlanStatus` class (lines 62-94)

**Purpose:** Include git metadata in status representation.

**Implementation:**

```python
class PlanStatus:
    """Represents the current state of a plan."""

    def __init__(self, data: dict):
        # Existing fields
        self.plan_path = data.get("planPath", "")
        self.plan_name = data.get("planName", "Unknown")
        self.total = data.get("total", 0)
        self.completed = data.get("completed", 0)
        self.in_progress = data.get("inProgress", 0)
        self.pending = data.get("pending", 0)
        self.failed = data.get("failed", 0)
        self.skipped = data.get("skipped", 0)
        self.percentage = data.get("percentage", 0)
        self.current_phase = data.get("currentPhase", "")

        # NEW: Git metadata from status.json
        git_data = data.get("git", {})
        self.branch_name = git_data.get("branchName", "")
        self.base_branch = git_data.get("baseBranch", "main")
        self.is_dirty = git_data.get("isDirty", False)
        self.uncommitted_files = git_data.get("uncommittedFiles", [])
        self.commits_ahead = git_data.get("divergence", {}).get("ahead", 0)
        self.commits_behind = git_data.get("divergence", {}).get("behind", 0)

    @property
    def has_uncommitted_changes(self) -> bool:
        return self.is_dirty or len(self.uncommitted_files) > 0

    @property
    def needs_sync(self) -> bool:
        return self.commits_behind > 0

    def __str__(self) -> str:
        bar_width = 30
        filled = int(bar_width * self.percentage / 100)
        bar = "█" * filled + "░" * (bar_width - filled)

        status_str = (
            f"[{bar}] {self.percentage}% "
            f"({self.completed}/{self.total} tasks)\n"
            f"  Pending: {self.pending} | In Progress: {self.in_progress} | "
            f"Failed: {self.failed} | Skipped: {self.skipped}"
        )

        # NEW: Add git info if available
        if self.branch_name:
            status_str += f"\n  Branch: {self.branch_name}"
            if self.commits_ahead or self.commits_behind:
                status_str += f" (↑{self.commits_ahead} ↓{self.commits_behind})"
            if self.is_dirty:
                status_str += " [uncommitted changes]"

        return status_str
```

---

### 2.3 Uncommitted Changes Pre-Check

**Location:** New method in `PlanOrchestrator`

**Purpose:** Check for uncommitted changes before each iteration.

**Implementation:**

```python
def check_uncommitted_changes(self) -> tuple[bool, int, list]:
    """Check for uncommitted changes in the working directory.

    Returns:
        (has_changes, file_count, file_list)
    """
    try:
        # Check for uncommitted changes
        result = subprocess.run(
            ["git", "status", "--porcelain"],
            capture_output=True, text=True, timeout=10
        )

        if result.returncode != 0:
            return False, 0, []

        lines = [l for l in result.stdout.strip().split('\n') if l]
        file_count = len(lines)
        file_list = [l[3:] for l in lines[:5]]  # First 5 files

        return file_count > 0, file_count, file_list

    except Exception:
        return False, 0, []


def handle_uncommitted_changes(self) -> bool:
    """Handle uncommitted changes before session.

    Returns:
        True if safe to continue, False if should abort.
    """
    has_changes, count, files = self.check_uncommitted_changes()

    if not has_changes:
        return True

    self.logger.warning(f"Uncommitted changes detected: {count} files")

    if self.use_tui:
        self.tui.set_status(f"Warning: {count} uncommitted files")

    # In autonomous mode, we should NOT auto-commit from orchestrator
    # That's the responsibility of /plan:implement
    # Just log a warning and continue

    return True  # Continue but with warning logged
```

**Note:** The orchestrator should NOT commit changes. That's the responsibility of `/plan:implement`. The orchestrator only validates state and logs warnings.

---

### 2.4 Session State Tracking

**Location:** `_build_prompt()` and new tracking methods

**Purpose:** Pass git context to Claude sessions.

**Implementation:**

```python
def _build_prompt(self, status: PlanStatus, next_tasks: list) -> str:
    """Build the prompt for Claude Code with git context."""
    task_ids = " ".join(t.get('id', '') for t in next_tasks)

    task_list = "\n".join(
        f"  - {t.get('id')}: {t.get('description')}"
        for t in next_tasks
    )

    # NEW: Include git context for Claude's awareness
    git_context = ""
    if status.branch_name:
        git_context = f"""
Git Context:
  Branch: {status.branch_name}
  Base: {status.base_branch}
  Divergence: {status.commits_ahead} ahead, {status.commits_behind} behind
"""
        if status.is_dirty:
            git_context += "  Warning: Uncommitted changes present\n"

    return f"""Execute these tasks from the plan:

{task_list}

Plan: {status.plan_path}
Progress: {status.percentage}% ({status.completed}/{status.total} tasks)
{git_context}
Run: /plan:implement {task_ids} --autonomous

## Rules

- Execute autonomously - do NOT ask for confirmation
- Stop after completing this batch or if blocked by unrecoverable error
- If a task fails, the command will mark it failed and continue to next task
- Check progress: `node scripts/status-cli.js progress`"""
```

---

### 2.5 switch_plan.py Integration

**Location:** `scripts/switch_plan.py` (lines 165-237)

**Purpose:** Add branch creation/switching to plan selection.

**Current `switch_to_plan()` function:**
- Writes to `current-plan.txt`
- Creates output directory
- Initializes `status.json`

**Enhanced Implementation:**

```python
def switch_to_plan(name):
    """Switch to a specific plan with branch management."""
    paths = get_paths()
    plan_file = paths['plans'] / f'{name}.md'
    output_dir = paths['outputs'] / name
    status_file = output_dir / 'status.json'

    if not plan_file.exists():
        print(f"{Colors.RED}Error: Plan file not found: {plan_file}{Colors.NC}")
        return False

    print(f"\n{Colors.CYAN}Switching to plan:{Colors.NC} {name}")

    # NEW: Git branch management
    branch_name = f"plan/{name}"

    # Check for uncommitted changes
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        capture_output=True, text=True
    )

    if result.stdout.strip():
        print(f"\n{Colors.YELLOW}⚠ Uncommitted changes detected{Colors.NC}")
        print("Options:")
        print("  [C] Commit to current branch")
        print("  [S] Stash changes")
        print("  [A] Abort")
        print("  [F] Force (discard changes)")

        try:
            choice = input(f"{Colors.CYAN}Choose [{Colors.NC}C/S/A/F{Colors.CYAN}]:{Colors.NC} ").strip().upper()
        except (KeyboardInterrupt, EOFError):
            print("\nAborted.")
            return False

        if choice == 'A':
            return False
        elif choice == 'C':
            subprocess.run(["git", "add", "-A"])
            subprocess.run(["git", "commit", "-m", "WIP: Auto-commit before plan switch"])
        elif choice == 'S':
            current = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True, text=True
            ).stdout.strip()
            subprocess.run([
                "git", "stash", "push", "-u", "-m",
                f"Auto-stash before switching to plan/{name} from {current}"
            ])
        elif choice == 'F':
            subprocess.run(["git", "checkout", "--", "."])
            subprocess.run(["git", "clean", "-fd"])

    # Check if branch exists
    result = subprocess.run(
        ["git", "rev-parse", "--verify", branch_name],
        capture_output=True
    )

    if result.returncode == 0:
        # Branch exists - switch to it
        subprocess.run(["git", "checkout", branch_name])
        print(f"{Colors.GREEN}✓{Colors.NC} Switched to existing branch: {branch_name}")
    else:
        # Create new branch from main
        base = get_base_branch()
        subprocess.run(["git", "checkout", base])
        subprocess.run(["git", "checkout", "-b", branch_name])
        print(f"{Colors.GREEN}✓{Colors.NC} Created new branch: {branch_name}")

    # Existing: Update current plan pointer
    paths['current_plan'].write_text(f'docs/plans/{name}.md\n')
    print(f"{Colors.GREEN}✓{Colors.NC} Updated current-plan.txt")

    # ... rest of existing implementation


def get_base_branch():
    """Detect main branch name (main vs master)."""
    for branch in ['main', 'master']:
        result = subprocess.run(
            ["git", "rev-parse", "--verify", branch],
            capture_output=True
        )
        if result.returncode == 0:
            return branch
    return 'HEAD'  # Fallback
```

---

## 3. TUI Integration

### 3.1 Git Status in Header

**Location:** `RichTUIManager` in `scripts/lib/tui.py`

**Enhancement:** Show branch name and divergence in TUI header.

```python
# In RichTUIManager.render():
header_text = f"[bold cyan]PLAN ORCHESTRATOR[/]\n"
header_text += f"Plan: {self.plan_name}\n"
if self.branch_name:
    header_text += f"Branch: {self.branch_name}"
    if self.ahead or self.behind:
        header_text += f" (↑{self.ahead} ↓{self.behind})"
    header_text += "\n"
```

### 3.2 Uncommitted Changes Warning

**Display:** Yellow warning in status bar when uncommitted changes detected.

```python
if self.is_dirty:
    status_bar = "[yellow]⚠ Uncommitted changes[/] | "
```

---

## 4. Error Scenarios

### 4.1 Wrong Branch Detection

**Scenario:** User is on `master` but active plan expects `plan/my-plan`.

**Response:**
```
ERROR: Not on expected branch.
  Current: master
  Expected: plan/my-plan

Options:
  1. Switch to correct branch: git checkout plan/my-plan
  2. Re-run /plan:set to ensure branch exists
```

### 4.2 Dirty State Before Session

**Scenario:** Uncommitted changes from previous interrupted session.

**Response:**
```
WARNING: 5 uncommitted files detected
  src/lib/auth.ts
  src/middleware/validate.ts
  ... 3 more

Continuing with orchestration. Changes will be committed by /plan:implement.
```

### 4.3 Branch Doesn't Exist

**Scenario:** Plan selected but no branch created (legacy plan).

**Response:**
```
ERROR: Plan branch 'plan/old-plan' does not exist.

This may be a legacy plan from before branch management was added.
Run /plan:set old-plan to create the branch.
```

---

## 5. Configuration Options

### 5.1 New CLI Arguments

```
python scripts/plan_orchestrator.py [options]

Git Options:
    --skip-git-check       Skip branch validation (not recommended)
    --auto-stash           Auto-stash uncommitted changes
    --branch <name>        Override expected branch name
```

### 5.2 Environment Variables

```bash
# Skip git validation entirely
ORCHESTRATOR_SKIP_GIT=1

# Auto-stash uncommitted changes
ORCHESTRATOR_AUTO_STASH=1
```

---

## 6. Implementation Priority

### Phase 1: Read-Only Validation (4-5 hours)

- [ ] Add `validate_git_state()` method
- [ ] Add `check_uncommitted_changes()` method
- [ ] Extend `PlanStatus` with git fields
- [ ] Update `__str__` display with git info
- [ ] Add validation check in `run()`
- [ ] Log warnings for uncommitted changes

**Deliverable:** Orchestrator validates branch before starting, warns about dirty state.

### Phase 2: switch_plan.py Enhancement (3-4 hours)

- [ ] Add branch detection logic
- [ ] Implement uncommitted changes handling (C/S/A/F options)
- [ ] Add branch creation from base
- [ ] Add branch switching for existing branches
- [ ] Update status display with branch info

**Deliverable:** `python scripts/switch_plan.py my-plan` creates/switches branch.

### Phase 3: TUI Integration (1-2 hours)

- [ ] Add branch name to header
- [ ] Show ahead/behind counts
- [ ] Add dirty state warning
- [ ] Update status bar styling

**Deliverable:** TUI shows git context during orchestration.

### Phase 4: CLI Arguments (0.5-1 hour)

- [ ] Add `--skip-git-check` option
- [ ] Add `--auto-stash` option
- [ ] Document new options

**Deliverable:** Configurable git behavior.

---

## 7. Testing Considerations

### Test Scenarios

1. **Happy path:** Correct branch, clean state
2. **Wrong branch:** Should error with guidance
3. **Missing branch:** Should error with guidance
4. **Dirty state:** Should warn but continue
5. **Non-git repo:** Should skip validation gracefully
6. **switch_plan.py:** All uncommitted change options (C/S/A/F)

### Mock Strategy

```python
# Mock git commands for testing
def mock_git_command(cmd, returncode=0, stdout="", stderr=""):
    ...
```

---

## 8. Summary

The Python orchestrator needs **minimal changes** since git operations are delegated to `/plan:implement` via Claude. Key changes:

| Component | Change | Priority |
|-----------|--------|----------|
| `plan_orchestrator.py` | Branch validation on start | HIGH |
| `plan_orchestrator.py` | Git metadata in PlanStatus | HIGH |
| `plan_orchestrator.py` | Uncommitted changes warning | MEDIUM |
| `switch_plan.py` | Branch creation/switching | HIGH |
| `lib/tui.py` | Git info in display | LOW |

**Key Design Decision:** The orchestrator **validates** but does not **mutate** git state. All git writes (commits, branch creation) are handled by:
- `/plan:set` - Branch creation
- `/plan:implement` - Commits after tasks
- `/plan:complete` - Merge/cleanup

This separation keeps the orchestrator simple and testable.
