# Task 0.4: Review How Other Automation Tools Handle Git

## Overview

This analysis reviews how other automation tools handle git integration, with a focus on patterns that could inform the orchestrator's git workflow design.

## 1. Claude Code Hooks System

**Source:** `findings/3-3-hooks-system.md`

### Hook Events Relevant to Git

| Hook Event | Git Use Case |
|------------|--------------|
| `PreToolUse` | Validate git state before file operations |
| `PostToolUse` | Trigger commits after file writes |
| `SessionStart` | Check git context (branch, clean status) |
| `SessionEnd` | Cleanup, auto-stash uncommitted changes |
| `Stop` | Final commit before session ends |

### Hook-Based Git Automation Pattern

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "git add -A && git commit -m 'Auto-commit after file change'",
            "timeout": 30
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "git status --porcelain | head -1 && echo 'Git context loaded'"
          }
        ]
      }
    ]
  }
}
```

### Key Features

1. **Deterministic control** - Shell commands run at specific lifecycle points
2. **Parallel execution** - Multiple hooks run simultaneously
3. **Exit code semantics** - Code 2 blocks operations, other codes continue
4. **Environment variables** - `$CLAUDE_PROJECT_DIR`, session IDs available

### Applicability to Orchestrator

- **PostToolUse hooks** could auto-commit after task completion
- **SessionStart hooks** could validate git state before plan execution
- **PreToolUse hooks** could prevent operations on dirty working tree

## 2. GitHub CLI (gh)

**Source:** `findings/2.4-git-tools-analysis.md`

### PR Workflow Automation

```bash
# Create PR from current branch
gh pr create --title "..." --body "..."

# View PR status
gh pr status

# Merge PR
gh pr merge --squash
```

### Patterns for Orchestrator

| Pattern | Description |
|---------|-------------|
| Branch-to-PR | Create PR from feature branch on plan completion |
| Squash merge | Clean history when merging plan branches |
| PR templates | Standardized PR bodies with plan context |

### Integration Opportunity

```bash
# After plan completion
gh pr create \
  --title "Plan: {plan-name}" \
  --body "$(cat docs/plan-outputs/{plan}/summary.md)" \
  --base main
```

## 3. Lazygit (TUI Git Client)

**Source:** `findings/2.4-git-tools-analysis.md`

### Key Features

- **Interactive staging** - Stage specific hunks/lines
- **Commit management** - Amend, reword, squash
- **Branch management** - Create, switch, merge
- **Custom commands** - User-defined git workflows

### Custom Commands Pattern

```yaml
customCommands:
  - key: 'P'
    command: 'gh pr create --web'
    context: 'global'
    description: 'Create PR in browser'

  - key: '<c-f>'
    command: 'git log --oneline | fzf | cut -d " " -f 1'
    context: 'commits'
    description: 'Fuzzy find commit'
```

### Patterns for Orchestrator

1. **Selective staging** - Stage task-specific changes only
2. **Squash interface** - Combine multiple task commits into one
3. **Conflict resolution** - Visual merge conflict handling

## 4. CI/CD Systems (General Patterns)

### GitHub Actions Pattern

```yaml
name: Plan Execution
on:
  push:
    branches: [plan/*]

jobs:
  execute:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Create branch for plan
      - run: git checkout -b plan/${{ github.event.inputs.plan_name }}

      # Execute plan
      - run: ./run-plan.sh

      # Commit results
      - run: |
          git add -A
          git commit -m "Plan execution: ${{ github.event.inputs.plan_name }}"
          git push origin plan/${{ github.event.inputs.plan_name }}

      # Create PR
      - uses: peter-evans/create-pull-request@v5
        with:
          branch: plan/${{ github.event.inputs.plan_name }}
          title: "Plan: ${{ github.event.inputs.plan_name }}"
```

### Key CI/CD Patterns

| Pattern | Description | Orchestrator Analog |
|---------|-------------|---------------------|
| Checkout action | Clone repo at start | Check clean state before plan |
| Branch creation | Isolate changes | Branch per plan |
| Commit after step | Preserve state | Commit after task |
| PR creation | Request review | /plan:complete workflow |
| Artifact upload | Store outputs | findings/ directory |

## 5. Git Pre-commit Hooks

### Standard Pre-commit Pattern

```bash
#!/bin/bash
# .git/hooks/pre-commit

# Run linters
npm run lint || exit 1

# Run tests
npm run test:quick || exit 1

# Check for secrets
git secrets --scan || exit 1
```

### Pre-commit Framework

```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: plan-validation
        name: Validate plan format
        entry: node scripts/validate-plan-format.js
        language: system
        files: docs/plans/.*\.md$
```

### Patterns for Orchestrator

1. **Plan validation** - Validate plan format before commit
2. **Status sync** - Ensure status.json matches markdown
3. **Conflict prevention** - Block commit if concurrent plan changes

## 6. Git-Based Workflow Tools

### Gitflow Pattern

```
master (production)
  └── develop (integration)
        ├── feature/feature-1
        ├── feature/feature-2
        └── release/v1.0
```

### Trunk-Based Development

```
main
  └── short-lived feature branches (< 1 day)
       └── merge back to main quickly
```

### Plan-Based Branching (Proposed)

```
main
  ├── plan/architecture-review
  │     ├── commits per task
  │     └── squash merge when complete
  ├── plan/implement-feature-x
  │     ├── phase-1 tag
  │     ├── phase-2 tag
  │     └── squash merge when complete
  └── hotfix/urgent-fix
```

## 7. Conventional Commits

### Standard Format

```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

### Types for Plan Orchestration

| Type | Use Case |
|------|----------|
| `task` | Individual task completion |
| `phase` | Phase completion (multiple tasks) |
| `plan` | Plan completion (merge commit) |
| `verify` | Verification task completion |
| `fix` | Task retry/fix |

### Example Messages

```
task(1.1): Create authentication middleware

Plan: implement-authentication
Phase: Phase 1: Core Implementation
Duration: 45s
```

```
phase(1): Complete Phase 1: Core Implementation

Tasks completed: 1.1, 1.2, 1.3, 1.4
Duration: 5m 23s
Failed: 0
```

## 8. Summary: Patterns for Orchestrator Integration

### From Claude Code Hooks

| Pattern | Implementation |
|---------|----------------|
| PostToolUse commit | Auto-commit after task file changes |
| SessionStart validation | Check git state before plan execution |
| PreToolUse blocking | Prevent operations on dirty tree |

### From CI/CD Systems

| Pattern | Implementation |
|---------|----------------|
| Branch per plan | `git checkout -b plan/{plan-name}` |
| Commit per task | `git commit -m "task {id}: {description}"` |
| PR on completion | `gh pr create --title "Plan: {name}"` |
| Artifact preservation | findings/ directory tracked |

### From Git Tooling

| Pattern | Implementation |
|---------|----------------|
| Selective staging | Stage only task-related files |
| Interactive squash | Combine task commits for clean history |
| Merge strategy | Squash merge plan branches to main |

### From Conventional Commits

| Pattern | Implementation |
|---------|----------------|
| task() type | Per-task commits |
| phase() type | Phase completion markers |
| plan() type | Plan completion/merge commits |

## Recommended Integration Points

### Immediate (Phase 1)

1. **Commit after task** - Already documented in implement.md, needs enforcement
2. **Git state validation** - Check clean state before plan operations
3. **Conventional commit format** - Standardize message format

### Near-term (Phase 2)

4. **Branch per plan** - Create/switch branches in /plan:set
5. **Tag per phase** - Mark phase completions
6. **Hooks integration** - Claude Code hooks for automatic commits

### Long-term (Phase 3)

7. **PR workflow** - /plan:complete creates PR
8. **Squash merge** - Clean history on plan completion
9. **Rollback commands** - /plan:rollback task/phase
10. **Conflict resolution** - Handle concurrent plan changes

## Key Takeaways

1. **Hooks are the most direct integration point** - Claude Code's hook system provides lifecycle events perfect for git operations

2. **Branch isolation is standard** - All CI/CD systems and workflows use branches for isolation

3. **Conventional commits are widely adopted** - Structured messages enable automation (changelogs, rollback)

4. **Squash merge for clean history** - Multiple task commits → single merge commit

5. **PR workflow for review** - Standard pattern for team workflows

6. **Tags for recovery points** - Phase and plan tags enable rollback
