# Task 5.2: Map Changes Needed in /plan:batch

## Executive Summary

**Current State:** The `/plan:batch` command has zero git awareness - no branch validation, no commit workflow, no git state tracking.

**Gap:** `/plan:implement` documents commits (even if not enforced), but `/plan:batch` doesn't mention them at all.

**Recommendation:** Implement branch pre-checks, commit-per-task (not per-batch), phase completion detection, and atomic write+commit+status operations.

---

## 1. Current State Analysis

### What /plan:batch Does Now

- Multi-task selection and parallel execution
- Agents return content (read-only pattern)
- Main conversation writes files
- Updates status.json after each task
- No git operations documented

### Git Integration Gap

```
Current:  Select ‚Üí Execute ‚Üí Update status.json ‚Üí Done
Missing:  ‚úó Branch check ‚úó Per-task commits ‚úó Phase boundaries ‚úó Git state tracking
```

---

## 2. Branch Pre-Checks (Priority: CRITICAL)

### Add Section 1.6: Verify Git Branch

**Before batch execution starts:**

```bash
current_branch=$(git branch --show-current)
expected_branch="plan/${plan-name}"

# Check 1: Ensure on plan branch
if [ "$current_branch" != "$expected_branch" ]; then
  echo "‚ùå ERROR: Not on expected plan branch"
  echo "   Current: $current_branch"
  echo "   Expected: $expected_branch"
  exit 1
fi

# Check 2: Prevent execution on main/master
if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
  echo "‚ùå ERROR: Cannot execute plan tasks on main branch"
  exit 1
fi

# Check 3: Warn if uncommitted changes
if [[ -n $(git status --porcelain) ]]; then
  echo "‚ö†Ô∏è  WARNING: Uncommitted changes detected"
fi
```

**Missing branch scenarios:**

| Scenario | Behavior |
|----------|----------|
| On main, no plan branch | Create branch `plan/{plan-name}` |
| On wrong plan branch | ERROR + guidance to use `/plan:set` |
| On main, plan branch exists | ERROR + switch suggestion |
| Detached HEAD | ERROR - manual recovery needed |

---

## 3. Commit Strategy in Batch Mode

### Analysis of Options

| Option | Description | Rollback | History |
|--------|-------------|----------|---------|
| A: Per-task | One commit per task | ‚úì Granular | More commits |
| B: Per-batch | One commit for entire batch | ‚úó Coarse | Fewer commits |
| C: Per-phase | One commit at phase boundary | ~ Medium | Natural grouping |

### RECOMMENDATION: Option A (Commit-Per-Task)

**Score: 9/10**

**Rationale:**
1. **Consistency** - Matches `/plan:implement` documented behavior
2. **Rollback** - Preserves per-task revert capability
3. **Debugging** - Git bisect works across batch and non-batch execution
4. **Audit** - Task-level attribution preserved

### Implementation Pattern

**Process completions SEQUENTIALLY after parallel agent execution:**

```
# Parallel group: tasks 1.1, 1.2, 1.3
# Launch agents (parallel)
Agent 1: task 1.1 ‚Üí returns content
Agent 2: task 1.2 ‚Üí returns content
Agent 3: task 1.3 ‚Üí returns content

# Process completions (sequential, in task ID order)
[1.1] ‚Üí Write files ‚Üí git commit ‚Üí markTaskCompleted
[1.2] ‚Üí Write files ‚Üí git commit ‚Üí markTaskCompleted
[1.3] ‚Üí Write files ‚Üí git commit ‚Üí markTaskCompleted
```

### Commit Message Format

```
task {taskId}: {brief description}

Plan: {plan-name}
Phase: {phase-name}
Batch: {runId}
Duration: {duration}

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

**New field:** `Batch: {runId}` - Links commits from same batch execution

---

## 4. Phase Completion Handling

### Phase Boundary Detection

```javascript
function checkPhaseComplete(planPath, taskId) {
  const task = getTaskById(planPath, taskId);
  const phaseTasks = getTasksByPhase(planPath)[task.phase];
  const allComplete = phaseTasks.every(t => t.status === 'completed');

  if (allComplete) {
    return { complete: true, phase: task.phase, taskCount: phaseTasks.length };
  }
  return { complete: false };
}
```

### Phase Completion Options

| Option | Approach | Recommendation |
|--------|----------|----------------|
| Phase commit | Create empty commit marker | ‚úó Clutters history |
| Annotated tag | `git tag -a phase-1-complete` | Optional |
| Status update | Update status.json only | ‚úì Recommended |

### Recommendation: Status Update + Optional Tag

```javascript
if (phaseCheck.complete) {
  updatePlanStatus(planPath, {
    currentPhase: getNextPhase(planPath, phaseCheck.phase)
  });

  console.log(`\n‚úì Phase complete: ${phaseCheck.phase}\n`);

  // Optional: Create tag (if configured)
  if (config.git_workflow.tag_phase_completion) {
    const tagName = `phase-${phaseCheck.phase.replace(/\s+/g, '-')}`;
    execSync(`git tag -a "${tagName}" -m "Phase complete: ${phaseCheck.phase}"`);
  }
}
```

---

## 5. Parallel Execution Git Safety

### Atomic Commit Pattern

**Atomic unit = Write files + Commit changes + Update status**

```javascript
for (const taskResult of completedTasks) {
  try {
    // 1. Write files from agent output
    writeTaskFiles(taskResult.files);

    // 2. Commit changes
    const hasChanges = execSync('git status --porcelain').stdout.length > 0;
    if (hasChanges) {
      execSync('git add -A');
      execSync(`git commit -m "${formatCommitMessage(taskResult)}"`);
      const commitSha = execSync('git rev-parse HEAD').stdout.trim();
      taskResult.commitSha = commitSha;
    }

    // 3. Mark task complete (only after successful commit)
    markTaskCompleted(planPath, taskResult.taskId, taskResult.findings);

  } catch (error) {
    // Rollback on failure
    execSync('git reset --hard HEAD');
    markTaskFailed(planPath, taskResult.taskId, error.message);
  }
}
```

**Guarantees:**
- If commit fails, status.json not updated (task stays in_progress)
- If status update fails, commit already succeeded (can retry update)
- No partial state (either all 3 steps succeed or none)

---

## 6. Progress Markers Enhancement

### Current Format (Lines 494-502)

```
[BATCH] started tasks=5 phases=2
[PROGRESS] task=1.1 status=started agent=parallel
[PROGRESS] task=1.1 status=completed duration=45s
```

### Enhanced with Git State

```
[BATCH] started tasks=5 phases=2 branch=plan/my-feature base_commit=abc123f
[PROGRESS] task=1.1 status=completed duration=45s commit=def456a
[BATCH] phase=1 complete succeeded=2 failed=0 commit_range=def456a..789bcd1
[BATCH] complete succeeded=5 failed=1 duration=3m45s total_commits=5
```

---

## 7. status.json Schema Additions

### Task-Level Git Metadata

```json
{
  "id": "1.1",
  "status": "completed",
  "commitSha": "abc123f456",
  "commitMessage": "task 1.1: Create auth middleware",
  "filesChanged": 3,
  "linesAdded": 145,
  "linesDeleted": 12
}
```

### Run-Level Git Metadata

```json
{
  "runId": "run-001",
  "startedAt": "2024-12-24T10:00:00Z",
  "completedAt": "2024-12-24T10:15:00Z",
  "gitBranch": "plan/implement-auth",
  "baseCommit": "def456a",
  "headCommit": "789bcd1",
  "commitsCreated": 5
}
```

### Plan-Level Git State

```json
{
  "gitBranch": "plan/my-plan",
  "branchCreatedAt": "2024-12-24T09:00:00Z",
  "lastCommitSha": "789bcd1",
  "commitsAhead": 15,
  "commitsBehind": 2
}
```

---

## 8. Implementation Priority

### Phase 1: Critical (Week 1) - 6-9 hours

1. **Branch pre-checks** - Prevent execution on wrong branch
2. **Per-task commits** - Sequential commit processing
3. **Error handling** - Graceful commit failure recovery

**Deliverable:** Batch execution creates per-task commits on correct branch

### Phase 2: Enhanced (Week 2) - 6-8 hours

4. **Phase completion detection** - Detect and track phase boundaries
5. **status.json git metadata** - Add commitSha to tasks and runs
6. **Enhanced progress markers** - Add commit SHA to output

**Deliverable:** Full git integration with phase awareness

### Phase 3: Polish (Week 3) - 6-9 hours

7. **Conflict detection** - Check divergence before batch
8. **Batch commit optimization** - Async commit option
9. **Git metrics** - Show commit range in summary

---

## 9. Key Recommendations

### Commit Strategy
**Use commit-per-task, not commit-per-batch**
- Maintains rollback granularity
- Aligns with /plan:implement
- Enables git bisect

### Branch Safety
**Enforce branch pre-checks**
- Prevent execution on main
- Auto-create plan branch if missing

### Phase Handling
**Update status.json only (no phase commits)**
- Tags optional for milestones
- Status.json sufficient for tracking

### Parallel Execution
**Sequential commit processing**
- Agents run parallel
- Main processes sequentially (write + commit + status)
- Guarantees atomic commits

---

## 10. Success Criteria

After implementation, batch execution should:
- ‚úì Refuse to run on main branch
- ‚úì Create one commit per completed task
- ‚úì Store commit SHA in status.json
- ‚úì Detect phase completion
- ‚úì Handle commit failures gracefully
- ‚úì Preserve atomic commits even in parallel execution
- ‚úì Emit git state in progress markers
