# Task 7.3: Recommended Workflow (Primary + Alternatives)

## Executive Summary

Based on the comprehensive analysis in Phases 1-6 and scoring in Tasks 7.1-7.2, this document presents the recommended git workflow for the plan orchestration system:

**Primary Workflow:** Branch-Per-Plan + Commit-Per-Task + Squash Merge (Hybrid A)

**Score:** 85/100 | **Recommended for:** 90% of plans

---

## Primary Recommended Workflow: Hybrid A

### Overview

The Hybrid A workflow combines three strategies to achieve optimal balance:

| Component | Strategy | Purpose |
|-----------|----------|---------|
| **Branching** | Branch-Per-Plan | Isolation for concurrent work |
| **Commits** | Commit-Per-Task | Granular checkpoints during execution |
| **Merge** | Squash Merge | Clean main branch history |

### Workflow Lifecycle

```
Phase 1: PLAN START
├─ Create plan branch: git checkout -b plan/{plan-name}
├─ Initialize status.json
└─ Record branch in plan metadata

Phase 2: TASK EXECUTION
├─ For each task:
│   ├─ Execute task
│   ├─ Stage all changes: git add -A
│   ├─ Commit: git commit -m "task {id}: {description}"
│   └─ Update status.json with commit SHA
└─ Tag phase completions: git tag plan/{name}/phase-{N}

Phase 3: PLAN COMPLETION
├─ Verify all tasks complete
├─ Create archive tag: git tag archive/plan-{name}
├─ Switch to main: git checkout main
├─ Squash merge: git merge --squash plan/{name}
├─ Commit: git commit -m "Plan: {name} (squashed)"
└─ Delete branch: git branch -D plan/{name}

Phase 4: MAINTENANCE
├─ Archive tag preserves granular history
├─ Access via: git log archive/plan-{name}
└─ Cleanup old archives after retention period
```

### Command Mapping

| User Action | Git Operations |
|-------------|----------------|
| `/plan:set my-plan` | `git checkout -b plan/my-plan` (or switch if exists) |
| `/plan:implement 1.1` | Execute task → `git add -A && git commit -m "task 1.1: ..."` |
| `/plan:status` | Show current branch, uncommitted changes, progress |
| `/plan:complete` | Archive tag → squash merge → delete branch |
| `/plan:rollback task 1.1` | `git revert <commit-sha>` |
| `/plan:abandon` | `git checkout main && git branch -D plan/my-plan` |

### Benefits of Hybrid A

1. **Complete isolation:** Plan work never affects main until explicit merge
2. **Granular rollback:** Per-task revert available during execution
3. **Clean history:** Main shows one commit per plan
4. **Debugging access:** Archive tags preserve task-level history
5. **Team alignment:** Matches GitHub/GitLab PR workflow
6. **Automation friendly:** All operations non-interactive

### Limitations and Mitigations

| Limitation | Mitigation |
|------------|------------|
| Branch management overhead | Orchestrator automates all branching |
| Archive tag management | Automated cleanup after retention period |
| Task rollback after merge | Access via archive tag or revert merge commit |
| Merge conflicts at completion | Sync with main periodically, resolve at merge |

---

## Alternative Workflow A: Audit-Heavy (Merge Commit)

### When to Use

- Regulatory compliance requiring granular audit trail on main
- High debugging needs (frequent bisect, blame)
- Plans with historical significance (major refactors, migrations)

### Differences from Primary

| Aspect | Primary (Squash) | Alternative A (Merge Commit) |
|--------|------------------|------------------------------|
| Main history | 1 commit per plan | All task commits visible |
| Task rollback post-merge | Via archive tag | Direct on main |
| History noise | Clean | Noisy (mitigated by `--first-parent`) |
| Merge command | `git merge --squash` | `git merge --no-ff` |

### Workflow Modifications

```bash
# At plan completion (instead of squash)
git checkout main
git merge --no-ff plan/{name} -m "Plan: {name}"

# View clean history (first-parent only)
git log --first-parent main

# Task rollback on main (available directly)
git revert <task-commit-sha>
```

### Command Option

```bash
/plan:complete --merge commit    # Use merge commit instead of squash
```

---

## Alternative Workflow B: Heavy Verification (Branch-Per-Phase)

### When to Use

- Phase verification takes >10 minutes (infrastructure, integration tests)
- Phase failure rate >20%
- Regulatory requirements for phase-level audit trail
- Multi-developer parallel phase work

### Differences from Primary

| Aspect | Primary | Alternative B (Branch-Per-Phase) |
|--------|---------|----------------------------------|
| Branch hierarchy | 2 levels (main, plan) | 3 levels (main, plan, phase) |
| Commit count per 100-task plan | ~100 on branch | ~100 across phase branches |
| Phase isolation | Tags only | Full branch isolation |
| Implementation complexity | Medium | High (+80%) |
| Mental model | Simple | Complex |

### Workflow Modifications

```
Plan Branch: plan/{name}
├─ Phase Branch: plan/{name}/phase-1
│   ├─ task commits (1.1, 1.2, 1.3...)
│   └─ VERIFY 1 passes → merge to plan branch
├─ Phase Branch: plan/{name}/phase-2
│   ├─ task commits (2.1, 2.2, 2.3...)
│   └─ VERIFY 2 passes → merge to plan branch
└─ Plan completion → squash merge to main
```

### Configuration

```json
{
  "git_workflow": {
    "strategy": "branch-per-phase",
    "phase_branch_pattern": "plan/{plan}/phase-{N}"
  }
}
```

---

## Alternative Workflow C: Solo Developer Simplified

### When to Use

- Solo developer on personal projects
- Plans with <5 tasks
- Rapid experimentation (many short plans)
- Low rollback requirements

### Differences from Primary

| Aspect | Primary | Alternative C (Simplified) |
|--------|---------|---------------------------|
| Branching | Required | Optional |
| Commits | Per-task (enforced) | Per-task (optional) |
| Merge | Squash | Fast-forward or direct |
| Complexity | Moderate | Minimal |

### Workflow Modifications

```bash
# Option 1: Work directly on main (very small plans)
git checkout main
# Execute tasks with optional commits
/plan:implement 1.1 --no-commit  # Manual control
git commit -m "Plan: quick-fix (3 tasks)"

# Option 2: Branch without squash (preserve granularity)
git checkout -b plan/quick-fix
/plan:implement 1.1 1.2 1.3
git checkout main
git merge --ff-only plan/quick-fix  # Keep task commits on main
```

### Configuration

```json
{
  "git_workflow": {
    "auto_branch": false,
    "auto_commit": false,
    "merge_strategy": "fast-forward"
  }
}
```

---

## Workflow Selection Guide

### Quick Reference Matrix

| Scenario | Recommended Workflow |
|----------|---------------------|
| Team project with PRs | **Primary (Hybrid A)** |
| Solo developer, production | **Primary (Hybrid A)** |
| Regulatory/compliance | **Alternative A (Merge Commit)** |
| Expensive verification | **Alternative B (Branch-Per-Phase)** |
| Solo, experimental | **Alternative C (Simplified)** |
| OSS contribution | **Primary (Hybrid A)** |

### Decision Flowchart

```
START
│
├─ Team project with code review?
│   └─ YES → Primary Workflow (Hybrid A)
│
├─ Regulatory/compliance requirements?
│   └─ YES → Alternative A (Merge Commit)
│
├─ Phase verification takes >10 min AND phase failure >20%?
│   └─ YES → Alternative B (Branch-Per-Phase)
│
├─ Solo developer with <5 task plans?
│   └─ YES → Alternative C (Simplified)
│
└─ DEFAULT → Primary Workflow (Hybrid A)
```

---

## Configuration Reference

### Default Configuration (Hybrid A)

```json
{
  "git_workflow": {
    "strategy": "branch-per-plan",
    "branch_prefix": "plan/",
    "auto_commit": true,
    "commit_template": "task {id}: {description}",
    "merge_strategy": "squash",
    "archive_branches": true,
    "archive_prefix": "archive/plan-",
    "archive_retention_days": 90,
    "phase_tags": true,
    "tag_pattern": "plan/{name}/phase-{N}",
    "enforce_branch": true,
    "sync_remote": false
  }
}
```

### Override Options

| Option | CLI Flag | Values |
|--------|----------|--------|
| Merge strategy | `--merge` | `squash`, `commit`, `ff` |
| Skip auto-commit | `--no-commit` | (flag) |
| Skip branching | `--no-branch` | (flag) |
| Archive retention | `--archive-days` | Integer (days) |

---

## Rollback Procedures

### Task-Level Rollback (During Execution)

```bash
# Find task commit
git log --grep="task 1.3:" --oneline -1
# abc123 task 1.3: Create auth middleware

# Revert the task
git revert abc123 --no-edit

# Update status.json
/plan:rollback task 1.3
```

### Task-Level Rollback (After Merge)

```bash
# Access archive tag
git log archive/plan-implement-auth --grep="task 1.3:" --oneline -1

# Checkout specific file from before task
git checkout archive/plan-implement-auth~5 -- src/auth/middleware.js
git commit -m "Restore middleware from before task 1.3"
```

### Phase-Level Rollback

```bash
# Option 1: Reset to phase start (if on branch)
git reset --hard plan/implement-auth/phase-1

# Option 2: Revert range of commits
git log --grep="Phase 2:" --oneline  # Find phase commits
git revert <first-phase-2-commit>..<last-phase-2-commit>
```

### Plan-Level Rollback (Not Yet Merged)

```bash
# Simply delete the branch
git checkout main
git branch -D plan/implement-auth
```

### Plan-Level Rollback (After Merge)

```bash
# Revert the squash commit on main
git log --grep="Plan: implement-auth" --oneline -1
# xyz789 Plan: implement-auth (squashed)

git revert xyz789 --no-edit
```

---

## Summary

### Primary Recommendation: Hybrid A

**Branch-Per-Plan + Commit-Per-Task + Squash Merge**

| Aspect | Score |
|--------|-------|
| Requirements coverage | 85/100 |
| Flexibility | 9/10 |
| Simplicity | 8/10 |
| Safety | 9/10 |

### Key Takeaways

1. **Default to Hybrid A** for 90% of plans
2. **Use Merge Commit** for audit/debug requirements
3. **Use Branch-Per-Phase** only for expensive verification
4. **Use Simplified** only for solo experimental work
5. **All workflows support rollback** at appropriate granularity levels
6. **Archive tags preserve granular history** even after squash merge
