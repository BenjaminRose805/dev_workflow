# Task 6.2: Handle Merge Conflicts During Plan Execution

## Executive Summary

Merge conflicts can occur during plan execution in two scenarios: **external updates** (remote changes) and **internal conflicts** (task-generated conflicts). This document defines detection, prevention, and resolution strategies for both.

**Key Principle:** Pause execution on conflict, preserve state, guide resolution.

---

## 1. Conflict Scenarios

### 1.1 External Conflicts (Remote Updates)

**When:** Base branch (main) updated while plan branch diverges.

**Detection Point:**
- During `/plan:complete` merge to main
- During periodic sync checks (if enabled)
- During manual `git pull`

**Example:**
```
              main: A → B → C → D (updated by teammate)
                     ↘
plan/my-plan:         B → E → F → G (plan commits)
                                  ↑
                          Conflict here on merge
```

### 1.2 Internal Conflicts (Task Collisions)

**When:** Two tasks in the same batch modify the same file.

**Detection Point:**
- During `/plan:implement` task commits
- During agent output merging

**Example:**
```
Task 1.1: Modifies src/auth.ts lines 10-20
Task 1.2: Modifies src/auth.ts lines 15-25
                            ↑
                    Overlapping changes
```

### 1.3 Parallel Agent Conflicts

**When:** Multiple agents generate conflicting code for the same file.

**Detection Point:**
- During `/plan:implement` file writing phase
- When collecting agent outputs

**Example:**
```
Agent A: Returns FILE: src/types.ts with interface User { ... }
Agent B: Returns FILE: src/types.ts with interface User { ... } (different)
                                          ↑
                              Must reconcile before writing
```

---

## 2. Conflict Detection

### 2.1 Pre-Merge Conflict Check

```bash
# Dry-run merge to detect conflicts
git merge --no-commit --no-ff main

if [ $? -ne 0 ]; then
  echo "Conflicts detected"
  git merge --abort
fi
```

### 2.2 Conflict Detection Function

```javascript
async function detectMergeConflicts(targetBranch = 'main') {
  const result = {
    hasConflicts: false,
    conflictFiles: [],
    canAutoResolve: false
  };

  try {
    // Attempt dry-run merge
    const mergeResult = execSync(
      `git merge --no-commit --no-ff ${targetBranch} 2>&1`,
      { encoding: 'utf8' }
    );

    // If we get here, no conflicts
    execSync('git merge --abort');
    result.hasConflicts = false;

  } catch (error) {
    // Parse conflict files from error output
    const output = error.stdout || error.message;
    const conflictMatch = output.match(/CONFLICT.*: (.*)/g);

    if (conflictMatch) {
      result.hasConflicts = true;
      result.conflictFiles = conflictMatch.map(line => {
        const match = line.match(/CONFLICT.*: (.*)/);
        return match ? match[1] : line;
      });
    }

    // Clean up
    execSync('git merge --abort', { stdio: 'ignore' });
  }

  return result;
}
```

### 2.3 Conflict Status in status.json

```json
{
  "git": {
    "mergeStatus": {
      "lastCheck": "2025-12-24T15:30:00Z",
      "hasConflicts": true,
      "conflictsWith": "main",
      "conflictFiles": [
        "src/lib/auth.ts",
        "src/routes/api.ts"
      ],
      "conflictDetectedAt": "2025-12-24T15:30:00Z"
    }
  }
}
```

---

## 3. Prevention Strategies

### 3.1 Pre-Execution Sync Check

**Before starting /plan:implement batch:**

```javascript
async function preExecutionCheck() {
  // Check if base branch has updates
  execSync('git fetch origin main');

  const behind = execSync(
    'git rev-list --count HEAD..origin/main'
  ).toString().trim();

  if (parseInt(behind) > 0) {
    console.log(`⚠ Base branch is ${behind} commits ahead`);
    console.log('Consider syncing before continuing:');
    console.log('  git merge origin/main');
    // Don't block, just warn
  }
}
```

### 3.2 Task Ordering for Conflict Avoidance

**In /plan:implement:**

```javascript
function orderTasksForSafety(tasks) {
  // Group tasks by files they modify
  const fileToTasks = new Map();

  for (const task of tasks) {
    const affectedFiles = predictAffectedFiles(task);
    for (const file of affectedFiles) {
      if (!fileToTasks.has(file)) {
        fileToTasks.set(file, []);
      }
      fileToTasks.get(file).push(task);
    }
  }

  // Find conflicts
  const conflicts = [];
  for (const [file, fileTasks] of fileToTasks) {
    if (fileTasks.length > 1) {
      conflicts.push({ file, tasks: fileTasks });
    }
  }

  if (conflicts.length > 0) {
    console.log('⚠ Potential conflicts detected:');
    for (const { file, tasks } of conflicts) {
      console.log(`  ${file}: Tasks ${tasks.map(t => t.id).join(', ')}`);
    }
    console.log('Running conflicting tasks sequentially...');
  }

  // Return ordered list: non-conflicting parallel, conflicting sequential
  return reorderForSafety(tasks, conflicts);
}
```

### 3.3 Agent Output Reconciliation

**When collecting agent outputs:**

```javascript
function reconcileAgentOutputs(agentOutputs) {
  // Group by file
  const fileContents = new Map();

  for (const output of agentOutputs) {
    const { file, content, agentId } = output;

    if (!fileContents.has(file)) {
      fileContents.set(file, []);
    }
    fileContents.get(file).push({ content, agentId });
  }

  // Detect conflicts
  const conflicts = [];
  const resolved = new Map();

  for (const [file, contents] of fileContents) {
    if (contents.length === 1) {
      resolved.set(file, contents[0].content);
    } else {
      // Multiple agents wrote to same file
      conflicts.push({
        file,
        versions: contents.map(c => ({
          agentId: c.agentId,
          preview: c.content.substring(0, 200)
        }))
      });
    }
  }

  return { resolved, conflicts };
}
```

---

## 4. Resolution Workflows

### 4.1 External Conflict Resolution Flow

```
/plan:complete (or sync)
        │
        ▼
┌──────────────────┐
│ Attempt merge    │
│ main → plan/*    │
└────────┬─────────┘
         │
         ▼
    Conflicts?───No───► Complete merge
         │
        Yes
         │
         ▼
┌──────────────────┐
│ Abort merge      │
│ Save conflict    │
│ state to JSON    │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ Pause execution  │
│ Notify user      │
└────────┬─────────┘
         │
         ▼
User resolves manually
         │
         ▼
User runs /plan:resume
         │
         ▼
Execution continues
```

### 4.2 User Resolution Prompt

```
⛔ Merge conflicts detected during plan completion

Conflicts in 3 files:
  • src/lib/auth.ts
  • src/routes/api.ts
  • src/middleware/validate.ts

These conflicts must be resolved manually.

Resolution Steps:
  1. Open conflicting files
  2. Look for <<<<<<< HEAD markers
  3. Keep desired changes, remove markers
  4. Stage resolved files: git add <file>
  5. Complete merge: git commit

After resolving, run:
  /plan:resume

Need help?
  git diff --name-only --diff-filter=U  # List conflicting files
  git checkout --ours <file>            # Keep our version
  git checkout --theirs <file>          # Keep their version
```

### 4.3 Conflict Resolution Commands

**New status-cli.js commands:**

```bash
# Check for active conflicts
node scripts/status-cli.js conflict-status

# Mark conflicts as resolved
node scripts/status-cli.js conflict-resolved

# Abort conflict resolution
node scripts/status-cli.js conflict-abort
```

### 4.4 Automated Resolution Strategies

**For low-risk conflicts (optional):**

```javascript
const AUTO_RESOLVE_STRATEGIES = {
  // Keep our version for plan-specific files
  'docs/plan-outputs/': 'ours',

  // Keep their version for dependency files
  'package-lock.json': 'theirs',
  'yarn.lock': 'theirs',

  // Never auto-resolve source code
  'src/': 'manual',
  'tests/': 'manual'
};

function canAutoResolve(file) {
  for (const [pattern, strategy] of Object.entries(AUTO_RESOLVE_STRATEGIES)) {
    if (file.startsWith(pattern)) {
      return strategy !== 'manual' ? strategy : null;
    }
  }
  return null;
}
```

---

## 5. Task-Level Conflict Handling

### 5.1 Commit Conflict During Task

**Scenario:** Task modifies file that was changed since task started.

**Detection:**

```bash
# Before committing task changes
git diff --check  # Check for conflict markers

# During git add
git add src/file.ts 2>&1 | grep -q "conflict"
```

**Handling:**

```javascript
async function commitTaskChanges(taskId, files) {
  try {
    execSync('git add ' + files.join(' '));
    execSync(`git commit -m "task ${taskId}: ..."`);
    return { success: true };

  } catch (error) {
    if (error.message.includes('conflict')) {
      return {
        success: false,
        reason: 'conflict',
        message: `Task ${taskId} cannot commit due to conflicts`,
        conflictFiles: extractConflictFiles(error.message)
      };
    }
    throw error;
  }
}
```

### 5.2 Parallel Task Conflict

**When two tasks in same batch conflict:**

```javascript
function handleParallelTaskConflict(task1, task2, conflictFiles) {
  console.log(`⚠ Tasks ${task1.id} and ${task2.id} conflict on:`);
  for (const file of conflictFiles) {
    console.log(`  • ${file}`);
  }

  // Strategy: Run them sequentially
  console.log('\nRe-running tasks sequentially...');

  // Revert task2 changes
  execSync('git checkout -- ' + conflictFiles.join(' '));

  // Re-run task2 after task1's changes are committed
  return {
    action: 'rerun_sequential',
    firstTask: task1.id,
    secondTask: task2.id
  };
}
```

---

## 6. Conflict State Persistence

### 6.1 Conflict Record in status.json

```json
{
  "conflicts": {
    "active": true,
    "detectedAt": "2025-12-24T15:30:00Z",
    "type": "merge",
    "source": "main",
    "target": "plan/my-plan",
    "files": [
      {
        "path": "src/lib/auth.ts",
        "ours": "abc1234",
        "theirs": "def5678",
        "status": "unresolved"
      }
    ],
    "pausedTaskId": "3.2",
    "pausedBatchId": "batch-5"
  }
}
```

### 6.2 Resume After Resolution

```javascript
async function resumeAfterConflict() {
  const status = loadStatus();

  if (!status.conflicts || !status.conflicts.active) {
    console.log('No active conflicts to resume from.');
    return;
  }

  // Verify conflicts are resolved
  const unresolved = await checkUnresolvedConflicts();
  if (unresolved.length > 0) {
    console.log('⚠ Some conflicts still unresolved:');
    for (const file of unresolved) {
      console.log(`  • ${file}`);
    }
    return;
  }

  // Clear conflict state
  status.conflicts.active = false;
  status.conflicts.resolvedAt = new Date().toISOString();
  saveStatus(status);

  // Resume execution
  console.log('✓ Conflicts resolved. Resuming execution...');
  const resumeTaskId = status.conflicts.pausedTaskId;

  // Re-run /plan:implement from paused task
  return { resumeFrom: resumeTaskId };
}
```

---

## 7. User Notifications

### 7.1 Conflict Detection Notification

```
╔═══════════════════════════════════════════════════════════════╗
║  ⛔ MERGE CONFLICT DETECTED                                    ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                 ║
║  Plan execution paused at task 3.2                             ║
║                                                                 ║
║  Conflicting files:                                            ║
║    • src/lib/auth.ts                                           ║
║    • src/routes/api.ts                                         ║
║                                                                 ║
║  Resolution required before continuing.                        ║
║                                                                 ║
║  Run /plan:status for detailed conflict info.                  ║
║  Run /plan:resume after resolving conflicts.                   ║
║                                                                 ║
╚═══════════════════════════════════════════════════════════════╝
```

### 7.2 TUI Conflict Indicator

```python
# In TUI status bar
if status.has_conflicts:
    status_bar = "[red]⛔ CONFLICTS[/] | "
    status_bar += f"[dim]{len(status.conflict_files)} files[/]"
```

---

## 8. Integration Points

### 8.1 /plan:implement

```javascript
// Before executing batch
const conflicts = await detectMergeConflicts();
if (conflicts.hasConflicts) {
  console.log('⚠ Conflicts with main branch detected.');
  console.log('Consider syncing before continuing.');
  // Don't block, just warn
}

// After each task
const commitResult = await commitTaskChanges(taskId, files);
if (!commitResult.success && commitResult.reason === 'conflict') {
  await pauseExecution(taskId, commitResult);
  return;
}
```

### 8.2 /plan:complete

```javascript
// During merge
try {
  execSync('git merge --no-ff main');
} catch (error) {
  if (error.message.includes('CONFLICT')) {
    await handleMergeConflict(error);
    return;
  }
}
```

### 8.3 Python Orchestrator

```python
def handle_conflict_state(self):
    """Check for and handle conflict state."""
    status = self.get_status()

    if status and status.has_conflicts:
        self.logger.error("Plan has unresolved conflicts")
        if self.use_tui:
            self.tui.set_status("⛔ Conflicts detected - manual resolution required")
        return False  # Stop orchestration

    return True  # Continue
```

---

## 9. Prevention Best Practices

### 9.1 Recommendations for Plan Authors

1. **Minimize file overlap between tasks** in same phase
2. **Group related file changes** in single tasks
3. **Use phases to separate** high-conflict areas
4. **Sync frequently** during long-running plans

### 9.2 Orchestrator Recommendations

1. **Run conflict check** before each batch
2. **Warn but don't block** on potential conflicts
3. **Pause immediately** on actual conflicts
4. **Preserve complete state** for resume

---

## 10. Summary

### Conflict Handling Matrix

| Scenario | Detection | Response | Recovery |
|----------|-----------|----------|----------|
| External (main updated) | Pre-merge check | Pause + notify | Manual resolve |
| Task commit conflict | git add failure | Mark task failed | Re-run task |
| Parallel agent conflict | Output comparison | Rerun sequential | Automatic |
| Merge in progress | .git/MERGE_HEAD | Block switch | Complete/abort merge |

### Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Pause on conflict | Never auto-resolve source code |
| Preserve state | Enable clean resume after resolution |
| Warn on potential | Don't block unnecessarily |
| Manual resolution | User knows intent better than automation |

**Estimated Effort:** 6-8 hours for complete implementation.
