# Task 4.3: Implicit Dependency Detection Analysis

**Analysis Plan:** TUI Expansion Analysis
**Task Number:** 4.3
**Date:** 2025-12-26
**Scope:** Analyze implicit dependency detection mechanisms (without explicit `depends:` syntax)

---

## Executive Summary

The dev_workflow system implements **four complementary mechanisms** for detecting task dependencies implicitly:

1. **Phase-based ordering** - Task phase number provides coarse execution guidance
2. **[SEQUENTIAL] annotations** - Explicit groups enforced by orchestrator
3. **File conflict detection** - Automatic detection of shared file modifications
4. **Textual task mentions** - Manual detection (not automated)

Combined, these mechanisms catch ~70% of dependency cases without explicit `(depends:)` syntax.

---

## 1. Overview of Implicit Dependency Mechanisms

| Mechanism | Type | Detection | Enforcement | Accuracy |
|-----------|------|-----------|-------------|----------|
| **Phase ordering** | Plan-level | Automatic | Sort key | 70% |
| **[SEQUENTIAL]** | Task group | Regex parse | Orchestrator filter | 90% |
| **File conflicts** | File-level | Pattern extract | Auto-mark sequential | 65% |
| **Task mentions** | Task-to-task | Manual review | Manual | 40% |

---

## 2. Mechanism #1: Phase-Based Implicit Ordering

### How It Works

Tasks inherit implicit ordering from phase numbers. Phase is a **sort key**, not a blocking gate.

**Location:** `scripts/lib/plan-status.js:2182-2189` in `getReadyTasks()`

**Phase Extraction:**
```javascript
const phaseMatch = task.phase ? task.phase.match(/Phase\s+(\d+)/) : null;
const phaseNumber = phaseMatch ? parseInt(phaseMatch[1]) : 0;
```

### Sort Priority

```javascript
readyTasks.sort((a, b) => {
  if (a.phaseNumber !== b.phaseNumber) {
    return a.phaseNumber - b.phaseNumber;  // Earlier phases first
  }
  return a.id.localeCompare(b.id, undefined, { numeric: true });
});
```

### Detection Accuracy

| Scenario | Detected | Enforced |
|----------|----------|----------|
| Task in later phase should wait | ✓ (sort order) | ✗ (not a gate) |
| All earlier phase tasks complete | ✗ Not tracked | N/A |

---

## 3. Mechanism #2: [SEQUENTIAL] Annotation Parsing

### Syntax Pattern

```markdown
**Execution Note:** Tasks X.Y-X.Z are [SEQUENTIAL] - <reason>
```

**Location:** `scripts/lib/plan-status.js:950-995` in `parseExecutionNotes()`

### Supported Variations

| Pattern | Example | Tasks Selected |
|---------|---------|----------------|
| Range | `Tasks 3.1-3.4 are [SEQUENTIAL]` | 3.1, 3.2, 3.3, 3.4 |
| Single | `Task 3.1 is [SEQUENTIAL]` | 3.1 |
| List | `Tasks 3.1, 3.3 are [SEQUENTIAL]` | 3.1, 3.3 only |
| Multiple ranges | `Tasks 2.1-2.3 and 3.1-3.4` | All six tasks |

### Enforcement

**Location:** `scripts/plan_orchestrator.py:215-261`

```python
def _filter_sequential_tasks(self, tasks: list) -> list:
    seen_groups = set()
    filtered = []
    for task in tasks:
        seq_group = task.get("sequentialGroup")
        if seq_group:
            if seq_group in seen_groups:
                continue  # Hold back duplicate group members
            seen_groups.add(seq_group)
        filtered.append(task)
    return filtered
```

### Real-World Examples

From `tui-integration-implementation.md`:
```markdown
**Execution Note:** Tasks 2.1-2.6 are [SEQUENTIAL] - all modify TUI layout
```

From `documentation-cleanup.md`:
```markdown
**Execution Note:** Tasks 3.1-3.4 are [SEQUENTIAL] - all modify orchestrator-system.md
```

---

## 4. Mechanism #3: File Conflict Detection

### How It Works

The system automatically detects when multiple tasks mention the same file path, inferring they cannot execute in parallel.

### File Reference Extraction

**Location:** `scripts/lib/plan-status.js:1931-1976` in `extractFileReferences()`

**Four Regex Patterns:**

```javascript
const patterns = [
  /`([^`]+\.[a-z]{2,4})`/gi,              // Backtick-quoted paths
  /\b(src\/[^\s,]+)/gi,                    // src/ paths
  /\b(tests?\/[^\s,]+)/gi,                 // test/ paths
  /\b(docs\/[^\s,]+)/gi,                   // docs/ paths
  /modify(?:ing)?\s+([^\s,]+\.[a-z]+)/gi   // "modifying X.ts"
];
```

### Conflict Detection Algorithm

**Location:** `scripts/lib/plan-status.js:1993-2036` in `detectFileConflicts()`

```javascript
function detectFileConflicts(tasks) {
  const fileToTasks = new Map();

  for (const task of tasks) {
    const files = extractFileReferences(task.description);
    for (const file of files) {
      if (!fileToTasks.has(file)) {
        fileToTasks.set(file, []);
      }
      fileToTasks.get(file).push(task.id);
    }
  }

  const conflicts = [];
  for (const [file, taskIds] of fileToTasks) {
    if (taskIds.length > 1) {
      conflicts.push({ file, taskIds });
    }
  }
  return conflicts;
}
```

### Detection Coverage

| Pattern | Example | Detected |
|---------|---------|----------|
| Backtick paths | `` `src/api.ts` `` | ✓ Yes |
| Known prefixes | `src/lib/auth.ts` | ✓ Yes |
| Action verbs | `Modify status-cli.js` | ✓ Yes |
| Unknown prefixes | `app/components/Button.tsx` | ✗ No |
| Basenames only | `Update README.md file` | ✗ No |

---

## 5. Mechanism #4: Textual Task Mention Detection

### Current State

Tasks can implicitly reference other tasks by mentioning them in the description:

```markdown
- [ ] 2.3 Create user service (depends on 2.1, 2.2)
- [ ] 0.3 Update status tracking after 0.2 completes
```

**Status:** NOT AUTOMATED - Requires manual review during implementation.

The `/plan:implement` command instructs agents to check for task mentions, but no automated parsing exists.

---

## 6. Gaps in Implicit Detection

### Gap 1: No Cross-Phase Implicit Dependencies

**Current:** Phase number is only a sort key
**Issue:** Cannot express "Task 2.3 should wait for Task 1.5"
**Workaround:** Use `[SEQUENTIAL]` or `(depends:)` syntax

### Gap 2: [SEQUENTIAL] Enforces ID Order Only

**Current:** Sequential groups enforce order by task ID (1.1, 1.2, 1.3)
**Issue:** If Task 1.3 should run before 1.1, the annotation cannot express this
**Impact:** Task IDs must be manually ordered to match dependencies

### Gap 3: File Conflict Detection Limited by Patterns

**Missing patterns:**
- Unquoted basenames: `"Update README.md file"`
- Unknown directory prefixes: `"app/components/Button.tsx"`
- Wildcard patterns: `"all .js files in src/"`

### Gap 4: No Implicit Type/Import Dependencies

**Issue:** Task 2.1 might generate types that Task 2.2 uses, but this is not detected
**Impact:** Tasks may fail with "type not found" errors

---

## 7. Comparison: Explicit vs Implicit Accuracy

| Detection Method | Scope | Accuracy | Ease of Use |
|------------------|-------|----------|-------------|
| **Phase ordering** | Plan-level | 70% | Automatic |
| **[SEQUENTIAL]** | Task group | 90% | Manual annotation |
| **File conflicts** | File-level | 65% | Automatic |
| **Task mentions** | Task-to-task | 40% | Manual review |
| **`(depends:)` syntax** | Task-to-task | 95% | Manual annotation |

### False Positives

File conflict detection can create false positives:

**Example:**
```markdown
Task 2.1: Read and analyze src/api.ts
Task 2.2: Add new endpoint in src/api.ts
```
Marked as conflict: YES (both mention src/api.ts)
Actual conflict: Depends on whether Task 2.1 only reads

### False Negatives

Implicit detection can miss real dependencies:

1. **Type dependency not detected:**
   - Task 1.2: Generate type definitions
   - Task 2.1: Use types from Task 1.2
   - Detection: None (no file mention in Task 2.1)

2. **Cross-file import not detected:**
   - Task 2.1: Create src/auth.ts
   - Task 2.2: Import from src/auth.ts (not mentioned)
   - Detection: None

---

## 8. Implementation in /plan:implement

### Detection Sequence in Step 4

From `/plan:implement` command:

```markdown
**Group by phase for execution (respecting constraints):**
- Tasks in DIFFERENT phases: Always sequential (phase order matters)
- Tasks in SAME phase with `[SEQUENTIAL]`: Run one at a time
- Tasks in SAME phase with file conflicts: Run one at a time
- Tasks in SAME phase, independent: Can run in parallel
```

### Execution Preview

```
Execution Plan:
├── Sequential Group 1 (Phase 0):
│   └── 0.3 Update playwright.config.ts
├── Parallel Group 2 (Phase 1):
│   ├── 1.1 websocket-connection.test.ts
│   ├── 1.2 preferences-store.test.ts
│   └── 1.3 api-utils.test.ts
├── Sequential Group 3 (Phase 3) [SEQUENTIAL]:
│   ├── 3.1 Merge ORCHESTRATOR.md content
│   ├── 3.2 Merge ARCHITECTURE.md content
```

---

## 9. TUI Integration Opportunities

### Data Available from cmdNext()

```json
{
  "tasks": [
    {
      "id": "2.1",
      "fileConflict": true,
      "conflictsWith": ["2.2"],
      "conflictingFiles": ["src/api.ts"],
      "sequential": true,
      "sequentialGroup": "2.1-2.3",
      "sequentialReason": "all modify same file"
    }
  ],
  "fileConflicts": [
    { "file": "src/api.ts", "taskIds": ["2.1", "2.2"] }
  ]
}
```

### Proposed TUI Enhancements

1. **Conflict badge:** Show `⚠` on tasks with `fileConflict: true`
2. **Sequential grouping:** Visual bracket around `[SEQUENTIAL]` tasks
3. **File conflict panel:** List shared files with task IDs
4. **Phase progress bars:** Show completion % per phase

---

## 10. Recommendations for Enhancement

### Priority 1: Improve File Conflict Detection

- Add Pattern 5 for common unquoted filenames
- Add more directory prefixes: `app/`, `components/`, `pages/`

### Priority 2: Add Explicit (depends:) Adoption

- Document migration path from `[SEQUENTIAL]` to `(depends:)`
- Both systems can coexist

### Priority 3: Enhanced TUI Feedback

- Show conflict badge on tasks
- Display sequential group membership
- Highlight active phases in cross-phase execution

---

## Summary Table: All Implicit Mechanisms

| Mechanism | Scope | Syntax | Detection | Enforcement | Accuracy |
|-----------|-------|--------|-----------|-------------|----------|
| **Phase ordering** | Plan-level | `## Phase N:` | Automatic | Sort only | 70% |
| **[SEQUENTIAL]** | Task group | `**Execution Note:**` | Regex parse | Orchestrator | 90% |
| **File conflicts** | File-level | Task description | Pattern extract | Auto-mark | 65% |
| **Task mentions** | Task-to-task | Task description | Manual review | Manual | 40% |

### Combined Effectiveness

When all four mechanisms work together:
- **Phase ordering** provides coarse-grained execution guidance
- **[SEQUENTIAL]** groups enforce strict execution sequences
- **File conflicts** prevent race conditions on shared files
- **Task mentions** provide semantic context for planners

**Limitation:** No single mechanism covers all dependency types. Complex plans still require explicit `(depends:)` syntax.
