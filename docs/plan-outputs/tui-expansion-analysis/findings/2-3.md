# Task 2.3: Annotation Flow Through Orchestration Pipeline

## Summary

This analysis traces how `[SEQUENTIAL]`, `[PARALLEL]`, and other execution annotations flow from the plan markdown file through the orchestration system to final task execution. The pipeline has multiple stages where annotations are parsed, stored, queried, and acted upon.

## Pipeline Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        ANNOTATION FLOW DIAGRAM                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  docs/plans/my-plan.md                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ **Execution Note:** Tasks 3.1-3.4 are [SEQUENTIAL] - file share │    │
│  │ **Execution Note:** Phases 1-3 are [PARALLEL] - independent      │    │
│  └────────────────────────────┬────────────────────────────────────┘    │
│                               ▼                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ scripts/lib/plan-status.js                                       │    │
│  │ ├── parseExecutionNotes(content)  ← Entry point                  │    │
│  │ │   ├── expandTaskRange("3.1-3.4")                               │    │
│  │ │   └── expandPhaseRange("1-3")                                  │    │
│  │ └── Returns { sequential: [...], parallel: [...], ... }          │    │
│  └────────────────────────────┬────────────────────────────────────┘    │
│                               ▼                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ scripts/status-cli.js (cmdNext)                                  │    │
│  │ ├── Parses plan fresh for each query                             │    │
│  │ ├── Builds parallelPhaseSet from constraints.parallel            │    │
│  │ ├── Adds task flags: sequential, sequentialGroup, parallelPhase  │    │
│  │ └── Returns enriched task list with constraint metadata          │    │
│  └────────────────────────────┬────────────────────────────────────┘    │
│                               ▼                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ scripts/plan_orchestrator.py                                     │    │
│  │ ├── get_next_tasks() - Calls status-cli.js next                  │    │
│  │ ├── _filter_sequential_tasks() - Respects sequential groups      │    │
│  │ ├── _build_constraints_section() - Adds to Claude prompt         │    │
│  │ └── Logs constraint metadata for debugging                       │    │
│  └────────────────────────────┬────────────────────────────────────┘    │
│                               ▼                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ Claude Code Session (via /plan:implement --autonomous)           │    │
│  │ ├── Receives "## Sequential Constraints" in prompt               │    │
│  │ ├── Reads plan file, re-parses [SEQUENTIAL] annotations          │    │
│  │ ├── Detects file conflicts as implicit sequential constraints    │    │
│  │ └── Executes tasks respecting constraints                        │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Detailed Stage Analysis

### Stage 1: Plan File (Source)

**Location:** `docs/plans/*.md`

**Annotation Types:**
- `**Execution Note:** Tasks X.Y-X.Z are [SEQUENTIAL] - reason`
- `**Execution Note:** Phases X-Y are [PARALLEL] - reason`
- `**VERIFY Phase N:** (non-blocking)`
- `(pipeline-start: when X.Y completes)`

**Characteristics:**
- Human-readable markdown format
- Annotations can appear anywhere (typically near phase headers)
- Multiple annotations can exist in same plan
- Reason text provides context for constraints

### Stage 2: Parsing Layer (plan-status.js)

**Location:** `scripts/lib/plan-status.js:1232-1352`

**Function:** `parseExecutionNotes(planContent)`

**Input:** Full plan markdown content
**Output:**
```javascript
{
  sequential: [{ taskRange, taskIds: [], reason }],
  parallel: [{ phaseRange, phaseIds: [], reason }],
  nonBlockingVerify: [{ phase: number }],
  pipelineStart: [{ phase: number, triggerTaskId }]
}
```

**Characteristics:**
- Parses on-demand (not cached in status.json)
- Backward-compatible array-like object (array items = sequential constraints)
- Handles multiple separator types (-, –, —)
- Case-insensitive "are/is" matching

**Helper Functions:**
| Function | Purpose |
|----------|---------|
| `expandTaskRange("3.1-3.4")` | → `["3.1", "3.2", "3.3", "3.4"]` |
| `expandPhaseRange("1-3, 5")` | → `[1, 2, 3, 5]` |

### Stage 3: Status CLI Query Layer

**Location:** `scripts/status-cli.js:700-950` (cmdNext function)

**Query:** `node scripts/status-cli.js next [count]`

**Processing:**
1. Loads plan file fresh
2. Calls `parseExecutionNotes(content)` to get constraints
3. Builds `parallelPhaseSet` from `.parallel` groups
4. For each task, adds metadata flags:

**Task Metadata Added:**
```javascript
{
  id: "3.1",
  description: "...",
  phase: "Phase 3: Documentation",
  phaseNumber: 3,

  // Constraint flags
  sequential: true,              // Task is in a sequential group
  sequentialGroup: "3.1-3.4",    // Which group
  sequentialReason: "file share", // Why sequential
  parallelPhase: true,           // Phase marked [PARALLEL]
  pipelineTriggered: true,       // Task available via pipeline-start

  // Conflict info
  hasFileConflicts: true,
  conflictsWith: ["3.2", "3.3"]
}
```

### Stage 4: Orchestrator Layer

**Location:** `scripts/plan_orchestrator.py`

**Key Methods:**

#### `get_next_tasks(count)` (lines 281-319)
- Calls `node scripts/status-cli.js next {count}`
- Receives enriched task list with constraint metadata
- Logs constraint info for debugging

#### `_filter_sequential_tasks(tasks)` (lines 321-367)
```python
def _filter_sequential_tasks(self, tasks):
    """Filter tasks to respect sequential constraints.

    If multiple tasks share the same sequentialGroup, only include
    the first one (by task ID order). This ensures tasks marked
    [SEQUENTIAL] run one at a time.
    """
    seen_groups = set()
    filtered = []
    held_back = []

    for task in tasks:
        seq_group = task.get("sequentialGroup")
        if seq_group:
            if seq_group in seen_groups:
                held_back.append(task)
                continue
            seen_groups.add(seq_group)
        filtered.append(task)

    # Log held-back tasks
    for task in held_back:
        self.logger.info(f"Task {task.get('id')} held back (sequential)")

    return filtered
```

#### `_build_constraints_section(tasks)` (lines 1017-1043)
Generates prompt section for Claude:
```markdown
## Sequential Constraints

- Tasks 3.1-3.4: [SEQUENTIAL] - all modify same file
```

### Stage 5: Claude Session Layer

**Location:** `.claude/commands/plan/implement.md`

**Constraint Processing:**
1. Receives `## Sequential Constraints` section in prompt
2. Re-parses plan file to find `**Execution Note:**` blocks
3. Detects implicit file conflicts even without annotations
4. Groups tasks for execution:
   - Different phases → Sequential (phase order matters)
   - Same phase + `[SEQUENTIAL]` → One at a time
   - Same phase + file conflicts → One at a time
   - Same phase + independent → Parallel agents

**Execution Preview Generated:**
```
Execution Plan:
├── Sequential Group 1 (Phase 0):
│   └── 0.3 Update playwright.config.ts
├── Parallel Group 2 (Phase 1):
│   ├── 1.1 websocket-connection.test.ts
│   ├── 1.2 preferences-store.test.ts
│   └── 1.3 api-utils.test.ts
├── Sequential Group 3 (Phase 3) [SEQUENTIAL]:
│   ├── 3.1 Merge ORCHESTRATOR.md content
│   ├── 3.2 Merge ARCHITECTURE.md content
│   ├── 3.3 Create redirect file
│   └── 3.4 Remove duplicate section
```

## Data Flow Gaps Identified

### Gap 1: No Persistent Annotation Storage
- Annotations are parsed fresh each time
- status.json stores `sequentialGroups` but only from init
- `refreshConstraints()` must be called to update after plan edits

### Gap 2: Parallel Phase Info Not Cached
- `[PARALLEL]` annotations parsed on every `next` query
- No `parallelGroups` field in status.json
- Could add for TUI performance optimization

### Gap 3: Constraint Violations Not Logged
- When sequential constraint is violated (external execution)
- No audit trail of why tasks were held back
- TUI could show "held back" history

### Gap 4: Implicit vs Explicit Constraints
- File conflict detection is implicit (no annotation)
- `[SEQUENTIAL]` is explicit (annotated)
- TUI could distinguish these visually

## TUI Integration Points

### Data Available at Each Stage

| Stage | Data Available | TUI Opportunity |
|-------|---------------|-----------------|
| Plan File | Raw annotations | Annotation editor |
| plan-status.js | Parsed constraints | Constraint summary panel |
| status-cli.js | Enriched task list | Task badge overlays |
| Orchestrator | Held-back tasks | "Why waiting" panel |
| Claude Session | Execution preview | Live execution view |

### Recommended Hooks for TUI

1. **Post-Parsing Hook:** After `parseExecutionNotes()`, emit event for TUI
2. **Task Filter Event:** When `_filter_sequential_tasks()` holds back tasks
3. **Constraint Section:** Expose `_build_constraints_section()` output
4. **Execution Preview:** Stream execution plan to TUI before starting

## Annotation Persistence in status.json

### Currently Persisted (during init)
```json
{
  "sequentialGroups": [
    { "taskRange": "3.1-3.4", "taskIds": ["3.1", "3.2", "3.3", "3.4"], "reason": "..." }
  ],
  "tasks": [
    {
      "id": "3.1",
      "executionConstraints": {
        "sequential": true,
        "sequentialGroup": "3.1-3.4",
        "reason": "all modify same file"
      }
    }
  ]
}
```

### Not Persisted (parsed on-demand)
- `[PARALLEL]` phase groups
- `(non-blocking)` VERIFY phases
- `pipeline-start` triggers

### Recommendation: Persist All Annotations
Add to status.json during init:
```json
{
  "constraints": {
    "sequential": [...],
    "parallel": [...],
    "nonBlockingVerify": [...],
    "pipelineStart": [...]
  }
}
```

This would improve TUI performance by avoiding repeated plan parsing.
