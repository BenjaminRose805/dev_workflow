# Task 7.2: Analyze Task Selection for Batches

## Analysis Overview

This analysis documents the complete task selection algorithm for batching, examining which tasks are eligible for the same batch and how constraints (phase, dependency, file conflicts) affect selection.

## Task Selection Algorithm

### Primary Selection Flow

The task selection algorithm is implemented in `cmdNext()` (status-cli.js:697-978) and `getReadyTasks()` (plan-status.js:2097-2201):

```
Selection Priority:
1. In-progress tasks (must complete first)
2. Failed tasks (need retry or intervention)
3. Pending tasks (DAG-aware selection)
```

### Step 1: In-Progress Tasks

```javascript
// status-cli.js:762-778
for (const phase of phases) {
  for (const task of phase.tasks) {
    if (task.status === 'in_progress') {
      next.push({
        id: task.id,
        description: task.description,
        phase: phase.number,
        status: task.status,
        reason: 'in_progress - should be completed first',
        dependencies: task.dependencies || [],
        dependents: task.dependents || [],
        ...getConstraintMetadata(task.id)
      });
    }
  }
}
```

**Key Insight**: If any tasks are in_progress, they are returned immediately - blocking new task selection.

### Step 2: Failed Tasks

```javascript
// status-cli.js:821-847
for (const phase of phases) {
  for (const task of phase.tasks) {
    if (task.status === 'failed') {
      next.push({...});
    }
  }
}
```

**Key Insight**: Failed tasks block progress until handled (retry or skip).

### Step 3: DAG-Aware Selection

```javascript
// status-cli.js:849-888
const pipelineStartTriggers = constraints.pipelineStart || [];
const readyTasks = getReadyTasks(status, maxTasks, {
  ignoreDeps,
  phasePriority,
  pipelineStartTriggers
});
```

## getReadyTasks() Algorithm

### Dependency Checking

```javascript
// plan-status.js:2145-2160
if (!ignoreDeps) {
  for (const depId of dependencies) {
    const depStatus = taskStatusMap.get(depId);
    // Dependency is satisfied if completed or skipped
    if (depStatus !== 'completed' && depStatus !== 'skipped') {
      blockedBy.push(depId);
    }
  }
}

const taskInfo = {
  id: task.id,
  isReady: blockedBy.length === 0,
  ...
};

if (blockedBy.length === 0 || ignoreDeps) {
  readyTasks.push(taskInfo);
}
```

### Sorting Logic

```javascript
// plan-status.js:2182-2189
readyTasks.sort((a, b) => {
  if (a.phaseNumber !== b.phaseNumber) {
    return a.phaseNumber - b.phaseNumber;
  }
  // Sort by task ID within the same phase
  return a.id.localeCompare(b.id, undefined, { numeric: true });
});
```

### Phase Priority Mode

```javascript
// plan-status.js:2191-2197
if (phasePriority && readyTasks.length > 0) {
  const earliestPhase = readyTasks[0].phaseNumber;
  const filteredTasks = readyTasks.filter(t => t.phaseNumber === earliestPhase);
  return filteredTasks.slice(0, maxTasks);
}
```

## Batch Eligibility Constraints

### 1. Phase Constraints

| Configuration | Behavior |
|---------------|----------|
| Default (cross-phase enabled) | Tasks from multiple phases can be in same batch |
| `--phase-priority` | Only tasks from earliest incomplete phase |
| `[PARALLEL]` annotation | Explicitly allows cross-phase execution |

### 2. Dependency Constraints

| State | Eligibility |
|-------|-------------|
| No dependencies | Always eligible |
| All deps completed/skipped | Eligible |
| Any dep pending/in_progress/failed | Blocked (unless `--ignore-deps`) |
| Pipeline-start trigger satisfied | Eligible (marked `pipelineTriggered`) |

### 3. File Conflict Detection

```javascript
// status-cli.js:893-927
const conflicts = detectFileConflicts(next);
const conflictMap = new Map();
for (const conflict of conflicts) {
  for (const taskId of conflict.taskIds) {
    conflictMap.get(taskId).conflictsWith.add(otherId);
  }
}

// Add conflict info to output
const tasksWithConflicts = next.map(task => {
  if (conflictMap.has(task.id)) {
    return {
      ...task,
      fileConflict: true,
      conflictsWith: Array.from(conflict.conflictsWith),
      conflictingFiles: conflict.files
    };
  }
  return task;
});
```

### 4. Sequential Constraints

```javascript
// status-cli.js:717-728
function getConstraintMetadata(taskId) {
  for (const constraint of constraints) {
    if (constraint.taskIds.includes(taskId)) {
      return {
        sequential: true,
        sequentialGroup: constraint.taskRange,
        sequentialReason: constraint.reason
      };
    }
  }
  return { sequential: false };
}
```

## Selection Algorithm Output

### Returned Task Object

```typescript
interface SelectedTask {
  id: string;                     // Task ID (e.g., "3.1")
  description: string;            // Task description
  phase: number;                  // Phase number
  status: string;                 // Current status
  reason: string;                 // Why selected
  dependencies: string[];         // Declared dependencies
  dependents: string[];           // Tasks depending on this

  // Constraint metadata
  sequential?: boolean;           // Is in a [SEQUENTIAL] group
  sequentialGroup?: string;       // Range like "3.1-3.4"
  sequentialReason?: string;      // Why sequential

  // File conflict info
  fileConflict?: boolean;         // Has file conflicts
  conflictsWith?: string[];       // Conflicting task IDs
  conflictingFiles?: string[];    // Conflicting file paths

  // Cross-phase info
  parallelPhase?: boolean;        // Is in a [PARALLEL] phase
  pipelineTriggered?: boolean;    // Ready via pipeline trigger
  blockedBy?: string[];           // Unmet dependencies (with --ignore-deps)
}
```

### Complete Output Object

```typescript
interface NextTasksOutput {
  count: number;
  tasks: SelectedTask[];

  // Optional fields
  fileConflicts?: FileConflict[];
  parallelPhases?: {phases: number[], reason: string}[];
  pipelineStartTriggers?: {phase: number, triggerTask: string}[];
  blockedTaskCount?: number;
  ignoreDeps?: boolean;
  phasePriority?: boolean;
  crossPhaseExecution?: boolean;
  activePhases?: number[];
}
```

## Orchestrator Sequential Filtering

The orchestrator applies additional filtering to respect sequential constraints:

```python
# plan_orchestrator.py:321-367
def _filter_sequential_tasks(self, tasks: list) -> list:
    """Filter tasks to respect sequential constraints."""
    seen_groups = set()
    filtered = []
    held_back = []

    for task in tasks:
        seq_group = task.get("sequentialGroup")

        if seq_group:
            if seq_group in seen_groups:
                # Already have a task from this group
                held_back.append(task)
                continue
            # First task from this sequential group
            seen_groups.add(seq_group)

        filtered.append(task)

    return filtered
```

**Key Insight**: Even if `cmdNext()` returns multiple tasks from a sequential group, the orchestrator only executes the first one.

## TUI Visualization Opportunities

### Batch Composition Panel
- Show which tasks are in current batch
- Color-code by phase
- Show constraint icons (ğŸ”„ sequential, âš ï¸ conflict)

### Selection Explainer
- "Why this task?" breakdown
- Show dependency chain status
- Explain why tasks are held back

### Constraint Indicators
| Icon | Meaning |
|------|---------|
| ğŸ”— | Has dependencies (met) |
| ğŸš« | Blocked by dependencies |
| ğŸ”„ | Sequential constraint |
| âš ï¸ | File conflict |
| ğŸŒŠ | Pipeline triggered |

### Batch Size Visualization
```
Current Batch (3/5):
â”œâ”€â”€ 3.1 [Phase 3] ready
â”œâ”€â”€ 4.1 [Phase 4] parallel phase âœ“
â””â”€â”€ 4.2 [Phase 4] parallel phase âœ“

Held Back:
â”œâ”€â”€ 3.2 [Sequential: waiting for 3.1]
â””â”€â”€ 5.1 [Depends: 4.3 pending]
```

## Key Findings

1. **Multi-Stage Selection**: Tasks go through priority checks (in_progress â†’ failed â†’ pending) before batch formation

2. **DAG-Aware by Default**: Dependencies are checked automatically; cross-phase scheduling is enabled

3. **Rich Constraint Metadata**: Selection output includes all constraint info needed for visualization

4. **Orchestrator Filtering**: Second layer of filtering ensures sequential constraints are respected

5. **File Conflicts Informational**: Conflicts are reported but not auto-filtered; orchestrator/TUI can act on them

6. **Pipeline Triggers**: Enable early advancement to later phases based on specific task completion

## Files Analyzed

- `scripts/status-cli.js:697-978` - cmdNext() implementation
- `scripts/lib/plan-status.js:2097-2201` - getReadyTasks() implementation
- `scripts/plan_orchestrator.py:321-367` - Sequential filtering
- `.claude/commands/plan/implement.md` - Agent batching rules
