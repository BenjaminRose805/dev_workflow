# Task 8.1: Review Current Orchestrator Capabilities

## Analysis Overview

This analysis catalogs all features exposed by the plan orchestrator (`scripts/plan_orchestrator.py`) that could be surfaced in the TUI, including batch execution, progress tracking, and stuck detection.

## Orchestrator Architecture

### Core Components

```python
# scripts/plan_orchestrator.py:123-165
class PlanOrchestrator:
    """Orchestrates plan execution across multiple Claude Code sessions."""

    def __init__(self, ...):
        self.plan_path = plan_path
        self.max_iterations = max_iterations      # DEFAULT: 50
        self.timeout = timeout                    # DEFAULT: 600 (10 min)
        self.batch_size = batch_size              # DEFAULT: 5

        # TUI components
        self.tui: Optional[RichTUIManager] = None
        self.status_monitor: Optional[StatusMonitor] = None
        self.streaming_runner: Optional[StreamingClaudeRunner] = None

        # Multi-orchestrator support
        self.registry: Optional[OrchestratorRegistry] = None
        self.instance: Optional[OrchestratorInstance] = None
        self.heartbeat_thread: Optional[HeartbeatThread] = None
        self.ipc_server: Optional[IPCServer] = None
        self._shutdown_requested = False
        self._paused = False
```

## Feature Inventory

### 1. Batch Execution

#### Configuration
```python
DEFAULT_BATCH_SIZE = 5           # Tasks per iteration hint
DEFAULT_MAX_ITERATIONS = 50      # Maximum Claude invocations
DEFAULT_TIMEOUT = 600            # 10 minutes per session
```

#### Task Selection
```python
# plan_orchestrator.py:281-319
def get_next_tasks(self, count: int = 5) -> list:
    """Get next recommended tasks via status-cli.js.

    Returns a list of task objects, each containing:
    - id: Task ID (e.g., "3.1")
    - description: Task description
    - phase: Phase number
    - status: Task status
    - reason: Why this task was selected
    - sequential: True if task is in a sequential group
    - sequentialGroup: Range like "3.1-3.4" if sequential
    - sequentialReason: Reason for sequential constraint
    """
```

#### Sequential Filtering
```python
# plan_orchestrator.py:321-367
def _filter_sequential_tasks(self, tasks: list) -> list:
    """Filter tasks to respect sequential constraints.

    If multiple tasks share the same sequentialGroup, only include
    the first one (by task ID order).
    """
```

### 2. Progress Tracking

#### PlanStatus Class
```python
# plan_orchestrator.py:88-120
class PlanStatus:
    """Represents the current state of a plan."""

    def __init__(self, data: dict):
        self.plan_path = data.get("planPath", "")
        self.plan_name = data.get("planName", "Unknown")
        self.total = data.get("total", 0)
        self.completed = data.get("completed", 0)
        self.in_progress = data.get("inProgress", 0)
        self.pending = data.get("pending", 0)
        self.failed = data.get("failed", 0)
        self.skipped = data.get("skipped", 0)
        self.percentage = data.get("percentage", 0)
        self.current_phase = data.get("currentPhase", "")

    @property
    def is_complete(self) -> bool:
        return self.percentage >= 100 or self.pending == 0

    @property
    def is_blocked(self) -> bool:
        return self.pending == 0 and self.failed > 0
```

#### Status Retrieval
```python
# plan_orchestrator.py:255-280
def get_status(self) -> Optional[PlanStatus]:
    """Get current plan status via node scripts/status-cli.js."""
    result = subprocess.run(
        ["node", STATUS_CLI_JS, "status"],
        capture_output=True,
        text=True,
        timeout=30,
        cwd=self.working_dir,
    )
    data = json.loads(result.stdout)
    return PlanStatus(data)
```

### 3. Stuck Detection

#### Detection Mechanism
```python
# plan_orchestrator.py:421-438
def detect_stuck_tasks(self) -> list:
    """Detect and mark stuck tasks as failed."""
    result = subprocess.run(
        ["node", "scripts/status-cli.js", "detect-stuck"],
        capture_output=True,
        text=True,
        timeout=30,
        cwd=self.working_dir,
    )
    data = json.loads(result.stdout)
    return data.get("stuckTasks", [])
```

#### Stuck Task Handling in Main Loop
```python
# plan_orchestrator.py:854-861
stuck_tasks = self.detect_stuck_tasks()
if stuck_tasks:
    if self.use_tui:
        self.tui.set_status(f"Detected {len(stuck_tasks)} stuck task(s)")
    for task in stuck_tasks:
        self.logger.info(
            f"  Stuck: {task.get('id')} (in_progress for {task.get('elapsedMinutes', '?')} min)"
        )
```

### 4. Retry Management

#### Get Retryable Tasks
```python
# plan_orchestrator.py:369-386
def get_retryable_tasks(self) -> list:
    """Get failed tasks that can be retried (retryCount < 2)."""
```

#### Increment Retry Count
```python
# plan_orchestrator.py:388-404
def increment_retry(self, task_id: str, error: str) -> dict:
    """Increment retry count for a failed task."""
```

#### Reset Task for Retry
```python
# plan_orchestrator.py:406-419
def reset_task_for_retry(self, task_id: str) -> bool:
    """Reset a failed task to pending for retry."""
```

### 5. Worktree Support

#### Path Resolution
```python
# plan_orchestrator.py:192-219
def _resolve_worktree_path(self, explicit_path: Optional[str]) -> Optional[str]:
    """Task 4.1 + 4.2: Resolve worktree path.

    Priority:
    1. Explicitly provided --worktree flag
    2. Auto-detect from current directory (.claude-context/ presence)
    3. CLAUDE_WORKTREE environment variable
    4. None (not in a worktree)
    """
```

#### Environment Propagation
```python
# plan_orchestrator.py:446-462
# Task 4.3 + 4.5: Set working directory and pass worktree context
env = os.environ.copy()
if self.worktree_path:
    env["CLAUDE_WORKTREE"] = self.worktree_path

result = subprocess.run(
    ["claude", "-p", prompt, "--dangerously-skip-permissions"],
    cwd=self.working_dir,
    env=env,
)
```

### 6. Multi-Orchestrator Registry

#### Instance Registration
```python
# plan_orchestrator.py:586-621
def _register_instance(self, plan_path: str):
    """Register this orchestrator instance with the registry.

    Raises:
        DuplicatePlanError: If the plan is already being executed.
    """
    self.registry = OrchestratorRegistry()
    self.registry.cleanup_stale()

    self.instance = OrchestratorInstance.create(
        plan_path=plan_path,
        worktree_path=self.worktree_path,
        socket_path=socket_path,
    )

    self.registry.register(self.instance)

    # Start heartbeat thread
    self.heartbeat_thread = HeartbeatThread(
        self.registry,
        self.instance.id,
    )
    self.heartbeat_thread.start()

    # Start IPC server
    self._start_ipc_server()
```

### 7. IPC Commands

#### Command Handler
```python
# plan_orchestrator.py:650-694
def _handle_ipc_command(self, command: str, payload: Dict) -> Dict:
    """Handle an incoming IPC command."""

    if command == "status":
        return {
            "instance_id": self.instance.id,
            "plan_path": status.plan_path,
            "progress": status.percentage,
            "completed": status.completed,
            "total": status.total,
            "iteration": self.iteration,
            "paused": self._paused,
            "shutdown_requested": self._shutdown_requested,
        }

    elif command == "shutdown":
        self._shutdown_requested = True
        return {"ack": True, "message": "Shutdown initiated"}

    elif command == "pause":
        self._paused = True
        return {"ack": True, "message": "Paused"}

    elif command == "resume":
        self._paused = False
        return {"ack": True, "message": "Resumed"}
```

### 8. Signal Handling

```python
# plan_orchestrator.py:696-708
def _setup_signal_handlers(self):
    """Set up signal handlers for graceful shutdown."""
    def handle_signal(signum, frame):
        sig_name = signal.Signals(signum).name
        self.logger.info(f"Received {sig_name}, initiating graceful shutdown...")
        self._shutdown_requested = True

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)
```

### 9. Daemon Mode

```python
# plan_orchestrator.py:1046-1082
def daemonize():
    """Fork the process to run in the background (Unix only)."""
    # Double fork pattern for proper daemon creation
    # Redirects stdin/stdout/stderr
```

### 10. Management Commands

```python
# Command-line management functions

def cmd_list():          # List all registered orchestrator instances
def cmd_stop():          # Stop a specific orchestrator instance
def cmd_shutdown_all():  # Shutdown all running orchestrator instances
def cmd_status():        # Get status of a specific orchestrator instance
```

## CLI Arguments

| Argument | Default | Description |
|----------|---------|-------------|
| `--plan` | active plan | Path to plan file |
| `--worktree` | auto-detect | Path to worktree directory |
| `--max-iterations` | 50 | Maximum Claude invocations |
| `--batch-size` | 5 | Tasks per iteration hint |
| `--timeout` | 600 | Timeout per session (seconds) |
| `--dry-run` | false | Show what would be done |
| `--verbose` | false | Enable verbose logging |
| `--continue` | false | Skip confirmation prompt |
| `--no-tui` | false | Disable Rich TUI |
| `--daemon` | false | Run in background |
| `--list` | - | List all registered instances |
| `--stop ID` | - | Stop specific instance |
| `--shutdown-all` | - | Shutdown all instances |
| `--status ID` | - | Get instance status |
| `--force` | false | Force shutdown |

## TUI Integration Points

### Current TUI Callbacks

| Callback | Purpose | Data Passed |
|----------|---------|-------------|
| `_on_tool_start` | Tool activity tracking | tool_name, details |
| `_on_tool_end` | Tool completion | tool_id, duration |
| `_on_status_update` | Progress updates | status_data dict |

### TUI Update Methods

```python
# Called by orchestrator to update TUI state

tui.set_status(message)          # Status message
tui.set_progress(completed, total, pending, failed, in_progress)
tui.set_phase(phase)             # Current phase
tui.set_iteration(current, max)  # Iteration counter
tui.add_activity(tool, details)  # Tool started
tui.complete_activity(id, dur)   # Tool completed
tui.set_claude_running(bool)     # Heartbeat indicator
tui.update_tasks(in_progress, completions)  # Task lists
```

## Features Suitable for TUI Expansion

### High Value
| Feature | Current State | TUI Opportunity |
|---------|---------------|-----------------|
| Batch composition | Internal | Batch panel showing tasks |
| Sequential constraints | Filtered internally | Constraint visualization |
| Stuck detection | Log message only | Warning panel with actions |
| Retry management | Automatic | Retry status panel |

### Medium Value
| Feature | Current State | TUI Opportunity |
|---------|---------------|-----------------|
| Multi-orchestrator | CLI only | Instance switcher |
| Pause/resume | IPC only | Control buttons |
| Worktree context | Header display | Enhanced path display |
| Daemon mode | CLI only | Background indicator |

### Lower Priority
| Feature | Current State | TUI Opportunity |
|---------|---------------|-----------------|
| Batch size | CLI flag | Runtime adjustment |
| Timeout | CLI flag | Per-task timeout display |
| Log file | Footer path | Log viewer panel |

## Key Findings

1. **Rich Feature Set**: Orchestrator has many features not fully exposed in TUI

2. **IPC Infrastructure Exists**: Pause/resume/shutdown available via IPC but not TUI

3. **Multi-Orchestrator Support**: Registry system supports multiple instances but no TUI view

4. **Stuck Detection Active**: 30-minute detection runs but UI feedback is minimal

5. **Retry System Automatic**: Retries happen but visibility is limited to status messages

6. **Worktree Fully Supported**: Auto-detection and propagation complete

7. **Daemon Mode Available**: Background execution possible but no TUI for daemon management

## Recommended TUI Expansions

### Phase 1: Enhanced Visibility
- Stuck task warning panel
- Retry status indicator
- Constraint visualization

### Phase 2: Control Integration
- Pause/resume buttons
- Skip task action
- Retry trigger

### Phase 3: Multi-Instance
- Instance list view
- Instance switcher
- Cross-instance progress

## Files Analyzed

- `scripts/plan_orchestrator.py` - Complete file (1387 lines)
- `scripts/lib/tui.py` - TUI manager
- `scripts/lib/orchestrator_registry.py` - Registry system
- `scripts/lib/orchestrator_ipc.py` - IPC infrastructure
