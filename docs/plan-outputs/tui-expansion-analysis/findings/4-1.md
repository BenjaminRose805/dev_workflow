# Task 4.1: Current Phase-Based Ordering Analysis

## Summary

The current task scheduling system combines phase-based ordering with DAG-based dependency resolution. There is **no explicit phase completion threshold** (the 80% mentioned in the plan was speculative). Instead, the system uses phase number as a **sort key** for tasks with equal readiness status, while allowing cross-phase parallelism by default.

## Key Finding: No Completion Threshold

**Correction:** The plan mentioned "Phase completion threshold (80% default)" but no such threshold exists in the implementation. The system behavior is:

| Assumed | Actual |
|---------|--------|
| Wait for 80% of phase to complete | No threshold - DAG-based |
| Phase gates task execution | Phase is sort key only |
| Strict phase ordering | Cross-phase by default |

## Phase Ordering Implementation

### Location

**Primary:** `getReadyTasks()` in `scripts/lib/plan-status.js:2097-2201`

**Secondary:** `cmdNext()` in `scripts/status-cli.js:697-978`

### Sorting Algorithm

```javascript
// From plan-status.js:2182-2189
readyTasks.sort((a, b) => {
  if (a.phaseNumber !== b.phaseNumber) {
    return a.phaseNumber - b.phaseNumber;  // Earlier phases first
  }
  // Sort by task ID within the same phase
  return a.id.localeCompare(b.id, undefined, { numeric: true });
});
```

**Sort Priority:**
1. **Phase number** (ascending) - Earlier phases come first
2. **Task ID** (numeric) - Within same phase, lower IDs first

### Phase Extraction

```javascript
// From plan-status.js:2137-2139
const phaseMatch = task.phase ? task.phase.match(/Phase\s+(\d+)/) : null;
const phaseNumber = phaseMatch ? parseInt(phaseMatch[1]) : 0;
```

**Pattern:** Extracts number from "Phase N: Title" format

**Default:** `0` for tasks without valid phase number

## Task Selection Algorithm

### Overview

```
┌─────────────────────────────────────────────────────────────┐
│                     getReadyTasks()                          │
├─────────────────────────────────────────────────────────────┤
│ 1. Build task status map                                     │
│ 2. For each pending task:                                    │
│    ├── Check explicit dependencies                          │
│    ├── Check pipeline-start triggers                        │
│    └── Mark as ready if no blockers                         │
│ 3. Sort ready tasks by (phase, taskId)                      │
│ 4. Apply phasePriority filter if enabled                    │
│ 5. Return top N tasks                                       │
└─────────────────────────────────────────────────────────────┘
```

### Readiness Criteria

A task is "ready" when:

| Criterion | Implementation |
|-----------|----------------|
| Status is `pending` | `task.status !== 'pending' → skip` |
| Dependencies satisfied | All deps are `completed` or `skipped` |
| OR `ignoreDeps` flag | Bypass dependency check |

### Phase Does NOT Block

**Key behavior:** Phase number does NOT block execution. If task 3.1 has no dependencies and task 1.5 has pending dependencies, task 3.1 will be selected first (after sorting by phase).

```
Example:
Task 1.5 - Phase 1 - blocked by 1.3 (pending)
Task 3.1 - Phase 3 - no dependencies (ready)

Result: Task 3.1 is selected despite being in later phase
```

## Phase Priority Mode

### Flag: `--phase-priority`

**Location:** `scripts/status-cli.js:700`, `plan-status.js:2191-2197`

**Behavior:** Only return tasks from the earliest phase with ready tasks

```javascript
// From plan-status.js:2191-2197
if (phasePriority && readyTasks.length > 0) {
  const earliestPhase = readyTasks[0].phaseNumber;
  const filteredTasks = readyTasks.filter(t => t.phaseNumber === earliestPhase);
  return filteredTasks.slice(0, maxTasks);
}
```

### Comparison

| Mode | Behavior |
|------|----------|
| Default | Return ready tasks from any phase, sorted by phase |
| `--phase-priority` | Only return tasks from earliest phase with ready tasks |

### Example

**Ready tasks:** `[1.3, 2.1, 2.2, 3.1]` (all ready, various phases)

| Mode | Output |
|------|--------|
| Default (`next 3`) | `[1.3, 2.1, 2.2]` (sorted by phase) |
| `--phase-priority` (`next 3`) | `[1.3]` (only Phase 1) |

## Cross-Phase Execution

### Default Behavior

Cross-phase execution is **enabled by default**:

```javascript
// Comment from plan-status.js:2051-2055
* This function enables cross-phase scheduling by default. Tasks are considered
* ready based solely on their dependencies, NOT their phase. This means:
* - If task 3.1 depends only on 1.1, it can start as soon as 1.1 completes
* - Tasks don't wait for entire earlier phases to complete
* - Multiple phases can have tasks executing in parallel
```

### Detection in Output

```json
{
  "crossPhaseExecution": true,
  "activePhases": [1, 2, 3]
}
```

**Logic:** (from status-cli.js:970-975)
```javascript
const phaseNumbers = new Set(tasksWithConflicts.map(t => t.phase));
if (phaseNumbers.size > 1) {
  output.crossPhaseExecution = true;
  output.activePhases = Array.from(phaseNumbers).sort((a, b) => a - b);
}
```

## Pipeline-Start Triggers

### Purpose

Allow a phase to start when a specific task completes, rather than waiting for the entire previous phase.

### Syntax

```markdown
## Phase 2: API Layer (pipeline-start: when 1.3 completes)
```

### Implementation

```javascript
// From plan-status.js:2110-2122
const pipelineTriggerMap = new Map();
for (const trigger of pipelineStartTriggers) {
  pipelineTriggerMap.set(trigger.phase, trigger.triggerTaskId);
}

const isPipelineTriggered = (phaseNumber) => {
  const triggerTaskId = pipelineTriggerMap.get(phaseNumber);
  if (!triggerTaskId) return false;
  const triggerStatus = taskStatusMap.get(triggerTaskId);
  return triggerStatus === 'completed' || triggerStatus === 'skipped';
};
```

### Output Annotation

Tasks ready via pipeline-start are marked:
```json
{
  "id": "2.1",
  "pipelineTriggered": true,
  "reason": "pending - ready via pipeline-start trigger"
}
```

## Phases Command Output

The `phases` command shows completion status per phase:

```bash
node scripts/status-cli.js phases
```

**Output:**
```json
{
  "phases": [
    {
      "number": 0,
      "title": "Phase 0: Setup",
      "total": 3,
      "completed": 3,
      "in_progress": 0,
      "pending": 0,
      "failed": 0,
      "skipped": 0,
      "percentage": 100,
      "status": "completed"
    },
    {
      "number": 1,
      "title": "Phase 1: Implementation",
      "total": 5,
      "completed": 2,
      "in_progress": 1,
      "pending": 2,
      "failed": 0,
      "skipped": 0,
      "percentage": 40,
      "status": "in_progress"
    }
  ]
}
```

### Phase Status Logic

```javascript
// From status-cli.js:1458-1462
if (phase.completed === phase.total && phase.total > 0) {
  phaseStatus = 'completed';
} else if (phase.completed > 0 || phase.in_progress > 0) {
  phaseStatus = 'in_progress';
}
// else: 'pending' (default)
```

## TUI Implications

### Current Phase Display

The TUI shows `currentPhase` from status.json:
```python
# From tui.py:179
self.current_phase = ""
```

This is the first phase with incomplete tasks, NOT the phase currently being worked on.

### Recommended Enhancements

| Enhancement | Data Source | TUI Location |
|-------------|-------------|--------------|
| Active phases list | `activePhases[]` | Header or progress |
| Cross-phase indicator | `crossPhaseExecution` | Progress panel |
| Phase completion bars | `phases` command | New panel |
| Pipeline triggers | `pipelineStartTriggers[]` | Detail panel |

### Proposed Phase Progress Panel

```
┌────────────────────────────────────────┐
│ PHASE PROGRESS                         │
├────────────────────────────────────────┤
│ Phase 0: Setup        [████████████] ✓ │
│ Phase 1: Core         [████████░░░░] 67%│
│ Phase 2: API          [████░░░░░░░░] 33%│
│ Phase 3: Tests        [░░░░░░░░░░░░] 0% │
│                                        │
│ Active: Phases 1, 2 (cross-phase)     │
└────────────────────────────────────────┘
```

## Summary Table

| Aspect | Behavior |
|--------|----------|
| Phase ordering | Sort key only, not a gate |
| Completion threshold | None (contrary to plan assumption) |
| Cross-phase execution | Enabled by default |
| Strict phase mode | `--phase-priority` flag |
| Pipeline triggers | Allow early phase start |
| Dependencies | DAG-based, phase-independent |
| Phase status | Derived from task statuses |

## Recommendations

### For Orchestrator

1. **Use default mode** for maximum parallelism
2. **Use `--phase-priority`** when strict ordering is required
3. **Check `crossPhaseExecution`** to know when multi-phase work is active

### For TUI

1. **Show active phases** when `crossPhaseExecution: true`
2. **Display phase completion bars** from `phases` output
3. **Highlight pipeline triggers** to explain early phase starts
4. **Don't assume sequential phases** - show actual execution state
