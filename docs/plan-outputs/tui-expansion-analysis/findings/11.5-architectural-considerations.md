# Task 11.5: Architectural Considerations for TUI Expansion

**Date:** 2025-12-26
**Purpose:** Document critical architectural considerations for TUI expansion implementation
**Scope:** Performance, data refresh, terminal constraints, event streaming

---

## Executive Summary

This document outlines the key architectural considerations for expanding the TUI with orchestrator visualization, parallel execution monitoring, and real-time event streaming. These considerations must guide implementation decisions to ensure the expanded TUI maintains sub-100ms responsiveness while providing rich real-time feedback.

**Key Concerns:**
1. Performance impact of new panels
2. Data refresh strategies for parallel state
3. Terminal size constraints
4. Real-time event streaming architecture

---

## 1. Performance Impact of New Panels

### 1.1 Current Performance Profile

The existing TUI (`scripts/lib/tui.py`) has these characteristics:

| Metric | Current Value | Target |
|--------|---------------|--------|
| Refresh rate | 500ms | 500ms (maintain) |
| Render time | <50ms | <100ms |
| Memory usage | ~20MB | <50MB |
| Data sources | 1 (status.json) | 5+ (multiple) |

### 1.2 New Panel Performance Concerns

#### High-Frequency Panels (Update every refresh cycle)

| Panel | Data Source | Parse Time | Risk |
|-------|-------------|------------|------|
| Parallel Dashboard | status.json + cmdNext() | ~30ms | MEDIUM |
| Task Constraint Panel | cmdNext() | ~20ms | LOW |
| Batch Execution Panel | status.json | ~10ms | LOW |
| Event Stream | EventBus (memory) | <5ms | LOW |

**Concern:** Parallel Dashboard requires calling `cmdNext()` which spawns a subprocess.

**Mitigation:**
```python
class ParallelExecutionDashboard:
    def __init__(self):
        self.last_refresh: float = 0
        self.cache_duration: float = 1.0  # seconds
        self.cached_data: Optional[Dict] = None

    def refresh(self, force: bool = False) -> None:
        now = time.time()
        if not force and self.cached_data:
            if now - self.last_refresh < self.cache_duration:
                return  # Use cached data

        self._fetch_fresh_data()
        self.last_refresh = now
```

#### On-Demand Panels (Update when toggled/focused)

| Panel | Data Source | Parse Time | Risk |
|-------|-------------|------------|------|
| Git Status Panel | git commands | ~50ms | MEDIUM |
| Orchestrator Control | IPC query | ~100ms | HIGH |
| Multi-Plan View | Multiple status.json | ~100ms | HIGH |

**Mitigation:**
- Lazy load: Only fetch data when panel is expanded
- Background refresh: Refresh in separate thread, update on next cycle
- Stale indicator: Show "updating..." if data older than 2s

### 1.3 Render Budget Allocation

With multiple panels, we must budget render time:

```
Total Budget: 100ms per cycle
─────────────────────────────────────
Core TUI (existing):       30ms
├─ Progress bar:           5ms
├─ In-progress panel:      10ms
├─ Activity panel:         10ms
└─ Footer:                 5ms

New Panels:                40ms
├─ Parallel Dashboard:     15ms
├─ Task Constraint:        10ms
├─ Batch Panel:            10ms
└─ Event Stream:           5ms

Buffer:                    30ms
└─ Handle spikes, GC, etc.
```

### 1.4 Recommendations

1. **Lazy Initialization:** Don't instantiate panels until first toggle
2. **Differential Rendering:** Only re-render changed sections
3. **Subprocess Pooling:** Reuse node processes for cmdNext() calls
4. **Profiling:** Add timing instrumentation to detect bottlenecks

```python
# Example: Differential rendering
class RichTUIManager:
    def __init__(self):
        self._render_cache: Dict[str, str] = {}

    def _render_panel(self, name: str, panel: Panel) -> Panel:
        rendered = str(panel)
        if self._render_cache.get(name) == rendered:
            return self._render_cache[name]  # Return cached
        self._render_cache[name] = rendered
        return panel
```

---

## 2. Data Refresh Strategies for Parallel State

### 2.1 The Challenge

Parallel execution creates rapidly changing state:
- Multiple tasks running simultaneously
- Commit queue changing constantly
- Agent spawn/complete events occurring frequently
- File conflicts detected/resolved dynamically

### 2.2 Refresh Strategy Matrix

| Data Type | Strategy | Interval | Rationale |
|-----------|----------|----------|-----------|
| Task status | Polling | 500ms | Core data, always current |
| Active agents | Polling | 500ms | Part of task status |
| Commit queue | Event + Poll | 1s | Changes with each commit |
| File conflicts | On-demand | Per cmdNext() | Only changes on task start |
| Sequential constraints | Startup | Once | Parsed from plan file |
| IPC status | Event-driven | On change | Orchestrator pushes updates |

### 2.3 Hybrid Refresh Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                       TUI Main Loop                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │ Polling │  │ Events  │  │ On-Dem. │  │ Cached  │         │
│  │ Thread  │  │ Handler │  │ Fetcher │  │ Data    │         │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘         │
│       │            │            │            │               │
│       ▼            ▼            ▼            ▼               │
│  ┌─────────────────────────────────────────────────┐        │
│  │              Unified State Store                 │        │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐         │        │
│  │  │ Tasks   │  │ Events  │  │ Config  │         │        │
│  │  └─────────┘  └─────────┘  └─────────┘         │        │
│  └─────────────────────────────────────────────────┘        │
│       │                                                      │
│       ▼                                                      │
│  ┌─────────────────────────────────────────────────┐        │
│  │              Render Cycle (500ms)                │        │
│  └─────────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 2.4 Polling Thread Implementation

```python
class StatePoller:
    """Background thread for polling data sources."""

    def __init__(self, interval: float = 0.5):
        self.interval = interval
        self.running = False
        self.state_lock = threading.Lock()
        self.current_state: Dict = {}

    def start(self):
        self.running = True
        self.thread = threading.Thread(target=self._poll_loop, daemon=True)
        self.thread.start()

    def _poll_loop(self):
        while self.running:
            try:
                new_state = self._fetch_state()
                with self.state_lock:
                    self.current_state = new_state
            except Exception as e:
                # Log but don't crash
                pass
            time.sleep(self.interval)

    def get_state(self) -> Dict:
        with self.state_lock:
            return self.current_state.copy()
```

### 2.5 Stale Data Handling

Show clear indicators when data is stale:

```python
def render_with_staleness(panel: Panel, last_update: float) -> Panel:
    age = time.time() - last_update
    if age > 2.0:
        # Add visual indicator
        panel.border_style = "dim yellow"
        panel.title = f"{panel.title} (updating...)"
    elif age > 5.0:
        panel.border_style = "dim red"
        panel.title = f"{panel.title} (stale)"
    return panel
```

---

## 3. Terminal Size Constraints

### 3.1 Minimum Supported Sizes

| Terminal Size | Classification | Panel Layout |
|---------------|----------------|--------------|
| 80x24 | Minimum | Compact: 2 panels max |
| 120x40 | Standard | Normal: 4 panels |
| 160x50+ | Large | Full: All panels |

### 3.2 Panel Priority for Space Allocation

When space is limited, prioritize:

| Priority | Panel | Reason |
|----------|-------|--------|
| P0 | Progress bar | Always visible |
| P1 | In-progress tasks | Core functionality |
| P2 | Activity feed | See what's happening |
| P3 | Parallel Dashboard (collapsed) | Key parallel info |
| P4 | Task Constraints | Understand blockers |
| P5 | Batch Panel | Execution context |
| P6 | Event Stream | Nice to have |
| P7 | Git Status | Secondary info |

### 3.3 Responsive Layout Algorithm

```python
def calculate_layout(terminal_height: int, terminal_width: int) -> Layout:
    """Calculate panel layout based on terminal size."""

    # Reserve space for chrome
    available_height = terminal_height - 4  # header + footer
    available_width = terminal_width

    if available_height < 20:
        # Ultra-compact: Only essentials
        return Layout().split(
            Layout(name="progress", size=3),
            Layout(name="main", ratio=1)
        )

    elif available_height < 35:
        # Compact: Two main sections
        return Layout().split(
            Layout(name="header", size=5),
            Layout(name="main", ratio=1),
            Layout(name="footer", size=2)
        )

    else:
        # Standard: Full layout
        layout = Layout()
        layout.split(
            Layout(name="header", size=5),
            Layout(name="parallel", size=3 if collapsed else 15),
            Layout(name="main", ratio=1),
            Layout(name="events", size=10),
            Layout(name="footer", size=2)
        )
        return layout
```

### 3.4 Collapsed vs Expanded Panel States

Every new panel should have two states:

| Panel | Collapsed Size | Expanded Size | Toggle Key |
|-------|----------------|---------------|------------|
| Parallel Dashboard | 1 row | 15 rows | `p` |
| Task Constraints | 1 row | 10 rows | `c` |
| Batch Execution | 1 row | 8 rows | `b` |
| Git Status | 1 row | 8 rows | `g` |
| Orchestrator Control | 1 row | 20 rows | `Ctrl+O` |
| Event Stream | 1 row | 12 rows | `Ctrl+E` |

### 3.5 Overflow Handling

```python
class OverflowHandler:
    """Handle text overflow in constrained spaces."""

    @staticmethod
    def truncate_with_ellipsis(text: str, max_width: int) -> str:
        if len(text) <= max_width:
            return text
        return text[:max_width - 3] + "..."

    @staticmethod
    def smart_truncate(text: str, max_width: int, preserve_end: int = 8) -> str:
        """Truncate middle, preserving start and end."""
        if len(text) <= max_width:
            return text
        start_len = max_width - preserve_end - 3
        return f"{text[:start_len]}...{text[-preserve_end:]}"
```

---

## 4. Real-time Event Streaming Architecture

### 4.1 Event Sources

Events must be captured from multiple sources:

```
┌─────────────────────────────────────────────────────────────┐
│                    Event Sources                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐ │
│  │ plan_orches-   │  │ claude_runner  │  │ status-cli.js  │ │
│  │ trator.py      │  │ .py            │  │ (via watcher)  │ │
│  └───────┬────────┘  └───────┬────────┘  └───────┬────────┘ │
│          │                   │                   │           │
│          ▼                   ▼                   ▼           │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    EventBus                              ││
│  │  emit() ──────────────────────────────► subscribers[]   ││
│  └─────────────────────────────────────────────────────────┘│
│                              │                               │
│                              ▼                               │
│  ┌─────────────────────────────────────────────────────────┐│
│  │              EventStreamPanel (TUI)                      ││
│  └─────────────────────────────────────────────────────────┘│
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 Event Bus Design Considerations

#### Thread Safety

```python
class EventBus:
    def __init__(self, max_history: int = 1000):
        self.history: List[Event] = []
        self.subscribers: Dict[str, List[Callable]] = {}
        self.lock = threading.RLock()  # Reentrant for nested calls

    def emit(self, event: Event) -> None:
        with self.lock:
            self.history.append(event)
            if len(self.history) > self.max_history:
                self.history.pop(0)

            # Copy subscribers to avoid lock during callbacks
            callbacks = list(self._get_subscribers(event.type))

        # Notify outside lock
        for callback in callbacks:
            try:
                callback(event)
            except Exception:
                pass  # Don't let bad subscribers break bus
```

#### Memory Management

With high event volume, memory management is critical:

```python
# Use circular buffer for history
from collections import deque

class EventBus:
    def __init__(self, max_history: int = 1000):
        self.history = deque(maxlen=max_history)  # Auto-evicts old
```

#### Event Throttling

For high-frequency events (e.g., tool calls), throttle to prevent TUI overload:

```python
class ThrottledEventEmitter:
    def __init__(self, event_bus: EventBus, min_interval: float = 0.1):
        self.bus = event_bus
        self.min_interval = min_interval
        self.last_emit: Dict[str, float] = {}

    def emit(self, event_type: str, data: Dict) -> bool:
        now = time.time()
        last = self.last_emit.get(event_type, 0)

        if now - last < self.min_interval:
            return False  # Throttled

        self.bus.emit(Event(type=event_type, data=data))
        self.last_emit[event_type] = now
        return True
```

### 4.3 Event Persistence Strategy

Events should persist across TUI restarts for debugging:

```python
class EventPersistence:
    def __init__(self, path: str):
        self.path = path
        self.max_lines = 10000

    def append(self, event: Event) -> None:
        with open(self.path, 'a') as f:
            f.write(event.to_json() + '\n')
        self._rotate_if_needed()

    def load_recent(self, count: int = 100) -> List[Event]:
        if not os.path.exists(self.path):
            return []
        with open(self.path, 'r') as f:
            lines = f.readlines()[-count:]
        return [Event.from_json(line) for line in lines]
```

### 4.4 IPC Event Delivery

For events from orchestrator (running in separate process):

```
┌─────────────────────┐           ┌─────────────────────┐
│    Orchestrator     │           │        TUI          │
│  (plan_orches-      │           │                     │
│   trator.py)        │           │                     │
├─────────────────────┤           ├─────────────────────┤
│                     │           │                     │
│  emit_event() ──────┼──────────►│ receive_event()    │
│                     │  IPC File │                     │
│                     │  or Named │                     │
│                     │  Pipe     │                     │
│                     │           │                     │
└─────────────────────┘           └─────────────────────┘
```

**Recommended: File-based IPC for simplicity**

```python
# Orchestrator side
class EventWriter:
    def __init__(self, event_file: str):
        self.event_file = event_file

    def emit(self, event: Event):
        with open(self.event_file, 'a') as f:
            f.write(event.to_json() + '\n')

# TUI side
class EventReader:
    def __init__(self, event_file: str):
        self.event_file = event_file
        self.last_position = 0

    def read_new(self) -> List[Event]:
        if not os.path.exists(self.event_file):
            return []
        with open(self.event_file, 'r') as f:
            f.seek(self.last_position)
            new_lines = f.readlines()
            self.last_position = f.tell()
        return [Event.from_json(line) for line in new_lines]
```

---

## 5. Integration Risks and Mitigations

### 5.1 Risk Matrix

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Subprocess spawning overhead | HIGH | MEDIUM | Cache cmdNext() results, use pooling |
| Event volume overwhelming TUI | MEDIUM | HIGH | Throttle events, filter by type |
| Terminal compatibility issues | MEDIUM | MEDIUM | Test on Linux, Mac, WSL early |
| IPC deadlocks | LOW | HIGH | Timeouts on all IPC operations |
| Memory growth from event history | MEDIUM | MEDIUM | Circular buffers, max sizes |
| Keyboard shortcut conflicts | MEDIUM | LOW | Document mappings, make configurable |

### 5.2 Graceful Degradation

When problems occur, degrade gracefully:

```python
class TUIFallback:
    """Fallback modes when features fail."""

    @staticmethod
    def on_ipc_failure():
        # Disable orchestrator control, show read-only status
        return "read_only_mode"

    @staticmethod
    def on_event_bus_failure():
        # Disable event stream, continue with polling
        return "polling_only"

    @staticmethod
    def on_render_timeout():
        # Switch to minimal layout
        return "compact_mode"
```

### 5.3 Feature Flags

Allow features to be disabled if problematic:

```python
TUI_FEATURES = {
    'parallel_dashboard': True,
    'event_stream': True,
    'orchestrator_control': True,
    'multi_plan': True,
    'real_time_events': True,
}

def is_feature_enabled(feature: str) -> bool:
    return TUI_FEATURES.get(feature, False)
```

---

## 6. Implementation Order Considerations

### 6.1 Dependency Graph

```
                    ┌─────────────────┐
                    │ Phase 1: Core   │
                    │ Quick Wins      │
                    └────────┬────────┘
                             │
           ┌─────────────────┼─────────────────┐
           ▼                 ▼                 ▼
    ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
    │ Task         │  │ Batch        │  │ Git Status   │
    │ Constraint   │  │ Execution    │  │ Panel        │
    │ Panel        │  │ Panel        │  │              │
    └──────────────┘  └──────────────┘  └──────────────┘
           │                 │
           └────────┬────────┘
                    ▼
           ┌──────────────────┐
           │ IPC Infrastructure│
           └────────┬─────────┘
                    │
           ┌────────┴────────┐
           ▼                 ▼
    ┌──────────────┐  ┌──────────────┐
    │ Orchestrator │  │ Event Bus    │
    │ Control Panel│  │ Infrastructure│
    └──────────────┘  └──────┬───────┘
                             │
                             ▼
                    ┌──────────────┐
                    │ Event Stream │
                    │ Panel        │
                    └──────────────┘
                             │
                             ▼
           ┌─────────────────┴─────────────────┐
           ▼                                   ▼
    ┌──────────────┐                    ┌──────────────┐
    │ Parallel     │                    │ Multi-Plan   │
    │ Dashboard    │                    │ View         │
    └──────────────┘                    └──────────────┘
```

### 6.2 Critical Path

1. **Quick Wins** - No dependencies, high value, low risk
2. **Core Panels** - Build on existing TUI patterns
3. **IPC Infrastructure** - Required for control features
4. **Event Infrastructure** - Required for streaming
5. **Advanced Panels** - Depend on IPC + Events

---

## 7. Success Metrics

### 7.1 Performance Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Render cycle time | <100ms | Time from data fetch to display |
| Keyboard response | <50ms | Time from keypress to visual feedback |
| Memory usage | <50MB | After 1 hour of operation |
| Event latency | <200ms | Time from event to display |
| IPC round-trip | <100ms | Command → Response time |

### 7.2 Usability Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Panel toggle time | <50ms | Expand/collapse response |
| Data staleness | <2s | Max age before indicator |
| Scroll smoothness | 60fps | No visible lag during scroll |
| Terminal resize | <100ms | Re-layout after resize |

---

## 8. Conclusion

The TUI expansion introduces significant architectural complexity, particularly around:

1. **Performance:** Multiple data sources, careful caching, render budgets
2. **Data Refresh:** Hybrid polling + events, stale data handling
3. **Terminal Constraints:** Responsive layouts, collapse/expand states
4. **Event Streaming:** Thread-safe bus, throttling, persistence

Following the patterns and mitigations documented here will ensure the expanded TUI maintains the responsiveness and reliability users expect while providing powerful new visibility into orchestrator operation.

---

**End of Architectural Considerations**
