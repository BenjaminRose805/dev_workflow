# WebSocket Message Format Specification

## Overview

This document defines the WebSocket message format for real-time plan status updates between the API server (`scripts/api-server.js`) and frontend clients.

## Connection Endpoints

| Endpoint | Description |
|----------|-------------|
| `ws://host:port/ws/plans/:name` | Subscribe to updates for a specific plan |
| `ws://host:port/ws/all` | Subscribe to aggregate updates for all plans |

## Message Format

All WebSocket messages use JSON format with a `type` field to identify the message type.

### Base Message Structure

```typescript
interface WebSocketMessage {
  type: string;           // Message type identifier
  timestamp: string;      // ISO 8601 timestamp
  [key: string]: unknown; // Type-specific fields
}
```

## Client-to-Server Messages

### Subscribe to Plan

```json
{
  "type": "subscribe",
  "plan": "git-workflow-phase5-worktrees",
  "timestamp": "2024-12-26T17:00:00.000Z"
}
```

### Unsubscribe from Plan

```json
{
  "type": "unsubscribe",
  "plan": "git-workflow-phase5-worktrees",
  "timestamp": "2024-12-26T17:00:00.000Z"
}
```

### Ping (Keep-alive)

```json
{
  "type": "ping",
  "timestamp": "2024-12-26T17:00:00.000Z"
}
```

## Server-to-Client Messages

### 1. Status Update (Single Plan)

Sent when a plan's status.json changes.

```json
{
  "type": "status",
  "plan": "git-workflow-phase5-worktrees",
  "status": "in_progress",
  "progress": {
    "total": 84,
    "completed": 71,
    "pending": 13,
    "in_progress": 0,
    "failed": 0,
    "percentage": 85
  },
  "currentTask": {
    "id": "12.1",
    "description": "Document frontend requirements and architecture",
    "startedAt": "2024-12-26T17:00:00.000Z"
  },
  "lastUpdatedAt": "2024-12-26T17:05:00.000Z",
  "timestamp": "2024-12-26T17:05:01.000Z"
}
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Always "status" |
| `plan` | string | Plan name (without .md) |
| `status` | string | "pending" \| "in_progress" \| "completed" |
| `progress.total` | number | Total number of tasks |
| `progress.completed` | number | Completed tasks |
| `progress.pending` | number | Pending tasks |
| `progress.in_progress` | number | Currently running tasks |
| `progress.failed` | number | Failed tasks |
| `progress.percentage` | number | Completion percentage (0-100) |
| `currentTask` | object \| null | Currently running task |
| `lastUpdatedAt` | string | Last status.json update time |
| `timestamp` | string | Message generation time |

### 2. All Plans Update (Aggregate)

Sent to `/ws/all` subscribers when any plan changes.

```json
{
  "type": "all-plans",
  "plans": [
    {
      "name": "git-workflow-phase5-worktrees",
      "status": "in_progress",
      "progress": {
        "total": 84,
        "completed": 71,
        "percentage": 85
      }
    },
    {
      "name": "another-plan",
      "status": "pending",
      "progress": {
        "total": 20,
        "completed": 0,
        "percentage": 0
      }
    }
  ],
  "aggregate": {
    "totalPlans": 2,
    "totalTasks": 104,
    "completed": 71,
    "pending": 33,
    "in_progress": 0,
    "failed": 0,
    "percentage": 68
  },
  "timestamp": "2024-12-26T17:05:01.000Z"
}
```

### 3. Task Update

Sent when a specific task status changes.

```json
{
  "type": "task_update",
  "plan": "git-workflow-phase5-worktrees",
  "task": {
    "id": "12.1",
    "phase": "Phase 12: NextJS Frontend Preparation",
    "description": "Document frontend requirements and architecture",
    "previousStatus": "pending",
    "status": "in_progress",
    "startedAt": "2024-12-26T17:00:00.000Z"
  },
  "timestamp": "2024-12-26T17:00:01.000Z"
}
```

**Task Status Transitions:**

```
pending -> in_progress -> completed
                      \-> failed
pending -> skipped
```

### 4. Orchestrator Update

Sent when orchestrator status changes.

```json
{
  "type": "orchestrator_update",
  "plan": "git-workflow-phase5-worktrees",
  "orchestrator": {
    "running": true,
    "pid": 12345,
    "mode": "batch",
    "startedAt": "2024-12-26T17:00:00.000Z",
    "currentTask": "12.1"
  },
  "timestamp": "2024-12-26T17:00:01.000Z"
}
```

**Orchestrator Stopped:**

```json
{
  "type": "orchestrator_update",
  "plan": "git-workflow-phase5-worktrees",
  "orchestrator": {
    "running": false,
    "pid": null,
    "stoppedAt": "2024-12-26T18:00:00.000Z",
    "reason": "completed"
  },
  "timestamp": "2024-12-26T18:00:01.000Z"
}
```

### 5. Log Entry

Sent when following orchestrator logs.

```json
{
  "type": "log",
  "plan": "git-workflow-phase5-worktrees",
  "log": {
    "level": "info",
    "message": "Task 12.1 completed successfully",
    "taskId": "12.1",
    "logTimestamp": "2024-12-26T17:05:00.000Z"
  },
  "timestamp": "2024-12-26T17:05:01.000Z"
}
```

**Log Levels:**

| Level | Description |
|-------|-------------|
| `debug` | Detailed debugging information |
| `info` | General information |
| `warn` | Warning conditions |
| `error` | Error conditions |

### 6. Progress Update (Lightweight)

Minimal update for progress bar animations.

```json
{
  "type": "progress_update",
  "plan": "git-workflow-phase5-worktrees",
  "completed": 72,
  "total": 84,
  "percentage": 86,
  "timestamp": "2024-12-26T17:05:01.000Z"
}
```

### 7. Error Message

Sent when an error occurs.

```json
{
  "type": "error",
  "error": "Plan not found: nonexistent-plan",
  "code": "PLAN_NOT_FOUND",
  "details": {},
  "timestamp": "2024-12-26T17:00:01.000Z"
}
```

**Error Codes:**

| Code | Description |
|------|-------------|
| `PLAN_NOT_FOUND` | Requested plan does not exist |
| `CONNECTION_ERROR` | Failed to establish connection |
| `SUBSCRIPTION_FAILED` | Failed to subscribe to updates |
| `INTERNAL_ERROR` | Server-side error |

### 8. Heartbeat

Keep-alive message sent every 30 seconds.

```json
{
  "type": "heartbeat",
  "timestamp": "2024-12-26T17:00:30.000Z"
}
```

### 9. Pong (Response to Ping)

```json
{
  "type": "pong",
  "timestamp": "2024-12-26T17:00:00.000Z"
}
```

## TypeScript Type Definitions

```typescript
// Base types
type PlanStatus = 'pending' | 'in_progress' | 'completed';
type TaskStatus = 'pending' | 'in_progress' | 'completed' | 'failed' | 'skipped';
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

// Progress information
interface Progress {
  total: number;
  completed: number;
  pending?: number;
  in_progress?: number;
  failed?: number;
  percentage: number;
}

// Task information
interface TaskInfo {
  id: string;
  phase?: string;
  description: string;
  status?: TaskStatus;
  previousStatus?: TaskStatus;
  startedAt?: string;
  completedAt?: string;
  failedAt?: string;
}

// Orchestrator information
interface OrchestratorInfo {
  running: boolean;
  pid: number | null;
  mode?: 'batch' | 'continuous';
  startedAt?: string;
  stoppedAt?: string;
  currentTask?: string;
  reason?: string;
}

// Log entry
interface LogEntry {
  level: LogLevel;
  message: string;
  taskId?: string;
  logTimestamp: string;
}

// Plan summary for all-plans view
interface PlanSummary {
  name: string;
  status: PlanStatus;
  progress: Progress;
}

// Aggregate statistics
interface AggregateStats {
  totalPlans: number;
  totalTasks: number;
  completed: number;
  pending: number;
  in_progress: number;
  failed: number;
  percentage: number;
}

// Message types
interface StatusMessage {
  type: 'status';
  plan: string;
  status: PlanStatus;
  progress: Progress;
  currentTask: TaskInfo | null;
  lastUpdatedAt: string;
  timestamp: string;
}

interface AllPlansMessage {
  type: 'all-plans';
  plans: PlanSummary[];
  aggregate: AggregateStats;
  timestamp: string;
}

interface TaskUpdateMessage {
  type: 'task_update';
  plan: string;
  task: TaskInfo;
  timestamp: string;
}

interface OrchestratorUpdateMessage {
  type: 'orchestrator_update';
  plan: string;
  orchestrator: OrchestratorInfo;
  timestamp: string;
}

interface LogMessage {
  type: 'log';
  plan: string;
  log: LogEntry;
  timestamp: string;
}

interface ProgressUpdateMessage {
  type: 'progress_update';
  plan: string;
  completed: number;
  total: number;
  percentage: number;
  timestamp: string;
}

interface ErrorMessage {
  type: 'error';
  error: string;
  code: string;
  details: Record<string, unknown>;
  timestamp: string;
}

interface HeartbeatMessage {
  type: 'heartbeat';
  timestamp: string;
}

// Union type for all messages
type WebSocketMessage =
  | StatusMessage
  | AllPlansMessage
  | TaskUpdateMessage
  | OrchestratorUpdateMessage
  | LogMessage
  | ProgressUpdateMessage
  | ErrorMessage
  | HeartbeatMessage;
```

## Client Implementation Example

```typescript
// lib/websocket/client.ts

class PlanWebSocket {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  private listeners: Map<string, Set<(data: unknown) => void>> = new Map();

  constructor(private url: string) {}

  connect(): void {
    this.ws = new WebSocket(this.url);

    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data) as WebSocketMessage;
        this.emit(message.type, message);
        this.emit('*', message); // Wildcard listener
      } catch (e) {
        console.error('Failed to parse WebSocket message:', e);
      }
    };

    this.ws.onclose = () => {
      console.log('WebSocket disconnected');
      this.scheduleReconnect();
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnect attempts reached');
      return;
    }

    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts);
    this.reconnectAttempts++;

    setTimeout(() => {
      console.log(`Reconnecting (attempt ${this.reconnectAttempts})...`);
      this.connect();
    }, delay);
  }

  on<T>(type: string, callback: (data: T) => void): () => void {
    if (!this.listeners.has(type)) {
      this.listeners.set(type, new Set());
    }
    this.listeners.get(type)!.add(callback as (data: unknown) => void);

    // Return unsubscribe function
    return () => {
      this.listeners.get(type)?.delete(callback as (data: unknown) => void);
    };
  }

  private emit(type: string, data: unknown): void {
    this.listeners.get(type)?.forEach(callback => callback(data));
  }

  send(message: object): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }

  disconnect(): void {
    this.ws?.close();
    this.ws = null;
  }
}

// Usage
const ws = new PlanWebSocket('ws://localhost:3100/ws/all');
ws.connect();

ws.on<StatusMessage>('status', (data) => {
  console.log(`Plan ${data.plan} progress: ${data.progress.percentage}%`);
});

ws.on<TaskUpdateMessage>('task_update', (data) => {
  console.log(`Task ${data.task.id} changed to ${data.task.status}`);
});
```

## React Hook Example

```typescript
// lib/websocket/hooks.ts

import { useEffect, useCallback, useState } from 'react';

export function usePlanWebSocket(planName: string | 'all') {
  const [status, setStatus] = useState<StatusMessage | null>(null);
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const endpoint = planName === 'all'
      ? 'ws://localhost:3100/ws/all'
      : `ws://localhost:3100/ws/plans/${planName}`;

    const ws = new WebSocket(endpoint);

    ws.onopen = () => {
      setConnected(true);
      setError(null);
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'status':
        case 'all-plans':
          setStatus(data);
          break;
        case 'error':
          setError(data.error);
          break;
        case 'heartbeat':
          // Keep-alive, no action needed
          break;
      }
    };

    ws.onclose = () => {
      setConnected(false);
    };

    ws.onerror = () => {
      setError('WebSocket connection error');
    };

    return () => {
      ws.close();
    };
  }, [planName]);

  return { status, connected, error };
}

// Usage in component
function PlanProgress({ planName }: { planName: string }) {
  const { status, connected, error } = usePlanWebSocket(planName);

  if (error) return <div className="error">{error}</div>;
  if (!connected) return <div>Connecting...</div>;
  if (!status) return <div>Loading...</div>;

  return (
    <div>
      <ProgressBar value={status.progress.percentage} />
      <span>{status.progress.completed}/{status.progress.total} tasks</span>
    </div>
  );
}
```

## Message Frequency

| Message Type | Trigger | Expected Frequency |
|--------------|---------|-------------------|
| `status` | status.json change | Every task completion |
| `all-plans` | Any plan change | Every plan update |
| `task_update` | Task status change | Per task transition |
| `orchestrator_update` | Orchestrator start/stop | Rare |
| `log` | New log entry | Frequent (if streaming) |
| `progress_update` | Any progress change | High frequency |
| `heartbeat` | Timer | Every 30 seconds |

## Best Practices

1. **Handle reconnection gracefully**
   - Implement exponential backoff
   - Show connection status to user
   - Queue messages during disconnect

2. **Debounce rapid updates**
   - Use `requestAnimationFrame` for UI updates
   - Batch state updates
   - Throttle if needed (e.g., 100ms)

3. **Validate incoming messages**
   - Check `type` field exists
   - Validate against TypeScript types
   - Handle unknown message types gracefully

4. **Clean up subscriptions**
   - Unsubscribe on component unmount
   - Close WebSocket connections properly
   - Clear intervals and timeouts
