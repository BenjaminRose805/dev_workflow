# Task 4.1: Task-Level Dependencies Analysis

## Overview

This analysis examines how task dependencies are expressed and managed within plan phases, focusing on the mechanisms for ordering tasks and preventing conflicts during execution.

## Current Dependency Expression Patterns

### 1. Explicit Dependency Patterns

#### 1.1 [SEQUENTIAL] Annotation (Primary Mechanism)

The `[SEQUENTIAL]` annotation in **Execution Note:** blocks is the primary mechanism for expressing task-level dependencies within phases.

**Syntax Pattern:**
```markdown
**Execution Note:** Tasks X.Y-X.Z are [SEQUENTIAL] - <reason>
```

**Examples from active plans:**

From `tui-integration-implementation.md`:
```markdown
**Execution Note:** Tasks 2.1-2.6 are [SEQUENTIAL] - all modify TUI layout in `scripts/tui/` and must be integrated one at a time to avoid layout conflicts
```

From `documentation-cleanup.md`:
```markdown
**Execution Note:** Tasks 1.3-1.7 are [SEQUENTIAL] - 1.3 creates directory that 1.4-1.7 require
**Execution Note:** Tasks 3.1-3.4 are [SEQUENTIAL] - all modify docs/architecture/orchestrator-system.md
```

From `implement-orchestration-constraints.md`:
```markdown
**Execution Note:** Tasks 2.1-2.3 are [SEQUENTIAL] - all modify cmdNext() in status-cli.js
```

#### 1.2 Textual Dependencies in Task Descriptions

Some plans express dependencies directly in task text:

From `output-separation-implementation.md`:
```markdown
- [x] 0.3 Create `scripts/lib/plan-output-utils.js` (depends on 0.2)
- [x] 1.1 Create `scripts/lib/status-manager.js` (depends on 0.2, 0.3)
```

#### 1.3 Dependencies Section at Plan Level

Plans include an explicit `## Dependencies` section documenting upstream/downstream relationships:

```markdown
## Dependencies

### Upstream
- **critical-fixes.md** (MUST complete first)
- `scripts/lib/plan-pointer.js` (from critical-fixes)

### Downstream
- medium-priority-fixes.md
```

### 2. Implicit Dependency Patterns

#### 2.1 Task Ordering Within Phases

Tasks are numbered sequentially (e.g., 1.1, 1.2, 1.3) implying execution order. The system assumes tasks within a phase can run in parallel unless marked otherwise.

#### 2.2 Phase-Level Dependencies

Phases are inherently sequential - Phase 2 tasks assume Phase 1 is complete:

```markdown
## Phase 1: Foundation (No dependencies)
## Phase 2: Status Tracking (Depends on Phase 1)
## Phase 3: Command Updates (Depends on Phases 1 & 2)
```

#### 2.3 Shared File Detection

The system can detect file conflicts even without annotations. From `implement.md`:
```markdown
**Detect file conflicts** (even without annotation):
- If multiple selected tasks mention the same file path, treat as sequential
- Example: Tasks both mentioning "orchestrator-system.md" → sequential
```

## System Enforcement Mechanisms

### 1. Constraint Parsing (plan-status.js)

The `parseExecutionNotes()` function extracts sequential constraints from plan content:

**Location:** `/home/benjamin/tools/dev_workflow/scripts/lib/plan-status.js` (lines 950-995)

```javascript
function parseExecutionNotes(planContent) {
  const notePattern = /\*\*Execution Note:\*\*\s*Tasks?\s+([\d.,\s-]+)\s+(?:are|is)\s+\[SEQUENTIAL\]\s*[-–—]?\s*(.+?)(?:\n|$)/gi;
  // Parses and expands task ranges into constraint objects
}
```

**Capabilities:**
- Parses `**Execution Note:** Tasks X.Y-X.Z are [SEQUENTIAL] - reason` patterns
- Expands task ranges (e.g., "3.1-3.4" → ["3.1", "3.2", "3.3", "3.4"])
- Handles comma-separated lists ("3.1,3.3" → ["3.1", "3.3"])
- Handles multiple ranges with "and" separator

### 2. Constraint Storage in status.json

Constraints are stored both at task level and plan level:

**Per-task storage:**
```json
{
  "id": "2.1",
  "status": "completed",
  "executionConstraints": {
    "sequential": true,
    "sequentialGroup": "2.1-2.3",
    "reason": "all modify cmdNext() in status-cli.js"
  }
}
```

**Plan-level summary:**
```json
{
  "sequentialGroups": [
    {
      "taskRange": "2.1-2.3",
      "taskIds": ["2.1", "2.2", "2.3"],
      "reason": "all modify cmdNext() in status-cli.js"
    }
  ]
}
```

### 3. status-cli.js Next Command

The `cmdNext()` command in status-cli.js returns constraint metadata with task objects:

**Location:** `/home/benjamin/tools/dev_workflow/scripts/status-cli.js` (lines 375-503)

**Output format:**
```json
{
  "tasks": [
    {
      "id": "3.1",
      "description": "Task description",
      "phase": 3,
      "status": "pending",
      "reason": "pending - ready to implement",
      "sequential": true,
      "sequentialGroup": "3.1-3.4",
      "sequentialReason": "all modify same file"
    }
  ]
}
```

### 4. Orchestrator Constraint Filtering

The Python orchestrator filters tasks to respect sequential constraints:

**Location:** `/home/benjamin/tools/dev_workflow/scripts/plan_orchestrator.py` (lines 215-261)

```python
def _filter_sequential_tasks(self, tasks: list) -> list:
    """Filter tasks to respect sequential constraints.

    If multiple tasks share the same sequentialGroup, only include the first one.
    """
    seen_groups = set()
    filtered = []
    for task in tasks:
        seq_group = task.get("sequentialGroup")
        if seq_group:
            if seq_group in seen_groups:
                continue  # Hold back duplicate group members
            seen_groups.add(seq_group)
        filtered.append(task)
    return filtered
```

### 5. plan:implement Command

The `/plan:implement` command handles dependencies at multiple levels:

**Location:** `/home/benjamin/tools/dev_workflow/.claude/commands/plan/implement.md`

**Parsing (Step 2):**
```markdown
Look for `**Execution Note:**` blocks after phase headers:
- Pattern: `**Execution Note:** Tasks X.Y-X.Z are [SEQUENTIAL] - reason`
- Extract task ID ranges from annotations
```

**Execution Strategy (Step 4):**
```markdown
**Group by phase for execution (respecting constraints):**
- Tasks in DIFFERENT phases: Always sequential (phase order matters)
- Tasks in SAME phase with `[SEQUENTIAL]`: Run one at a time
- Tasks in SAME phase with file conflicts: Run one at a time
- Tasks in SAME phase, independent: Can run in parallel
```

## Dependency Declaration Syntax Reference

### Supported Syntax Patterns

| Pattern | Example | Behavior |
|---------|---------|----------|
| Range | `Tasks 3.1-3.4 are [SEQUENTIAL]` | Tasks 3.1, 3.2, 3.3, 3.4 run sequentially |
| Single | `Task 3.1 is [SEQUENTIAL]` | Task 3.1 has constraint |
| List | `Tasks 3.1, 3.3 are [SEQUENTIAL]` | Tasks 3.1 and 3.3 only |
| Multiple ranges | `Tasks 2.1-2.3 and 3.1-3.4` | Both ranges constrained |

### Reason Formats

Reasons can use hyphen, en-dash, or em-dash as separator:
```markdown
[SEQUENTIAL] - reason
[SEQUENTIAL] – reason
[SEQUENTIAL] — reason
```

## Gaps in Dependency Management

### 1. No Cross-Phase Task Dependencies

**Gap:** Cannot express "Task 2.3 depends on Task 1.5" across phases.

**Current Workaround:** Phase-level ordering ensures Phase 1 completes before Phase 2 starts.

**Impact:** Fine-grained inter-phase dependencies are not expressible.

### 2. No Dependency-Based Ordering Within Sequential Groups

**Gap:** `[SEQUENTIAL]` forces order by task ID, not by actual dependency relationships.

**Example Problem:** If Task 3.3 should run before 3.1 due to a dependency, the annotation cannot express this.

**Impact:** Must manually order task IDs to match dependency requirements.

### 3. No Conditional Dependencies

**Gap:** Cannot express "Task 2.5 only if Task 2.3 succeeded" logic.

**Current Workaround:** Use `markTaskSkipped()` with reason during execution.

**Impact:** Complex conditional flows require manual handling.

### 4. Limited File Conflict Detection

**Gap:** File conflict detection relies on:
- Explicit `[SEQUENTIAL]` annotations
- Task descriptions mentioning the same file path

**Missing:** Automatic analysis of task content to detect file overlaps.

**Impact:** Relies on plan author to identify conflicts.

### 5. No Explicit DAG Representation

**Gap:** Dependencies are expressed as annotations, not as a formal directed acyclic graph (DAG).

**Impact:**
- Cannot easily visualize dependency relationships
- Cannot compute optimal parallel execution order
- Cannot detect circular dependencies

## Execution Order Enforcement Summary

| Level | Mechanism | Enforcement |
|-------|-----------|-------------|
| **Phase order** | Phase numbering (Phase 0, 1, 2...) | status-cli.js respects phase order in `next` command |
| **[SEQUENTIAL] tasks** | `parseExecutionNotes()` parsing | Orchestrator `_filter_sequential_tasks()` holds back duplicate group members |
| **File conflicts** | Manual detection or annotation | `/plan:implement` groups conflicting tasks sequentially |
| **Task ordering** | Task ID ordering (1.1, 1.2, 1.3) | FIFO within phase, but parallel by default |

## Recommendations for Future Improvements

### 1. Explicit Task Dependencies

Add syntax for explicit task-to-task dependencies:
```markdown
- [ ] 2.3 Create user service (depends: 2.1, 2.2)
```

### 2. Dependency Visualization

Add `plan:deps` command to visualize dependency graph.

### 3. Automatic File Conflict Detection

Analyze task content to detect shared file modifications automatically.

### 4. DAG-Based Execution Planner

Replace linear ordering with DAG-based scheduler for optimal parallelism.

### 5. Constraint Validation

Add validation to detect:
- Circular dependencies
- Conflicting constraints
- Missing sequential annotations where file conflicts exist

## Summary

The current system provides functional task-level dependency management through:

1. **`[SEQUENTIAL]` annotations** - Primary mechanism for expressing within-phase dependencies
2. **Phase ordering** - Implicit sequential execution across phases
3. **Constraint parsing** - Machine-readable extraction via `parseExecutionNotes()`
4. **Status tracking** - Constraints stored in `status.json` for runtime access
5. **Orchestrator filtering** - `_filter_sequential_tasks()` enforces one-at-a-time for sequential groups

The main gaps are the lack of:
- Explicit task-to-task dependencies across phases
- Conditional dependencies
- Automatic file conflict detection
- Formal DAG representation

These limitations are acceptable for current plan sizes but may need addressing for more complex plans or stricter parallelism requirements.
