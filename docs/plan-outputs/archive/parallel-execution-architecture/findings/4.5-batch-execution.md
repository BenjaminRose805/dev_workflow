# Task 4.5: Batch Execution Analysis

**Analysis Plan:** Parallel Execution Architecture
**Task:** 4.5 - Review existing batch execution in orchestrator (`next N` command)
**Date:** 2025-12-25

---

## Executive Summary

The batch execution system consists of three interconnected components:

1. **`status-cli.js next N`** - Task selection algorithm with phase-aware ordering
2. **`plan:batch`** - Interactive/autonomous batch execution skill
3. **`plan:orchestrate`** - Autonomous loop using batch execution

Current implementation supports **intra-phase parallelism** but enforces **inter-phase sequentiality** with an 80% completion threshold for phase advancement.

---

## 1. How `next N` Selects Tasks

### Algorithm Overview

The `cmdNext()` function in `scripts/status-cli.js` (lines 376-503) implements a three-priority selection algorithm:

```
Priority 1: In-Progress Tasks
    └── Return immediately if any exist

Priority 2: Failed Tasks
    └── May need retry or manual intervention

Priority 3: Pending Tasks
    └── Respect phase ordering with 80% threshold
```

### Detailed Selection Logic

#### Step 1: Phase Grouping

```javascript
// Group tasks by phase for phase-order logic
const phaseMap = new Map();
for (const task of status.tasks) {
  const phaseName = task.phase || 'Unknown Phase';
  // Extract phase number from "Phase N: Title"
  const phaseMatch = phaseName.match(/Phase\s+(\d+)/);
  const phaseNumber = phaseMatch ? parseInt(phaseMatch[1]) : 0;
  phaseMap.set(phaseName, { number: phaseNumber, title: phaseName, tasks: [] });
  phaseMap.get(phaseName).tasks.push(task);
}
const phases = Array.from(phaseMap.values()).sort((a, b) => a.number - b.number);
```

#### Step 2: In-Progress Check (Priority 1)

```javascript
// First check for in-progress tasks - these MUST complete first
for (const phase of phases) {
  for (const task of phase.tasks) {
    if (task.status === 'in_progress') {
      next.push({
        id: task.id,
        reason: 'in_progress - should be completed first',
        ...getConstraintMetadata(task.id)  // Includes sequential info
      });
    }
  }
}
if (next.length > 0) {
  return next.slice(0, maxTasks);  // Return immediately
}
```

#### Step 3: Failed Task Collection (Priority 2)

```javascript
// Then check for failed tasks that might be retried
for (const phase of phases) {
  for (const task of phase.tasks) {
    if (task.status === 'failed') {
      next.push({
        id: task.id,
        reason: 'failed - needs retry or manual intervention',
        ...getConstraintMetadata(task.id)
      });
    }
  }
}
```

#### Step 4: Pending Tasks with Phase Gate (Priority 3)

```javascript
for (const phase of phases) {
  // Check if previous phases are complete enough (80% threshold)
  const previousPhases = phases.filter(p => p.number < phase.number);

  const previousIncomplete = previousPhases.some(p =>
    p.tasks.some(t => t.status === 'pending' || t.status === 'in_progress')
  );

  const previousMostlyComplete = previousPhases.every(p => {
    const completed = p.tasks.filter(t =>
      t.status === 'completed' || t.status === 'skipped'
    ).length;
    return completed >= p.tasks.length * 0.8;  // 80% threshold
  });

  if (previousIncomplete && !previousMostlyComplete) {
    continue; // Skip this phase for now
  }

  // Collect pending tasks from this phase
  for (const task of phase.tasks) {
    if (task.status === 'pending' && next.length < maxTasks) {
      next.push({ id: task.id, reason: 'pending - ready to implement' });
    }
  }
  if (next.length >= maxTasks) break;
}
```

### Constraint Metadata Enrichment

The `next` command enriches task data with execution constraints from the plan:

```javascript
function getConstraintMetadata(taskId) {
  for (const constraint of constraints) {
    if (constraint.taskIds.includes(taskId)) {
      return {
        sequential: true,
        sequentialGroup: constraint.taskRange,  // e.g., "3.1-3.4"
        sequentialReason: constraint.reason      // e.g., "all modify same file"
      };
    }
  }
  return { sequential: false };
}
```

### Output Format

```json
{
  "count": 3,
  "tasks": [
    {
      "id": "1.1",
      "description": "Implement WebSocket connection",
      "phase": 1,
      "status": "pending",
      "reason": "pending - ready to implement",
      "sequential": false
    },
    {
      "id": "1.2",
      "description": "Create preferences store",
      "phase": 1,
      "status": "pending",
      "reason": "pending - ready to implement",
      "sequential": false
    }
  ]
}
```

---

## 2. How Batch Execution Works

### The `plan:batch` Skill

Located at `.claude/commands/plan/batch.md`, this skill provides both interactive and autonomous batch execution.

#### Argument Parsing

| Format | Example | Behavior |
|--------|---------|----------|
| Single task | `1.1` | Execute task 1.1 only |
| Multiple tasks | `1.1 1.2 1.3` | Execute listed tasks |
| Phase selector | `phase:1` or `p:1` | All pending tasks in Phase 1 |
| All pending | `all` | All pending tasks (with confirmation) |
| Autonomous | `--autonomous` | Skip all interactive prompts |

#### Execution Flow

```
1. Initialize
   ├── Load active plan from .claude/current-plan.txt
   ├── Initialize status.json via initializePlanStatus()
   └── Parse arguments or enter interactive mode

2. Parse Plan File
   ├── Extract phases with names
   ├── Extract incomplete tasks grouped by phase
   ├── Parse task dependencies
   └── Identify complexity indicators (CRITICAL, HIGH, etc.)

3. Build Execution Plan
   ├── Group selected tasks by phase
   ├── Detect dependencies (explicit [SEQUENTIAL] or file conflicts)
   └── Build parallel groups (same phase, no conflicts → parallel)

4. Show Preview (skip in autonomous mode)
   ├── Display execution groups
   └── Confirm with user

5. Execute with Progress
   ├── Start run: startRun(planPath)
   ├── For each group:
   │   ├── Mark tasks started
   │   ├── Launch parallel agents (if group is parallel)
   │   ├── Collect results
   │   └── Write files from agent output
   └── Complete run: completeRun(planPath, runId)

6. Final Summary
   └── Report completed/failed/skipped counts
```

### Parallel Execution Strategy

#### Group Classification

```
Phase 0 (Sequential - file operations):
├─► 0.3 Update playwright.config.ts
└─► 0.4 Update vitest.config.ts

Phase 1 (Parallel - independent test files):
├─┬─► 1.1 websocket-connection.test.ts
│ ├─► 1.2 preferences-store.test.ts
│ └─► 1.3 api-utils.test.ts
└── (All 3 tasks run concurrently)

Phase 3 [SEQUENTIAL]:
├─► 3.1 Merge ORCHESTRATOR.md content
├─► 3.2 Merge ARCHITECTURE.md content
└─► 3.3 Create redirect file
    (Each task waits for previous)
```

#### Agent Spawning

```markdown
For parallel tasks, use the Task tool with multiple agents:

Launching parallel group (Phase 1):
- Agent 1: 1.1 websocket-connection.test.ts
- Agent 2: 1.2 preferences-store.test.ts
- Agent 3: 1.3 api-utils.test.ts

Waiting for all agents to complete...
```

#### Read-Only Agent Pattern

Critical for avoiding race conditions:

```markdown
IMPORTANT: Do NOT write files directly. Instead:
1. Analyze the task requirements
2. Generate the complete code/content
3. Return your output in this format:
   FILE: <path>
   ```<language>
   <content>
   ```
4. The main conversation will handle file writing
```

### Parallelization Rules (from batch.md)

1. **All independent tasks in same phase run together**
2. **Use up to 5 parallel agents for large batches**
3. **Balance load across agents**
4. **Keep file-modifying tasks sequential to avoid conflicts**
5. **Run quick tasks first within a parallel group**

---

## 3. Orchestrator's Use of Batch Execution

### The `plan:orchestrate` Loop

The orchestrator in `.claude/commands/plan/orchestrate.md` implements an autonomous execution loop:

```
Main Execution Loop:

Step 2.1: Get Next Tasks
  └── node scripts/status-cli.js next 5

Step 2.2: Execute Tasks in Parallel
  ├── Launch up to 3-5 Task agents simultaneously
  ├── Use subagent_type="general-purpose"
  └── Each agent marks own task started/complete

Step 2.3: Collect Results
  └── Wait for all agents via TaskOutput

Step 2.4: Report Progress
  └── Output formatted status update

Step 2.5: Loop Back (IMMEDIATELY)
  └── Do not wait for user input
```

### Batch Size Guidelines

| Plan Size | Batch Size | Rationale |
|-----------|------------|-----------|
| < 10 tasks | 2-3 | Small plan, quick iteration |
| 10-30 tasks | 3-4 | Medium plan, balanced |
| > 30 tasks | 4-5 | Large plan, maximize throughput |

### Key Orchestrator Rules

From `orchestrate.md`:

> **DO NOT** ask for confirmation between tasks - just keep executing.
> **DO NOT** use Skill() invocations - implement directly using Task agents.
> **DO** batch multiple tasks together for efficiency.
> **DO** report progress after each batch, then immediately continue.

---

## 4. Current Parallel Execution Support

### Parallelism Levels

| Level | Support | Mechanism |
|-------|---------|-----------|
| **Parallel Plans** | NOT SUPPORTED | Single `current-plan.txt` pointer |
| **Parallel Phases** | LIMITED | 80% completion threshold |
| **Parallel Tasks** | SUPPORTED | Within same phase, if independent |
| **Parallel Agents** | SUPPORTED | Multiple Task agents per task |

### Phase Advancement Logic

The 80% threshold allows early advancement to next phase:

```javascript
// From status-cli.js
const previousMostlyComplete = previousPhases.every(p => {
  const completed = p.tasks.filter(t =>
    t.status === 'completed' || t.status === 'skipped'
  ).length;
  return completed >= p.tasks.length * 0.8;
});
```

**Example:**
- Phase 1 has 10 tasks
- When 8 tasks complete (80%), Phase 2 can start
- Remaining 2 tasks in Phase 1 run in parallel with Phase 2

### Sequential Enforcement

#### 1. Explicit `[SEQUENTIAL]` Annotation

```markdown
**Execution Note:** Tasks 3.1-3.4 are [SEQUENTIAL] - all modify same file
```

Parsed by `parseExecutionNotes()`:
```javascript
const notePattern = /\*\*Execution Note:\*\*\s*Tasks?\s+([\d.,\s-]+)\s+(?:are|is)\s+\[SEQUENTIAL\]/gi;
```

#### 2. Implicit File Conflict Detection

From `implement.md`:
> If multiple selected tasks mention the same file path, treat as sequential

#### 3. Phase Ordering

> Tasks in DIFFERENT phases: Always sequential (phase order matters)

---

## 5. Limitations of Current Approach

### 1. Single Active Plan Constraint

**Problem:** Only one plan can execute at a time due to `current-plan.txt` pointer.

```
.claude/current-plan.txt → docs/plans/only-one-plan.md
```

**Impact:**
- Cannot parallelize independent plans
- Context switching requires explicit `/plan:set`
- No concurrent project streams

### 2. Phase Ordering is Strict

**Problem:** The 80% threshold still enforces strict phase boundaries.

**Scenario:**
```
Phase 1: [1.1, 1.2, 1.3, 1.4, 1.5] - Tests
Phase 2: [2.1, 2.2] - Integration

If 1.1-1.4 complete but 1.5 is stuck:
- Phase 2 CAN start (80% complete)
- But 1.5 must complete before Phase 2 finishes
```

**Limitation:** No way to express "2.1 only depends on 1.1-1.3, not 1.4-1.5"

### 3. Constraint Detection is Manual

**Problem:** Sequential constraints require explicit `[SEQUENTIAL]` annotation.

**Missing automation:**
- No automatic file conflict detection during selection
- No dependency graph analysis
- Developer must manually annotate plan

### 4. No Cross-Task Dependencies

**Problem:** Cannot express "Task 2.3 depends on Task 1.2"

**Current workaround:**
- Place dependent tasks in later phases
- Use `[SEQUENTIAL]` within same phase

**Limitation:** Forces artificial phase boundaries

### 5. Retry Logic is Simple

**Problem:** Fixed retry count (2) with no backoff or categorization.

```javascript
const MAX_RETRIES = 2;
```

**Missing:**
- Transient vs permanent failure classification
- Exponential backoff
- Resource-aware scheduling

### 6. No Resource Awareness

**Problem:** Batch size is static, not resource-aware.

**Current:** "Use up to 5 parallel agents"

**Missing:**
- Memory usage monitoring
- API rate limiting consideration
- Task complexity weighting

### 7. Limited Progress Visibility

**Problem:** Progress markers are text-based, not structured.

```
[BATCH] started tasks=5 phases=2
[PROGRESS] task=1.1 status=started agent=parallel
```

**Missing:**
- Real-time progress streaming
- Structured event format
- Estimated completion times

---

## 6. Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                    BATCH EXECUTION FLOW                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────┐                                          │
│  │ plan:orchestrate │                                          │
│  │ (Autonomous Loop)│                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────┐    ┌─────────────────────┐               │
│  │ status-cli.js    │    │ plan-status.js      │               │
│  │ next N           │◄───┤ loadStatus()        │               │
│  │                  │    │ parseExecutionNotes()│               │
│  │ - Phase ordering │    │ getTaskConstraints() │               │
│  │ - 80% threshold  │    └─────────────────────┘               │
│  │ - Constraint info│                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│           ▼ (Returns: task IDs + sequential flags)              │
│  ┌──────────────────┐                                          │
│  │ plan:batch       │                                          │
│  │                  │                                          │
│  │ - Group tasks    │                                          │
│  │ - Detect deps    │                                          │
│  │ - Build groups   │                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────────────────────────────┐                  │
│  │            EXECUTION ENGINE               │                  │
│  │                                           │                  │
│  │  Sequential Group    Parallel Group       │                  │
│  │  ┌───┐              ┌───┬───┬───┐        │                  │
│  │  │T1 │─►            │T1 │T2 │T3 │        │                  │
│  │  └─┬─┘              └─┬─┴─┬─┴─┬─┘        │                  │
│  │    │                  └───┼───┘          │                  │
│  │  ┌─▼─┐                    │              │                  │
│  │  │T2 │─►                  ▼              │                  │
│  │  └─┬─┘              Wait for all         │                  │
│  │    │                                      │                  │
│  │  ┌─▼─┐                                    │                  │
│  │  │T3 │─►                                  │                  │
│  │  └───┘                                    │                  │
│  └──────────────────────────────────────────┘                  │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────┐                                          │
│  │ status.json      │                                          │
│  │ (Source of Truth)│                                          │
│  └──────────────────┘                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. Key Code References

| Component | File | Key Functions |
|-----------|------|---------------|
| Task selection | `scripts/status-cli.js` | `cmdNext()` (lines 376-503) |
| Batch skill | `.claude/commands/plan/batch.md` | Full execution flow |
| Orchestrator | `.claude/commands/plan/orchestrate.md` | Autonomous loop |
| Status library | `scripts/lib/plan-status.js` | `loadStatus()`, `parseExecutionNotes()` |
| Constraint parsing | `scripts/lib/plan-status.js` | `expandTaskRange()`, `getTaskConstraints()` |
| Retry handling | `scripts/lib/plan-output-utils.js` | `getRetryableTasks()`, `incrementRetryCount()` |

---

## 8. Summary

### Current Strengths

1. **Clean task selection algorithm** with clear priority ordering
2. **Phase-aware execution** with 80% threshold flexibility
3. **Read-only agent pattern** prevents race conditions
4. **Structured constraint parsing** from `[SEQUENTIAL]` annotations
5. **Autonomous mode** for CI/CD integration

### Current Limitations

1. **Single active plan** prevents concurrent execution
2. **No cross-task dependencies** beyond phase ordering
3. **Manual constraint annotation** required
4. **Fixed retry logic** without categorization
5. **No resource awareness** in batch sizing

### Recommendations for Future Enhancement

1. **Implement dependency graph** for true cross-task dependencies
2. **Auto-detect file conflicts** during task selection
3. **Add resource-aware scheduling** based on task complexity
4. **Support multiple active plans** with separate execution contexts
5. **Categorize failures** for smarter retry logic
