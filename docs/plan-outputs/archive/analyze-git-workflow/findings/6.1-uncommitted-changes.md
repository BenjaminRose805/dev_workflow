# Task 6.1: Handle Uncommitted Changes When Switching Plans

## Executive Summary

Uncommitted changes are the most common edge case in plan switching. This document defines a **4-option handling strategy** (Commit/Stash/Abort/Force) with smart defaults and safety mechanisms.

**Key Principle:** Never lose work silently. All destructive operations require explicit user confirmation.

---

## 1. Detection Mechanism

### 1.1 Change Detection Commands

```bash
# Check for any uncommitted changes (staged + unstaged + untracked)
git status --porcelain

# Output format:
# M  src/file.ts          (staged modification)
#  M src/other.ts         (unstaged modification)
# ?? src/new-file.ts      (untracked file)
# A  src/added.ts         (staged new file)
# D  src/deleted.ts       (staged deletion)
```

### 1.2 Detection Categories

| Category | Detection | Risk Level |
|----------|-----------|------------|
| Staged changes | `git diff --cached --quiet` returns non-zero | MEDIUM |
| Unstaged changes | `git diff --quiet` returns non-zero | MEDIUM |
| Untracked files | `git ls-files --others --exclude-standard` | LOW |
| Merge in progress | `.git/MERGE_HEAD` exists | HIGH |
| Rebase in progress | `.git/rebase-merge/` exists | HIGH |

### 1.3 Implementation

```javascript
function detectUncommittedChanges() {
  const result = {
    hasChanges: false,
    staged: [],
    unstaged: [],
    untracked: [],
    mergeInProgress: false,
    rebaseInProgress: false,
    riskLevel: 'none'
  };

  // Check for merge/rebase in progress
  result.mergeInProgress = fs.existsSync('.git/MERGE_HEAD');
  result.rebaseInProgress = fs.existsSync('.git/rebase-merge');

  if (result.mergeInProgress || result.rebaseInProgress) {
    result.riskLevel = 'high';
    result.hasChanges = true;
    return result;
  }

  // Get porcelain status
  const status = execSync('git status --porcelain').toString();
  const lines = status.trim().split('\n').filter(Boolean);

  for (const line of lines) {
    const staged = line[0];
    const unstaged = line[1];
    const file = line.slice(3);

    if (staged !== ' ' && staged !== '?') {
      result.staged.push(file);
    }
    if (unstaged !== ' ' && unstaged !== '?') {
      result.unstaged.push(file);
    }
    if (staged === '?') {
      result.untracked.push(file);
    }
  }

  result.hasChanges = lines.length > 0;
  result.riskLevel = result.staged.length > 0 ? 'medium' : 'low';

  return result;
}
```

---

## 2. User Options (CSAF)

### 2.1 Option Overview

```
⚠ Uncommitted changes detected (5 files modified, 2 untracked)

Modified:
  • src/lib/auth.ts
  • src/middleware/validate.ts
  • src/routes/api.ts
  ... and 2 more files

Options:
  [C] Commit changes to current branch (recommended)
  [S] Stash changes (can restore later)
  [A] Abort - stay on current plan
  [F] Force - discard changes (DANGEROUS)

Choose [C/S/A/F]:
```

### 2.2 Option C: Commit Changes

**When to Recommend:** User is on the correct plan branch and changes are related to current work.

**Implementation:**

```bash
# Auto-generate descriptive commit message
git add -A
git commit -m "WIP: Auto-commit before switching to plan/${NEW_PLAN_NAME}

Changes from plan/${CURRENT_PLAN_NAME}
Staged files: ${STAGED_COUNT}
Unstaged files: ${UNSTAGED_COUNT}

Generated by /plan:set"
```

**Validation:**
- Only allow if on a `plan/*` branch (not main/master)
- Warn if commit message would be meaningless (no task context)

**User Feedback:**
```
✓ Committed 5 files to plan/old-plan
  Commit: abc1234 "WIP: Auto-commit before switching..."

Switching to plan/new-plan...
```

### 2.3 Option S: Stash Changes

**When to Recommend:** Changes are experimental or user wants to context-switch temporarily.

**Implementation:**

```bash
# Include untracked files in stash (-u flag)
# Use descriptive message for easy identification
STASH_MSG="Auto-stash from /plan:set | ${CURRENT_BRANCH} → plan/${NEW_PLAN} | $(date +%Y-%m-%d_%H:%M)"

git stash push -u -m "$STASH_MSG"
```

**Stash Naming Convention:**

```
Auto-stash from /plan:set | plan/auth-impl → plan/test-suite | 2025-12-24_15:30
```

**User Feedback:**
```
✓ Changes stashed (stash@{0})
  Message: "Auto-stash from /plan:set | plan/old → plan/new | 2025-12-24_15:30"

  To restore: git stash pop
  To list stashes: git stash list

Switching to plan/new-plan...
```

### 2.4 Option A: Abort

**When to Recommend:** User realizes they're not ready to switch.

**Implementation:**

```javascript
console.log("Plan switch cancelled.");
console.log(`Staying on: ${currentBranch}`);
console.log(`Active plan: ${currentPlan}`);
process.exit(0);
```

**User Feedback:**
```
⚠ Plan switch cancelled. Staying on plan/current-plan.

To continue working: /plan:implement
To view progress: /plan:status
```

### 2.5 Option F: Force Switch

**When to Recommend:** NEVER. This is a safety valve for expert users.

**Implementation:**

```bash
# Double confirmation required
echo "WARNING: This will PERMANENTLY DELETE all uncommitted changes."
echo "Type 'DISCARD' to confirm:"
read confirmation

if [ "$confirmation" == "DISCARD" ]; then
  git checkout -- .
  git clean -fd
  echo "✗ Changes discarded"
fi
```

**Safeguards:**
1. Never the default option
2. Require explicit "DISCARD" confirmation
3. Log discarded files for potential recovery
4. Show count of files being discarded

**User Feedback:**
```
⚠ DANGEROUS: This will discard ALL uncommitted changes.

Files that will be lost:
  • src/lib/auth.ts (42 lines changed)
  • src/middleware/validate.ts (17 lines changed)
  ... and 3 more files

Type 'DISCARD' to confirm (or anything else to cancel): DISCARD

✗ Discarded 5 files. Changes are permanently lost.

Switching to plan/new-plan...
```

---

## 3. Smart Defaults

### 3.1 Context-Aware Recommendations

| Scenario | Recommended Option | Reason |
|----------|-------------------|--------|
| On `plan/*` branch, changes exist | C (Commit) | Keep work with current plan |
| On `main`/`master`, changes exist | S (Stash) | Don't pollute main history |
| Only untracked files | S (Stash) | Less intrusive |
| Merge in progress | A (Abort) | Must resolve merge first |
| >20 files changed | S (Stash) | Large changeset, be cautious |

### 3.2 Auto-Handling Mode

For orchestrator/CI usage, provide `--auto` flag:

```bash
# In orchestrator context
/plan:set new-plan --auto=commit    # Always commit
/plan:set new-plan --auto=stash     # Always stash
/plan:set new-plan --auto=abort     # Always abort if changes
```

---

## 4. Special Cases

### 4.1 Merge in Progress

```
⛔ Cannot switch plans: Merge in progress

You have an unfinished merge:
  Merging: feature/auth → plan/current-plan

Options:
  1. Complete the merge: git commit
  2. Abort the merge: git merge --abort

Then re-run /plan:set
```

**Behavior:** Abort with clear guidance. Never auto-resolve merges.

### 4.2 Rebase in Progress

```
⛔ Cannot switch plans: Rebase in progress

You have an unfinished rebase.

Options:
  1. Continue: git rebase --continue
  2. Skip current commit: git rebase --skip
  3. Abort entirely: git rebase --abort

Then re-run /plan:set
```

**Behavior:** Abort with guidance. Never auto-resolve rebases.

### 4.3 Detached HEAD State

```
⚠ You are in detached HEAD state (not on any branch)

Current commit: abc1234
Uncommitted changes: 3 files

Before switching plans, you should:
  1. Create a branch to save your work: git checkout -b temp-work
  2. Or discard changes: git checkout -f main

Then re-run /plan:set
```

### 4.4 Conflict Markers in Files

```
⚠ Files contain conflict markers (<<<<<<<)

Found conflict markers in:
  • src/lib/auth.ts (line 45)
  • src/routes/api.ts (line 127)

These may be from:
  1. An incomplete merge
  2. Manually inserted markers

Please resolve conflicts before switching plans.
```

---

## 5. Recovery Mechanisms

### 5.1 Stash Recovery

```bash
# List all stashes
git stash list

# Find auto-stashes from plan:set
git stash list | grep "Auto-stash from /plan:set"

# Restore specific stash
git stash pop stash@{2}

# Restore without deleting from stash list
git stash apply stash@{2}
```

### 5.2 Commit Recovery

If user committed but wants to undo:

```bash
# Soft reset - keep changes staged
git reset --soft HEAD~1

# Mixed reset - keep changes unstaged
git reset HEAD~1

# View what was committed
git show HEAD
```

### 5.3 Force Discard Recovery

**Prevention is key.** Once force discarded, recovery options are limited:

```bash
# Check reflog for any dangling commits
git fsck --lost-found

# IDE backup (VS Code)
ls ~/.config/Code/User/History/

# System backup (if exists)
# ...
```

**Recommendation:** Log discarded file paths to `orchestrator.log` for debugging.

---

## 6. Implementation in /plan:set

### 6.1 Updated Workflow

```
/plan:set new-plan
       │
       ▼
┌──────────────────┐
│ Check git status │
└────────┬─────────┘
         │
         ▼
    Has changes?───No───► Switch directly
         │
        Yes
         │
         ▼
┌──────────────────┐
│ Merge/Rebase in  │
│ progress?        │───Yes───► Show error, abort
└────────┬─────────┘
         │
        No
         │
         ▼
┌──────────────────┐
│ Show CSAF options│
└────────┬─────────┘
         │
         ▼
┌────────┴────────┐
│ C: Commit       │───► git add -A && git commit
│ S: Stash        │───► git stash push -u
│ A: Abort        │───► Exit(0)
│ F: Force        │───► Confirm + git checkout -f
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│ Switch to branch │
│ (create if new)  │
└──────────────────┘
```

### 6.2 Code Skeleton

```javascript
async function handleUncommittedChanges(targetPlan) {
  const changes = detectUncommittedChanges();

  if (!changes.hasChanges) {
    return { proceed: true };
  }

  // Block on merge/rebase
  if (changes.mergeInProgress) {
    console.error("⛔ Cannot switch: Merge in progress");
    return { proceed: false, reason: 'merge_in_progress' };
  }

  if (changes.rebaseInProgress) {
    console.error("⛔ Cannot switch: Rebase in progress");
    return { proceed: false, reason: 'rebase_in_progress' };
  }

  // Display changes
  displayChangeSummary(changes);

  // Get recommendation
  const recommended = getRecommendedOption(changes);

  // Present options
  const choice = await askUser({
    question: "How would you like to handle these changes?",
    options: [
      { label: `Commit to current branch${recommended === 'C' ? ' (Recommended)' : ''}`, value: 'C' },
      { label: `Stash changes${recommended === 'S' ? ' (Recommended)' : ''}`, value: 'S' },
      { label: 'Abort - stay on current plan', value: 'A' },
      { label: 'Force - discard changes (DANGEROUS)', value: 'F' }
    ]
  });

  switch (choice) {
    case 'C':
      await commitChanges(targetPlan);
      return { proceed: true, action: 'committed' };

    case 'S':
      await stashChanges(targetPlan);
      return { proceed: true, action: 'stashed' };

    case 'A':
      return { proceed: false, reason: 'user_abort' };

    case 'F':
      const confirmed = await confirmForce(changes);
      if (confirmed) {
        await forceClean();
        return { proceed: true, action: 'discarded' };
      }
      return { proceed: false, reason: 'force_cancelled' };
  }
}
```

---

## 7. Logging & Audit Trail

### 7.1 Log Format

```
2025-12-24 15:30:45 [PLAN:SET] Switching from plan/old → plan/new
2025-12-24 15:30:45 [PLAN:SET] Uncommitted changes detected: 5 files
2025-12-24 15:30:45 [PLAN:SET]   - src/lib/auth.ts (modified)
2025-12-24 15:30:45 [PLAN:SET]   - src/routes/api.ts (modified)
2025-12-24 15:30:45 [PLAN:SET]   ... 3 more files
2025-12-24 15:30:48 [PLAN:SET] User chose: STASH
2025-12-24 15:30:48 [PLAN:SET] Stash created: stash@{0} "Auto-stash from /plan:set..."
2025-12-24 15:30:49 [PLAN:SET] Switched to branch: plan/new
2025-12-24 15:30:49 [PLAN:SET] Switch complete. Duration: 4.2s
```

### 7.2 Audit in status.json

```json
{
  "switchEvents": [
    {
      "timestamp": "2025-12-24T15:30:45Z",
      "from": "plan/old-plan",
      "to": "plan/new-plan",
      "uncommittedChanges": 5,
      "action": "stash",
      "stashRef": "stash@{0}",
      "duration": 4.2
    }
  ]
}
```

---

## 8. Summary

### Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| 4 options (CSAF) | Covers all user intents |
| Commit as default for plan branches | Most common case |
| Stash as default for main | Preserve main history |
| Double-confirm for Force | Prevent accidental data loss |
| Block on merge/rebase | Can't safely context-switch mid-operation |

### Implementation Priority

1. **Detection** - `git status --porcelain` parsing
2. **CSAF options** - User prompt with recommendations
3. **Special cases** - Merge/rebase/detached HEAD handling
4. **Logging** - Audit trail for debugging
5. **Auto mode** - For orchestrator/CI usage

**Estimated Effort:** 4-6 hours for complete implementation.
