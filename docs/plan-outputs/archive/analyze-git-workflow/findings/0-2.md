# Task 0.2: Pain Points from Recent Plan Executions

## Overview

Analysis of recent plan execution history, status.json files, and commit patterns reveals several pain points related to git workflow during plan orchestration.

## Pain Points Identified

### 1. Manual Checkpoint Commits Required

**Evidence:** cleanup-deprecated-code plan task 0.3: "Create git commit with current state"

The plan explicitly requires a manual checkpoint task before destructive operations:
- Task 0.3: "Create git commit with current state"
- Completed in 514 seconds (8+ minutes of manual work)
- Created commit `e525cb4`, tagged as `pre-deprecated-cleanup`

**Pain:** Users must manually plan and execute safety checkpoints. No automatic snapshots before risky operations.

### 2. Messy Commit History

**Evidence:** Analysis of last 30 commits shows:

| Commit Type | Count | Example |
|-------------|-------|---------|
| Large batch commits | 8 | "Standardize implementation plans: consistent structure + documentation (39 tasks)" |
| Incremental manual | 12 | "updated from previous plans" |
| Fix commits | 5 | "Fix StreamingClaudeRunner to parse Claude CLI stream-json format" |
| Analysis dumps | 3 | "findings from analysis" |

**Observations:**
- No task-level commits despite implement.md specifying `task {id}: {description}` format
- Commits batch many changes together, losing per-task granularity
- Commit messages often vague ("analysis", "remaining files")
- No conventional commit format (feat/fix/chore)

**Pain:** History doesn't reflect individual task completions. Hard to rollback specific tasks or understand what changed per task.

### 3. No Branch Isolation

**Evidence:** `git branch -a` shows only `master` and `remotes/origin/master`

All 28 commits have occurred on master branch. No plan-specific branches, no phase branches.

**Pain Points:**
- Can't work on multiple plans concurrently
- No isolation for experimental/risky changes
- No clear merge points for completed work
- Risk of breaking master with incomplete plan work

### 4. Lost Work Risk

**Evidence:** No automatic commits between tasks

If the orchestrator crashes or is interrupted mid-plan:
- status.json is saved (tasks marked in_progress)
- Actual file changes may be uncommitted
- No automatic stash or commit before switching contexts

**Pain:** User must manually commit before interruption or risk losing work.

### 5. No Per-Task Commits in Practice

**Evidence:** implement.md specifies commit workflow but status.json shows no correlation

cleanup-deprecated-code plan:
- 62 tasks completed
- Only 2-3 related commits in git history
- Tasks like "1.1 Remove result-aggregator.js" don't have individual commits

**Pain:** The documented git workflow in implement.md is not actually being followed. Either:
- Claude is ignoring the commit step
- The commit step is conditional/skipped
- Users manually override with batch commits

### 6. No Rollback Mechanism

**Evidence:** Recovery section in cleanup-deprecated-code mentions manual git commands:

```bash
git checkout pre-deprecated-cleanup -- scripts/scan-results.js
```

**Pain:** Rolling back a task requires:
1. Knowing the commit/tag before the task
2. Manual git checkout of specific files
3. No orchestrator-level "undo task" command

### 7. Inconsistent Tag Usage

**Evidence:** `pre-deprecated-cleanup` tag created manually in one plan

Tags are ad-hoc, not systematic:
- No standard naming (`plan/{name}`, `phase/{n}`)
- Not automatically created by orchestrator
- Manual decision by plan author

**Pain:** Recovery points are inconsistent. Some plans have them, some don't.

### 8. Plan Switching Without Git Context

**Evidence:** /plan:set command has no git integration

When switching plans:
- No check for uncommitted changes
- No branch switch
- No stash/save of current work
- Risk of mixing changes from different plans

**Pain:** Easy to accidentally commit changes from plan A while working on plan B.

## Summary of Pain Points

| Priority | Pain Point | Impact |
|----------|-----------|--------|
| HIGH | No per-task commits | Can't rollback individual tasks |
| HIGH | No branch isolation | Can't work on multiple plans |
| HIGH | Lost work risk | Interrupted work may be lost |
| MEDIUM | Messy history | Hard to understand changes |
| MEDIUM | Manual checkpoints | Extra work, easily forgotten |
| MEDIUM | No rollback command | Manual recovery only |
| LOW | Inconsistent tags | Recovery points unreliable |
| LOW | Plan switch risk | Context mixing possible |

## Recommendations Preview

Based on these pain points, the git workflow should address:

1. **Automatic commits** - After each task completion (as documented but not enforced)
2. **Branch per plan** - Isolation for concurrent work
3. **Pre-task snapshots** - Safety checkpoint before risky operations
4. **Rollback commands** - `/plan:rollback task 1.1` or similar
5. **Plan switch safety** - Check for uncommitted changes, offer stash
6. **Tag conventions** - Systematic tagging for recovery points
