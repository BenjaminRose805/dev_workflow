# Task 1.3: History Preferences Analysis

## Overview

This analysis evaluates different git history styles and their tradeoffs for automated plan execution in the orchestrator system. The goal is to determine the optimal balance between granularity (for debugging and rollback) and cleanliness (for readability and collaboration).

## Context from Current State

### Existing Evidence

From Phase 0 analysis, the current state reveals:

- **Current practice:** Manual, batched commits (e.g., "Standardize implementation plans: consistent structure + documentation (39 tasks)")
- **Documented intent:** `/plan:implement` specifies `task {id}: {description}` format but includes note: "For cleaner history, consider squashing when merging feature branches"
- **Pain points:**
  - No per-task commits despite documentation
  - Hard to rollback individual tasks due to batched commits
  - Messy history with vague messages
- **Single branch workflow:** All work on `master`, no feature branches yet

### Developer Preference Signals

1. **Existing commit message acknowledges tradeoff:** The note in `implement.md` already recognizes the granular vs clean tension
2. **Manual batching preferred historically:** History shows developer batches related changes
3. **Descriptive summaries valued:** Recent commits have informative subjects

## 1. Granular History (Commit-Per-Task)

### Pattern

Every task creates an individual commit with structured message:

```
task 1.1: Create authentication middleware

Plan: implement-authentication
Phase: Phase 1: Core Implementation
Duration: 45s
Status: completed
```

### Advantages

| Benefit | Impact |
|---------|--------|
| **Full traceability** | Know exactly what changed for task 1.1 |
| **Easy per-task rollback** | `git revert <task-commit>` or `git checkout <commit> -- file.js` |
| **Debugging failures** | Isolate which task introduced a bug |
| **Incremental safety** | Automatic checkpoint after each task |
| **Audit trail** | Complete history of what orchestrator did |
| **Bisect capability** | `git bisect` to find which task broke functionality |

### Disadvantages

| Drawback | Impact | Mitigation |
|----------|--------|------------|
| **Noisy history** | 100-task plan = 100 commits on branch | Squash on merge to main |
| **Log clutter** | `git log` shows many similar commits | Use `git log --oneline --grep="phase"` to filter |
| **Overwhelming diffs** | PR shows 100 individual commits | GitHub collapses, or squash before PR |
| **Commit overhead** | ~2-5s per commit x 100 tasks = 3-8 minutes | Acceptable for safety |

### Performance Analysis

**Time cost per commit:**
- `git status --porcelain`: 0.1-0.5s
- `git add -A`: 0.1-0.3s
- `git commit`: 0.5-1.5s
- **Total:** ~1-2s per task

**For 100-task plan:**
- Sequential: ~2-3 minutes of git overhead
- As % of typical plan runtime (30-60 min): 3-5%
- **Verdict:** Acceptable overhead for benefits gained

### Optimal for

- Solo developers who need rollback capability
- Debugging plan failures
- Plans with high-risk tasks (file deletions, refactors)
- Regulatory/audit requirements
- Development/experimentation phases

## 2. Clean History (Squash-Per-Phase or Per-Plan)

### Pattern A: Squash-Per-Phase

Each phase becomes a single commit:

```
phase 1: Complete Core Implementation

Tasks: 1.1, 1.2, 1.3, 1.4, 1.5
Duration: 15m 23s
Status: all completed

- task 1.1: Create auth middleware
- task 1.2: Add user model
- task 1.3: Implement login endpoint
- task 1.4: Add session management
- task 1.5: Write auth tests
```

### Pattern B: Squash-Per-Plan

Single merge commit on plan completion:

```
Plan: implement-authentication (squashed)

Completed 25 tasks across 5 phases:
- Phase 1: Core Implementation (5 tasks)
- Phase 2: Integration (6 tasks)
- Phase 3: Testing (8 tasks)
- Phase 4: Documentation (4 tasks)
- Phase 5: Deployment (2 tasks)

Duration: 2h 15m
See docs/plan-outputs/implement-authentication/ for details
```

### Advantages

| Benefit | Impact |
|---------|--------|
| **Clean main branch** | Easy to read project history |
| **Logical groupings** | Commits represent complete features |
| **PR alignment** | One commit = one PR squash merge |
| **Reduced noise** | 100 tasks -> 5 commits (phase) or 1 commit (plan) |
| **Professional appearance** | Clean history for team/public repos |
| **Simpler merges** | Fewer commits to integrate |

### Disadvantages

| Drawback | Impact | Severity |
|----------|--------|----------|
| **Lost granularity** | Can't see individual task changes | **CRITICAL** for debugging |
| **Harder rollback** | Can't revert just task 1.3 | **CRITICAL** for orchestrator |
| **Debugging difficulty** | Which task caused the bug? | Must examine large diff |
| **Incomplete phases** | Phase fails at task 3/5 - what to commit? | Breaks phase-level commits |
| **Permanent information loss** | Original commits discarded after squash | Can't recover granular history |

### Optimal for

- Public/team repositories with main branch protection
- Post-plan cleanup before merging to main
- Plans that are fully complete and verified
- Long-term project history readability
- When combined with granular history during execution

## 3. Squash Policies

### Policy A: Never Squash (Pure Granular)

**When:** Keep all task commits forever

**Pros:**
- Maximum traceability
- Perfect for auditing
- Simple (no rebase needed)

**Cons:**
- History grows unbounded
- Main branch becomes noisy
- Not suitable for team workflows

**Use case:** Solo developer, experimental project, audit requirements

### Policy B: Squash on Merge (Hybrid - RECOMMENDED)

**When:** Granular commits on feature branch -> squash when merging to main

**Workflow:**
```bash
# During plan execution (on branch plan/feature-x)
git commit -m "task 1.1: ..."  # Granular
git commit -m "task 1.2: ..."  # Granular
git commit -m "task 1.3: ..."  # Granular

# On plan completion
git checkout main
git merge --squash plan/feature-x
git commit -m "Plan: feature-x (squashed)

Completed 25 tasks...
See branch plan/feature-x for granular history"

# Preserve original branch with granular history
git tag archive/plan-feature-x plan/feature-x
git branch -D plan/feature-x
```

**Pros:**
- **Best of both worlds:** Granular during development, clean on main
- Rollback available during execution (on branch)
- Clean project history (on main)
- Debugging possible (use tag to access granular history)
- Standard GitHub workflow

**Cons:**
- Requires branch-per-plan (adds complexity)
- Granular history in tag/reflog, not main branch
- Must preserve tags to access original commits

**Use case:** DEFAULT for orchestrator system

### Policy C: Squash on Phase Complete

**When:** Task commits -> phase squash -> plan merge

**Workflow:**
```bash
# Phase 1 execution
git commit -m "task 1.1: ..."
git commit -m "task 1.2: ..."
git rebase -i HEAD~2  # Squash into phase commit

# Phase 2 execution
git commit -m "task 2.1: ..."
git commit -m "task 2.2: ..."
git rebase -i HEAD~2  # Squash into phase commit

# Result: 5 phase commits on branch
# Merge to main preserves phase granularity
```

**Pros:**
- Phase-level granularity on main (better than full squash)
- Can rollback entire phases
- Matches mental model (phases = milestones)

**Cons:**
- Lose task-level rollback
- Interactive rebase required (not automatable with `-i`)
- Partial phase completion is awkward

**Use case:** Plans with well-defined phase boundaries, lower rollback needs

### Policy D: Squash on Demand

**When:** Developer chooses per plan

**Config:**
```json
{
  "plan": "implement-feature",
  "git": {
    "history_mode": "granular" | "phase-squash" | "plan-squash"
  }
}
```

**Pros:**
- Flexible for different plan types
- Low-risk plans can use plan-squash (faster)
- High-risk plans can use granular (safer)

**Cons:**
- Inconsistent history patterns
- More configuration required
- Complex implementation

**Use case:** Advanced users, mature orchestrator system

### Automation Considerations

| Policy | Automation Complexity | Interactive Steps Required |
|--------|----------------------|---------------------------|
| Never squash | **Low** - no rebase needed | None |
| Squash on merge | **Medium** - `git merge --squash` | None (non-interactive) |
| Squash on phase | **High** - needs rebase automation | Interactive rebase or custom script |
| Squash on demand | **High** - conditional logic | Depends on choice |

**Key insight:** Avoid `git rebase -i` (interactive) in automation. Use:
- `git merge --squash` (non-interactive)
- `git reset --soft` + new commit (non-interactive)
- Custom squash script with hardcoded ranges

## 4. Hybrid Approaches

### Hybrid A: Granular on Branch + Squash on Merge (RECOMMENDED)

**Pattern:** Task commits preserved on feature branch, squashed to main

**Implementation:**
1. `/plan:set my-plan` creates branch `plan/my-plan`
2. `/plan:implement` commits each task to branch
3. `/plan:complete` offers two options:
   - `--squash`: Merge as single commit (default)
   - `--preserve-history`: Merge with all commits

**Commit preservation:**
```bash
# Before squashing, create archive tag
git tag archive/plan-my-plan plan/my-plan

# Squash merge to main
git checkout main
git merge --squash plan/my-plan
git commit -m "Plan: my-plan (squashed)"

# Delete branch but tag remains
git branch -D plan/my-plan

# Later: access granular history
git log archive/plan-my-plan
git checkout archive/plan-my-plan -- path/to/file.js
git diff archive/plan-my-plan~5 archive/plan-my-plan  # Last 5 tasks
```

**Advantages:**
- Rollback available during plan execution (on branch)
- Clean main branch (matches team workflows)
- Granular history accessible via tags (not lost)
- No rebase required (simple automation)
- Compatible with GitHub PR squash workflow

**Disadvantages:**
- Requires understanding of tags for recovery
- Granular history not in main `git log`
- Tag management needed (cleanup old archives)

**Best for:** Default orchestrator workflow (solo + team)

### Hybrid B: Keep Granular in Reflog

**Pattern:** Squash immediately, rely on reflog for recovery

**Implementation:**
```bash
# After all tasks complete
git reset --soft HEAD~100  # Undo last 100 commits (keeps changes staged)
git commit -m "Plan: my-plan (100 tasks)"

# Original commits still in reflog for 90 days
git reflog  # Shows all original task commits
```

**Advantages:**
- Clean history immediately
- No branches/tags needed
- Simple implementation

**Disadvantages:**
- Reflog expires (default 90 days)
- Less discoverable (users may not know about reflog)
- Harder to reference specific tasks
- Lost after `git gc --prune=now`

**Best for:** Short-term cleanup, solo developers

### Hybrid C: Tag-Based Checkpoints

**Pattern:** Granular commits + tags at key points

**Implementation:**
```bash
# During plan execution
git commit -m "task 1.1: ..."
git commit -m "task 1.2: ..."
# ...

# After each phase
git tag plan/my-plan/phase-1 HEAD

# After plan completion
git tag plan/my-plan/complete HEAD
```

**Advantages:**
- Checkpoints easy to find (`git tag -l "plan/*"`)
- Can rollback to phase boundaries
- Granular commits preserved
- Simple automation (tag creation)

**Disadvantages:**
- Doesn't solve noisy history
- Tag proliferation (100 plans x 5 phases = 500 tags)
- Still need squash strategy for main

**Best for:** Supplement to hybrid A, recovery points

## 5. Comparative Analysis

### Developer Experience

| Approach | Solo Dev | Team Dev | Learning Curve |
|----------|----------|----------|----------------|
| Pure granular | High (Easy rollback) | Low (Noisy PRs) | Low (Simple) |
| Phase squash | Medium (Medium rollback) | High (Good balance) | Medium (Interactive rebase) |
| Plan squash | Low (Hard rollback) | High (Clean PRs) | Low (Simple squash) |
| Hybrid A (branch+squash) | High (Best of both) | High (Clean + accessible) | Medium (Tags, branches) |

**Verdict:** Hybrid A wins for both solo and team

### Debugging and Forensics

| Approach | Find Bug Task | Rollback Single Task | Bisect Capability | Audit Trail |
|----------|--------------|---------------------|-------------------|-------------|
| Pure granular | High (`git log`) | High (`git revert`) | High (Precise) | High (Complete) |
| Phase squash | Medium (Phase level) | Low (Phase only) | Low (Phase level) | Medium (Phase level) |
| Plan squash | Low (Read diff) | Low (Full plan) | N/A | Low (Plan level) |
| Hybrid A | High (Tag branch) | High (Via tag) | High (On branch) | High (Preserved) |

**Verdict:** Pure granular and Hybrid A tie (Hybrid A via tag access)

### CI/CD Compatibility

| Approach | PR Creation | Automated Testing | Merge Conflicts | Build Time |
|----------|-------------|------------------|----------------|------------|
| Pure granular | Low (100 commits in PR) | High (Test each commit) | Low (High risk) | Medium (Each commit tested) |
| Phase squash | High (5 commits) | High (Test each phase) | Medium (Medium risk) | High (Fewer builds) |
| Plan squash | High (1 commit) | High (One test run) | High (Low risk) | High (One build) |
| Hybrid A | High (1 squashed commit) | High (Test squashed) | High (Low risk) | High (One build) |

**Verdict:** Plan squash and Hybrid A both optimal for CI/CD

## 6. Recommendations by Use Case

### Solo Developer, Experimental Project

**Recommended:** Pure Granular (commit-per-task, never squash)

**Rationale:**
- Maximum safety and rollback capability
- No team collaboration concerns
- History noise doesn't matter for solo work
- Simple implementation (no branching needed)

### Solo Developer, Production Project

**Recommended:** Hybrid A (granular on branch, squash on merge)

**Rationale:**
- Safety during development (granular commits)
- Clean main branch for portfolio/sharing
- Prepares for future team collaboration
- Best practice habits

### Team, Feature Development

**Recommended:** Hybrid A (granular on branch, squash on PR merge)

**Rationale:**
- Matches GitHub PR workflow (squash merge default)
- Clean main branch for team
- Granular history accessible for debugging
- Standard industry practice

### Team, Regulated/Audit Requirements

**Recommended:** Pure Granular + Archive Branch

**Rationale:**
- Complete audit trail required by law
- Every change must be traceable
- Rollback to any point required
- Clean main via separate archive branch

### High-Risk Plans (Deletions, Refactors)

**Recommended:** Pure Granular on branch, manual squash decision

**Rationale:**
- Maximum rollback capability during risky operations
- Can abort and restore at any task
- Decision to squash made after successful completion
- Safety over cleanliness

### Low-Risk Plans (Documentation, Analysis)

**Recommended:** Phase squash or plan squash

**Rationale:**
- Low rollback need (documentation changes are low-risk)
- Faster execution (less git overhead)
- Cleaner history appropriate for low-impact work

## 7. Recommended Default Strategy

### PRIMARY RECOMMENDATION: Hybrid A (Branch + Squash on Merge)

**Pattern:**
1. **During plan execution:** Granular commits on feature branch `plan/{plan-name}`
2. **On plan completion:** Squash merge to main, preserve branch via tag
3. **Fallback access:** Tag `archive/plan-{plan-name}` retains granular history

**Implementation workflow:**

```bash
# 1. Plan start (via /plan:set)
git checkout -b plan/implement-auth

# 2. Task execution (via /plan:implement, automatic)
git commit -m "task 1.1: Create auth middleware
Plan: implement-auth
Phase: Phase 1: Core
Duration: 34s"

git commit -m "task 1.2: Add user model
Plan: implement-auth
Phase: Phase 1: Core
Duration: 28s"
# ... (repeat for all tasks)

# 3. Plan completion (via /plan:complete)
# 3a. Create archive tag
git tag archive/plan-implement-auth plan/implement-auth

# 3b. Squash merge to main
git checkout main
git merge --squash plan/implement-auth

# 3c. Create descriptive merge commit
git commit -m "Plan: implement-auth (squashed)

Completed 25 tasks across 5 phases
Duration: 2h 15m 34s

Phases:
- Phase 1: Core Implementation (5 tasks)
- Phase 2: Integration (6 tasks)
- Phase 3: Testing (8 tasks)
- Phase 4: Documentation (4 tasks)
- Phase 5: Deployment (2 tasks)

Granular history: git log archive/plan-implement-auth
Outputs: docs/plan-outputs/implement-auth/"

# 3d. Delete feature branch (tag preserves commits)
git branch -D plan/implement-auth

# 4. Future rollback/debugging
git log archive/plan-implement-auth  # View granular history
git show archive/plan-implement-auth:path/to/file  # View file at completion
git checkout archive/plan-implement-auth -- file.js  # Restore file
git diff archive/plan-implement-auth~5 archive/plan-implement-auth  # Last 5 tasks
```

**Rationale:**

| Criterion | Score | Explanation |
|-----------|-------|-------------|
| Debugging | High | Full granular history via tag |
| Rollback | High | Per-task rollback possible during execution + via tag after |
| Clean history | High | Main branch shows one commit per plan |
| Team collaboration | High | PR shows single commit, matches squash merge workflow |
| CI/CD | High | One commit to test/build on main |
| Solo dev | High | Slightly more complex (branches, tags) but manageable |
| Audit trail | High | Complete history preserved, just not on main |
| Automation | High | No interactive rebase needed |

## 8. Summary & Decision Matrix

### Overall Ranking

| Approach | Solo Dev | Team | Debugging | History | Automation | **TOTAL** |
|----------|----------|------|-----------|---------|------------|-----------|
| Pure Granular | 4/5 | 2/5 | 5/5 | 2/5 | 5/5 | 18/25 |
| Phase Squash | 3/5 | 4/5 | 3/5 | 3/5 | 2/5 | 15/25 |
| Plan Squash | 2/5 | 5/5 | 1/5 | 5/5 | 4/5 | 16/25 |
| **Hybrid A** | 5/5 | 5/5 | 5/5 | 5/5 | 5/5 | **25/25** |

### Key Tradeoffs

| Priority | Granular Wins | Clean Wins | Hybrid A Resolution |
|----------|--------------|------------|-------------------|
| Debugging | Per-task bisect | Large diffs | Access via tag |
| Rollback | Per-task revert | All-or-nothing | During execution + tag |
| Team PRs | 100 commits | 1 commit | 1 squashed commit |
| Audit | Complete trail | Lost detail | Preserved in tag |
| Performance | Slower commits | Faster | Same as granular |

### Final Recommendation

**DEFAULT: Hybrid A (Granular on Branch + Squash on Merge)**

**Justification:**
1. Solves all Phase 0 pain points
2. Enables per-task rollback during execution
3. Provides clean main branch for teams
4. Preserves granular history for forensics
5. Automates without interactive rebase
6. Matches industry standard (GitHub squash merge)
7. Scales from solo to team workflows

**Implementation priority:**
- **Phase 1:** Per-task commits on feature branches
- **Phase 2:** Archive tagging before squash
- **Phase 3:** Automated squash on /plan:complete
- **Phase 4:** Configurable policies for advanced users

**Next steps:**
- Task 1.4: Define CI/CD integration points
- Task 2.x: Design branch-per-plan implementation
- Task 3.x: Specify commit message format (conventional commits)
- Task 4.x: Design /plan:complete merge workflow
