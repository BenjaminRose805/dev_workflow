# Task 2.2: Branch-Per-Phase Approach Analysis

## Executive Summary

**Branch-per-phase** is a hierarchical branching strategy where each phase of a plan executes on its own isolated sub-branch within a parent plan branch. While this provides maximum isolation and granular rollback capabilities, it comes with significant complexity overhead that makes it suitable only for specific high-risk scenarios.

**Key Finding:** Branch-per-phase is **NOT recommended as the default strategy**. The simpler **branch-per-plan** approach provides 90% of the benefits with 30% of the complexity. Branch-per-phase should be reserved for:
- Plans with expensive phase verification (long-running tests, infrastructure provisioning)
- Multi-developer concurrent phase work
- High-risk phases that frequently fail verification
- Regulatory environments requiring phase-level audit trails

---

## 1. Definition & Concept

### 1.1 What is Branch-Per-Phase?

Branch-per-phase creates a **three-level branch hierarchy**:

```
main (trunk)
  └── plan/implement-authentication (plan branch)
       ├── plan/implement-authentication/phase-1 (phase branch)
       ├── plan/implement-authentication/phase-2 (phase branch)
       ├── plan/implement-authentication/phase-3 (phase branch)
       └── plan/implement-authentication/phase-4 (phase branch)
```

**Key characteristics:**
1. **Plan branch** serves as integration point (analogous to main for the plan)
2. **Phase branches** isolate work for each phase
3. Tasks commit to the active phase branch
4. Phases merge to plan branch only after VERIFY passes
5. Plan merges to main only after all phases complete

### 1.2 Branch Naming Convention

**Format:** `plan/{plan-name}/phase-{N}` or `plan/{plan-name}/phase-{N}-{slug}`

**Examples:**
```bash
plan/implement-auth/phase-1              # Minimal
plan/implement-auth/phase-1-core         # With slug
plan/implement-auth/phase-2-integration  # Descriptive
```

### 1.3 Workflow Diagram

```
START PHASE 1
│
├─ git checkout plan/my-plan
├─ git checkout -b plan/my-plan/phase-1
│
├─ EXECUTE TASKS (1.1, 1.2, 1.3, ...)
│  ├─ git commit -m "task 1.1: ..."
│  ├─ git commit -m "task 1.2: ..."
│  └─ git commit -m "task 1.3: ..."
│
├─ VERIFY PHASE 1
│  │
│  ├─ SUCCESS? ───┬───────────────────────────────────┐
│  │              │                                   │
│  YES            NO                                  │
│  │              │                                   │
│  ├─ git checkout plan/my-plan                      │
│  ├─ git merge --no-ff phase-1                      │
│  ├─ git tag phase-1-complete                       │
│  └─ git branch -d plan/my-plan/phase-1             │
│                                                     │
│                 ├─ git checkout plan/my-plan        │
│                 ├─ git branch -D phase-1 ← DELETE   │
│                 ├─ git checkout -b phase-1 ← NEW    │
│                 └─ RETRY PHASE 1                    │
│                                                     │
├─ START PHASE 2 ←────────────────────────────────────┘
```

---

## 2. Pros (Benefits)

### 2.1 Maximum Phase Isolation

**Benefit:** Failed phase verification has **zero impact** on plan branch.

**Example scenario:**
- Phase 1 (core functionality) completes successfully → merged to plan branch
- Phase 2 (advanced features) fails verification → phase branch deleted
- Phase 3 (testing) can start from known-good state (phase 1 complete)
- Plan branch remains in clean state with only verified work

**Value:** **HIGH** for plans with high phase failure rates.

### 2.2 Atomic Phase Integration

**Benefit:** Phases merge to plan branch only after verification succeeds.

**Guarantees:**
- Plan branch contains only verified work
- No partial phase merges (all-or-nothing)
- Clean rollback (delete branch if verification fails)

**Value:** **HIGH** for plans with rigorous VERIFY checkpoints.

### 2.3 Granular Phase Rollback

**Benefit:** Can rollback individual phases without affecting others.

**Scenario:**
```
Plan: 5 phases
  Phase 1: ✓ merged
  Phase 2: ✓ merged
  Phase 3: ✓ merged (bug discovered later)
  Phase 4: ✓ merged
  Phase 5: [ ] in progress
```

**With branch-per-phase:**
```bash
# Phases are merge commits on plan branch
git log plan/my-plan --oneline --merges
# abc123 phase(4): Complete Phase 4
# def456 phase(3): Complete Phase 3  ← Want to rollback this
# ghi789 phase(2): Complete Phase 2

# Revert the phase 3 merge commit
git revert def456 -m 1
```

**Value:** **MEDIUM** - useful but edge case.

### 2.4 Parallel Phase Development

**Benefit:** Multiple phases can be developed concurrently (advanced use case).

**Value:** **LOW** for orchestrator (automated execution is sequential by design).

### 2.5 Clean Merge History

**Benefit:** Each phase merge creates a clear milestone in git log.

**Example git log:**
```
* abc123 (plan/auth) phase(4): Complete Phase 4: Deployment
|\
| * def456 task 4.2: Add deploy script
| * ghi789 task 4.1: Write deployment docs
|/
* jkl012 phase(3): Complete Phase 3: Testing
```

**Value:** **MEDIUM** - nice for visualization, but tags can achieve similar result.

### 2.6-2.10 Additional Benefits

- **Verification Isolation:** Run phase verification without affecting plan branch
- **Reusable Phase Checkpoints:** Phase tags serve as reusable starting points
- **Easier Code Review:** Phases can be reviewed independently as separate PRs
- **Fine-Grained Audit Trail:** Phase merge commits create clear audit events
- **Reduced Risk of Incomplete Work:** Plan branch always contains only complete phases

---

## 3. Cons (Challenges & Limitations)

### 3.1 High Branch Management Overhead

**Challenge:** Every phase requires create → work → merge → delete cycle.

**Git operations per phase:** ~5 operations

**Typical plan:** 5 phases × 5 git operations = 25+ branch operations

**Comparison:**
- **Branch-per-plan:** 3 operations total
- **Branch-per-phase:** 25+ operations

**Value:** **HIGH COST** - significantly more complex than branch-per-plan.

### 3.2 Steeper Learning Curve

**Challenge:** Users must understand three-level hierarchy.

**Mental model required:**
```
main (production code)
  ↓
plan/X (verified plan work)
  ↓
plan/X/phase-N (unverified phase work)
```

**Value:** **MEDIUM-HIGH COST** - barrier to adoption.

### 3.3 Orphaned Branch Risk

**Challenge:** Failed/abandoned phases leave orphaned branches.

**Value:** **MEDIUM COST** - maintenance burden.

### 3.4 Merge Conflict Complexity

**Challenge:** Conflicts can occur at two levels (phase → plan, plan → main).

**Value:** **MEDIUM-HIGH COST** - conflict resolution is harder with multiple merge points.

### 3.5 Tooling & Visualization Challenges

**Challenge:** Standard git tools not optimized for three-level hierarchy.

**Value:** **LOW-MEDIUM COST** - tooling exists but not optimized for this workflow.

### 3.6 Performance Overhead

**Challenge:** Branch operations add latency to orchestrator execution.

**For 5-phase plan:** ~4.5 seconds overhead

**Value:** **LOW COST** - performance impact negligible.

### 3.7 Difficult Mid-Phase Recovery

**Challenge:** If orchestrator crashes mid-phase, recovery is complex.

**Value:** **MEDIUM COST** - recovery logic more complex.

---

## 4. Complexity Assessment

### 4.1 Implementation Effort

| Component | Branch-per-plan | Branch-per-phase | Delta |
|-----------|----------------|------------------|-------|
| **Plan creation** | 2 hours | 3 hours | +1h |
| **Task execution** | 4 hours | 5 hours | +1h |
| **Phase verification** | 3 hours | 6 hours | +3h |
| **Plan switching** | 2 hours | 4 hours | +2h |
| **Rollback** | 4 hours | 8 hours | +4h |
| **Status tracking** | 3 hours | 4 hours | +1h |
| **Cleanup/maintenance** | 1 hour | 3 hours | +2h |
| **Testing** | 4 hours | 8 hours | +4h |
| **Documentation** | 2 hours | 4 hours | +2h |
| **TOTAL** | **25 hours** | **45 hours** | **+20 hours (80% more)** |

**Conclusion:** Branch-per-phase requires **nearly double** the implementation effort.

### 4.2 Mental Model Complexity

**Branch-per-plan:** 2 levels (main, plan) - simple
**Branch-per-phase:** 3 levels - complex

**Conclusion:** Branch-per-phase is **3x more complex** in mental model.

### 4.3 Git Expertise Required

**Minimum git skill level:**
- Branch-per-plan: **Intermediate**
- Branch-per-phase: **Intermediate-to-Advanced**

### 4.4 Automation Complexity

**Conclusion:** Branch-per-phase automation is **2-3x more complex** with many more edge cases.

---

## 5. Best Suited Scenarios

### 5.1 Expensive Phase Verification

**When:** Phase verification takes 10+ minutes (e.g., infrastructure provisioning, full system tests).

**Value:** **HIGH** - worth the complexity for expensive verifications.

### 5.2 High Phase Failure Rate

**When:** Phases frequently fail verification (>20% failure rate).

**Value:** **HIGH** - cleaner history when phases often fail.

### 5.3 Parallel Phase Work (Multi-Developer)

**When:** Multiple developers/agents work on independent phases simultaneously.

**Value:** **MEDIUM** - useful for team scenarios, rare for solo orchestrator.

### 5.4 Regulatory/Compliance Requirements

**When:** Must prove each phase passed verification before proceeding.

**Value:** **HIGH** - regulatory value justifies complexity.

### 5.5 NOT Suited For: Simple Plans

**When:** Plan has 1-3 phases with low failure rate.

**Conclusion:** Branch-per-phase is **NOT recommended** for plans with <5 phases or <20 tasks.

---

## 6. Comparison to Branch-Per-Plan

### 6.1 Feature Comparison Table

| Feature | Branch-per-plan | Branch-per-phase | Winner |
|---------|----------------|------------------|--------|
| **Isolation level** | Plan-level | Phase-level | Phase |
| **Rollback granularity** | Task or plan | Task, phase, or plan | Phase |
| **Implementation complexity** | Low (25 hours) | High (45 hours) | Plan |
| **Mental model** | Simple (2 levels) | Complex (3 levels) | Plan |
| **Git expertise required** | Intermediate | Advanced | Plan |
| **Branch management overhead** | Low (3 operations) | High (25+ operations) | Plan |
| **History cleanliness** | Clean with squash | Very clean | Phase |
| **Tooling support** | Good | Fair | Plan |

**Overall winner:** **Branch-per-plan** for 90% of use cases.

### 6.2 Decision Tree: When to Use Branch-Per-Phase

```
Start: Planning git workflow
│
├─ Is this a multi-developer project?
│  ├─ YES → Will phases be worked on in parallel?
│  │  ├─ YES → ✓ Consider branch-per-phase
│  │  └─ NO  → Continue below
│  └─ NO  → Continue below
│
├─ Does phase verification take >10 minutes?
│  ├─ YES → Do phases fail verification >20% of the time?
│  │  ├─ YES → ✓ Use branch-per-phase (high value)
│  │  └─ NO  → ~ Consider branch-per-phase (medium value)
│  └─ NO  → Continue below
│
├─ Are there regulatory/compliance requirements?
│  ├─ YES → ✓ Use branch-per-phase (audit trail)
│  └─ NO  → Continue below
│
├─ Does plan have <5 phases and <20 tasks?
│  ├─ YES → ✗ Use branch-per-plan (simpler)
│  └─ NO  → Continue below
│
└─ Default → ✗ Use branch-per-plan (best complexity-to-value ratio)
```

**Conclusion:** Branch-per-phase is the **right choice for <10% of plans**.

---

## 7. ASCII Branch Hierarchy Diagram

```
┌────────────────────────────────────────────────────────────────────┐
│ Git Branch Hierarchy: Branch-Per-Phase Strategy                   │
└────────────────────────────────────────────────────────────────────┘

main (production, stable)
 │
 └─ [MERGE] Plan: implement-authentication (squashed)
     │
     └─ archive/plan-implement-auth
         │
         ├─ [MERGE] phase(1): Complete Phase 1: Core Implementation
         │   └─ plan/implement-auth/phase-1 (deleted after merge)
         │
         ├─ [MERGE] phase(2): Complete Phase 2: Integration
         │   └─ plan/implement-auth/phase-2 (deleted after merge)
         │
         └─ [MERGE] phase(3): Complete Phase 3: Testing
             └─ plan/implement-auth/phase-3 (deleted after merge)


COMPARISON: Branch-Per-Plan vs Branch-Per-Phase
───────────────────────────────────────────────

BRANCH-PER-PLAN (2 levels)
main
└─ plan/implement-auth
    ├─ task 1.1: ...
    ├─ task 1.2: ...
    └─ task 3.5: ...

BRANCH-PER-PHASE (3 levels)
main
└─ plan/implement-auth
    ├─ [MERGE] phase(1)
    ├─ [MERGE] phase(2)
    └─ [MERGE] phase(3)
```

---

## 8. Final Recommendation

### 8.1 When to Use Branch-Per-Phase

**Recommended scenarios (estimated 5-10% of plans):**

1. **Expensive phase verification** (>10 min per phase)
2. **High phase failure rate** (>20% verification failures)
3. **Regulatory compliance** (audit trail requirements)
4. **Multi-developer parallel phase work** (rare)

### 8.2 When to Use Branch-Per-Plan (Default)

**Recommended for 90-95% of plans:**

1. Simple plans (<5 phases, <20 tasks)
2. Solo development
3. Fast verification (<5 min per phase)
4. Low failure rate (<10% verification failures)
5. Standard development workflow

### 8.3 Hybrid Approach (Recommended Implementation)

**Best practice:** Support both strategies with configuration option.

```json
{
  "plan": "implement-authentication",
  "git": {
    "strategy": "branch-per-plan",  // or "branch-per-phase"
    "merge_strategy": "squash",
    "archive_branches": true
  }
}
```

**Implementation priority:**
1. **Phase 1:** Implement branch-per-plan (default, 90% of use cases)
2. **Phase 2:** Add branch-per-phase support (opt-in, 10% of use cases)
3. **Phase 3:** Auto-detect when to use phase branches (smart defaults)

---

## 9. Summary & Key Takeaways

### 9.1 Core Insights

1. **Branch-per-phase is powerful but complex** (3x mental overhead, 2x implementation effort)
2. **Value depends heavily on use case** (high value for expensive verification, low value for simple plans)
3. **Branch-per-plan is better default** (90% of plans don't need phase-level isolation)
4. **Support both strategies** (configurability for advanced users)

### 9.2 Comparison at a Glance

| Aspect | Branch-per-plan | Branch-per-phase |
|--------|----------------|------------------|
| **Complexity** | ★★☆☆☆ (Simple) | ★★★★☆ (Complex) |
| **Isolation** | ★★★☆☆ (Plan-level) | ★★★★★ (Phase-level) |
| **Rollback** | ★★★★☆ (Task/plan) | ★★★★★ (Task/phase/plan) |
| **Learning curve** | ★★☆☆☆ (Easy) | ★★★★☆ (Steep) |
| **Use cases** | 90% of plans | 10% of plans |
| **Recommendation** | **DEFAULT** | **SPECIALIZED** |

### 9.3 Decision Summary

**Use branch-per-phase if:**
- Phase verification takes >10 minutes
- Phase failure rate >20%
- Regulatory compliance required
- Multi-developer parallel work needed

**Use branch-per-plan if:**
- Standard plan execution
- Solo development
- Fast verification (<5 min)
- Simple workflow preferred

**When in doubt:** Start with branch-per-plan. Upgrade to branch-per-phase only when pain points emerge.
