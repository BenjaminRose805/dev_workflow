# Task 3.2: Commit-Per-Phase Strategy Analysis

## Executive Summary

**Commit-per-phase** groups all tasks within a phase into a single commit, creating history at the phase milestone level rather than task granularity. While this provides cleaner history than commit-per-task (5 phases = 5 commits vs 100 tasks = 100 commits), it sacrifices critical debugging and rollback capabilities needed for automated orchestration.

**Key Finding:** Commit-per-phase is **NOT RECOMMENDED** as the primary strategy. The tradeoffs heavily favor either:
- **Commit-per-task** (during execution for granular rollback)
- **Squash-per-plan** (on merge to main for clean history)
- **Hybrid approach** (granular on branch + squash on merge)

**Commit-per-phase occupies an awkward middle ground:** too coarse for debugging, too granular for clean history, and too complex to automate reliably.

---

## 1. Definition: What is Commit-Per-Phase?

**Commit-per-phase** means all tasks within a single phase are combined into one commit. A plan with 5 phases and 25 tasks would have 5 commits instead of 25.

### Commit Structure Example

```
a1b2c3d phase 5: Complete Deployment
e4f5g6h phase 4: Complete Documentation
i7j8k9l phase 3: Complete Testing
m1n2o3p phase 2: Complete Integration
q4r5s6t phase 1: Complete Core Implementation
```

### Key Characteristics

- **Granularity:** Mid-level (between task and plan)
- **Commit count:** 3-10 commits per plan
- **Rollback unit:** Entire phase
- **Verification alignment:** High (commits align with VERIFY checkpoints)

---

## 2. Grouping Analysis

### When Grouping Makes Semantic Sense

| Relationship Type | Example | Good Fit? |
|------------------|---------|-----------|
| **Sequential dependency** | 1.2 requires 1.1 | YES |
| **Functional cohesion** | All tasks implement same feature | YES |
| **Verification boundary** | All tasks verified together | YES |

### When Grouping Loses Important Granularity

1. **Heterogeneous tasks in same phase** - Tasks are unrelated
2. **Large phases with independent tasks** - Can't rollback just one failed task
3. **Experimental/risky tasks mixed with safe tasks** - Lose safe work on rollback

---

## 3. Verification Gate Integration

### Ideal Pattern: Commit Only After VERIFY Passes

```bash
# Execute all phase tasks (no commits)
# VERIFY checkpoint
if VERIFY success:
  git commit -m "phase 3: Complete Testing"
else:
  git reset --hard HEAD  # Rollback all
```

### Problem: What If VERIFY Fails Mid-Phase?

| Option | Pros | Cons |
|--------|------|------|
| No commit | Clean rollback | Lost completed task work |
| Commit partial | Preserves work | Breaks "one commit per phase" |
| Hybrid (task commits + phase squash) | Best of both | More complex |

---

## 4. Pros of Commit-Per-Phase

### 4.1 Cleaner History
- 100 tasks â†’ 5 commits (vs 100 commits for per-task)

### 4.2 Logical Grouping
- Commits match milestone boundaries
- Developers think in phases

### 4.3 Easier Phase-Level Rollback
```bash
git revert e3f  # Revert entire phase 3
```

### 4.4 Less Overhead
- 5 commits vs 100 commits saves ~190 seconds

---

## 5. Cons of Commit-Per-Phase

### 5.1 Cannot Rollback Individual Tasks (CRITICAL)
- Task 3.6 has bug but committed as phase 3
- Must revert entire phase (lose 7 good tasks)

**Severity: 9/10**

### 5.2 Lost Granularity for Debugging
- git bisect points to phase, not specific task
- Must examine large diff manually

**Severity: 8/10**

### 5.3 Squashing Automation is Complex
- `git rebase -i` is interactive (NOT automatable)
- `git reset --soft` is risky (must count correctly)

**Severity: 7/10**

### 5.4 Partial Phase Completion is Awkward
- What to commit if 3/6 tasks done?
- Breaks "one commit per phase" model

**Severity: 8/10**

---

## 6. Implementation Options

| Option | Automation | Risk | Granularity Preserved | **Score** |
|--------|-----------|------|----------------------|-----------|
| A: Rebase -i | 1/10 | Med | No | **Low** |
| B: Reset --soft | 7/10 | High | No | **Medium** |
| C: Branch-per-phase | 9/10 | Low | Yes | **High** |
| D: Tags only | 10/10 | Low | Yes | **Medium** |

**Recommendation:** Option C (branch-per-phase) for best outcome.

---

## 7. Comparison with Commit-Per-Task

| Aspect | Per-Task | Per-Phase |
|--------|----------|-----------|
| **Commits per 100-task plan** | 100 | 5 |
| **Rollback granularity** | Task-level | Phase-level |
| **Debugging precision** | High | Low |
| **Automation complexity** | Low | High |
| **Risk of data loss** | Low | Medium |

### When to Prefer Each

**Per-Task:**
- Automated orchestration (need granular rollback)
- High-risk operations
- Long phases (10+ tasks)

**Per-Phase:**
- Human-driven milestone completion
- Short phases (3-5 tasks)
- Clean history preference

---

## 8. Recommendations

### 8.1 DO NOT use pure commit-per-phase

**Reasons:**
1. Loses critical granularity for debugging
2. Cannot rollback individual tasks
3. Automation is complex and risky
4. Better alternatives exist

### 8.2 Use Hybrid Approach Instead

**During plan execution:** Commit-per-task
**Phase boundaries:** Tag completion
**Plan completion:** Squash-per-plan on merge

### 8.3 If Phase-Level Commits Are Needed

Use **branch-per-phase** strategy:
- Execute tasks on phase branch (granular commits)
- Merge to plan branch on VERIFY pass (creates phase commit)
- Granular history preserved in merge parent

---

## 9. Conclusion

**Commit-per-phase is NOT RECOMMENDED as standalone strategy.**

It's an awkward middle ground:
- Not granular enough for debugging and rollback
- Not clean enough for readable history
- Complex to automate reliably

**Instead:**
- Use commit-per-task during execution
- Use phase tags for milestones
- Squash on merge to main for clean history

**Phase-level commits are best achieved as a byproduct of branch-per-phase merges**, not as a standalone squashing strategy.
