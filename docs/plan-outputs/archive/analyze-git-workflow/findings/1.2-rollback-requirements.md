# Task 1.2: Rollback Requirements Analysis

## Overview

This analysis examines rollback requirements at three granularity levels for the plan orchestration system: per-task, per-phase, and per-plan. Each level serves different failure scenarios and recovery needs.

## Executive Summary

**Key Finding:** The current system has NO automated rollback mechanism. Recovery relies on manual git commands with knowledge of commit/tag history. The documented commit-per-task workflow in `/plan:implement` is not consistently enforced, making granular rollback impossible in practice.

**Recommendation:** Implement a layered rollback strategy:
- **Per-task:** Git revert for surgical fixes (low risk, preserves history)
- **Per-phase:** Branch-based checkpoints for verification failures (medium risk, clean recovery)
- **Per-plan:** Branch deletion or reset for fundamental approach failures (high risk, requires safeguards)

---

## 1. Per-Task Rollback

### 1.1 Scenarios Requiring Task-Level Rollback

**When needed:**
- Single task produces incorrect output (e.g., broken test file, wrong implementation)
- Task introduces a bug discovered later in verification
- Task modifies wrong files due to incorrect context
- Need to retry task with different approach
- Partial completion - task started but Claude session crashed

**Current pain points:**
- No per-task commits in practice despite documentation
- Manual recovery requires knowing pre-task state
- No orchestrator-level "undo task" command

### 1.2 Git Operations for Task-Level Rollback

#### Option A: Git Revert (Recommended for Task Rollback)

**Command sequence:**
```bash
# Find the commit for the task
git log --grep="task 1.1:" --oneline -1

# Revert the specific task commit
git revert <task-commit-sha> --no-edit
```

**Pros:**
- Preserves complete history (shows task was completed then reverted)
- Safe for shared branches (forward-only history)
- Maintains commit provenance
- No risk of losing other work
- Works with conventional commits tooling

**Cons:**
- Creates noise in git history (commit + revert for failed attempts)
- Requires atomic, per-task commits (currently not enforced)
- May create merge conflicts if later tasks touched same files
- Revert commit message needs context

**Commit granularity requirement:** MUST have one commit per task. Current system fails this requirement.

#### Option B: Interactive Reset (Destructive)

**Command sequence:**
```bash
# Reset to before the task
git reset --hard HEAD~1

# OR reset to specific commit
git reset --hard <commit-before-task>
```

**Pros:**
- Clean history (failed task never existed)
- No revert noise
- Simple mental model

**Cons:**
- DESTRUCTIVE - loses all commits after reset point
- Unsafe for shared/pushed branches (requires force push)
- Loses work from subsequent tasks
- Difficult to undo the undo (need reflog knowledge)
- Cannot rollback task 3 without losing tasks 4-10

**Use case:** Only for unpushed, local-only branches when task is latest commit.

#### Option C: Selective File Checkout

**Command sequence:**
```bash
# Restore specific files from before task
git checkout <commit-before-task> -- path/to/file1.js path/to/file2.js

# Stage and commit the rollback
git add path/to/file*.js
git commit -m "rollback: Undo task 1.1 - restore files to pre-task state"
```

**Pros:**
- Surgical - only affects task's files
- Safe - doesn't touch other work
- Works without per-task commits (can use phase/branch start)
- Preserves history (new commit with restored files)

**Cons:**
- Requires knowing exact file list changed by task
- Manual process (not easily automated)
- Doesn't undo new files (only restores existing ones)
- May miss side effects (package.json, lock files)

**Use case:** Manual recovery when per-task commits don't exist.

### 1.3 Task-Specific Considerations

**Multiple tasks in flight:**
```
Phase 1:
  [x] 1.1 (committed)
  [x] 1.2 (committed)  <- Want to rollback this
  [x] 1.3 (committed)
  [x] 1.4 (committed)
```

**Problem:** Can't use `reset` without losing 1.3 and 1.4.

**Solutions:**
1. **Git revert** - Creates revert commit for 1.2, preserves 1.3-1.4
2. **Cherry-pick workflow** - Create new branch from before 1.2, cherry-pick 1.3-1.4
3. **Interactive rebase** - Remove 1.2 from history (risky, rewrites history)

**Recommendation:** Git revert is safest for this scenario.

### 1.4 Retry Strategy

**After rollback, retry options:**

```bash
# Option 1: Manual retry with /plan:implement
/plan:implement task 1.2

# Option 2: Automated retry (proposed /plan:rollback command)
/plan:rollback task 1.2 --retry

# Option 3: Skip task and continue
/plan:skip task 1.2 --reason "Blocked by external dependency"
```

**Status.json implications:**
```json
{
  "id": "1.2",
  "status": "failed",
  "attempts": [
    {
      "attemptNumber": 1,
      "startedAt": "2025-12-24T10:00:00Z",
      "failedAt": "2025-12-24T10:05:00Z",
      "rollbackCommit": "abc123",
      "failureReason": "Generated incorrect schema"
    },
    {
      "attemptNumber": 2,
      "startedAt": "2025-12-24T10:10:00Z",
      "completedAt": "2025-12-24T10:15:00Z",
      "commit": "def456"
    }
  ],
  "status": "completed"
}
```

**Key requirement:** Track rollback history so multiple attempts don't accumulate junk commits.

---

## 2. Per-Phase Rollback

### 2.1 Scenarios Requiring Phase-Level Rollback

**When needed:**
- Phase verification fails (e.g., tests don't pass, architecture violated)
- Cumulative effect of phase tasks creates problems
- Need to restart entire phase with different strategy
- Multiple related tasks failed and need coordinated redo
- Phase completion criteria not met

**From current system:**
- Phases contain 3-10 related tasks
- VERIFY checkpoints at phase boundaries
- No automatic rollback when VERIFY fails
- Manual recovery across multiple task commits

### 2.2 Git Operations for Phase-Level Rollback

#### Option A: Branch-Based Phase Isolation (Recommended)

**Workflow:**
```bash
# At phase start, create checkpoint branch
git checkout -b plan/my-plan/phase-1
# ... execute tasks 1.1, 1.2, 1.3 ...
# ... each task commits ...

# At phase verification
if verify_phase_1; then
  # Merge back to plan branch
  git checkout plan/my-plan
  git merge --no-ff plan/my-plan/phase-1 -m "phase(1): Complete Phase 1: Core Implementation"
  git branch -d plan/my-plan/phase-1
else
  # Rollback entire phase
  git checkout plan/my-plan
  git branch -D plan/my-plan/phase-1  # Delete phase branch
  # Restart phase from plan branch HEAD
fi
```

**Pros:**
- Complete isolation - phase failure doesn't affect plan branch
- Atomic integration - merge only on success
- Clean rollback - just delete branch
- Easy to retry - recreate phase branch from same point
- Parallel phase work possible (phase-1 and phase-2 branches)

**Cons:**
- Branch management overhead (create, switch, merge, delete)
- Requires discipline (always work on phase branch, not plan branch)
- Merge commits create history noise
- More complex mental model for users
- Orphaned branches if phase abandoned mid-execution

**Use case:** Medium-to-large phases (5+ tasks), when verification is rigorous.

#### Option B: Phase Tagging

**Workflow:**
```bash
# Before phase starts
git tag phase-1-start

# ... execute tasks 1.1-1.4 ...

# Phase verification fails
git reset --hard phase-1-start
git tag -d phase-1-start

# OR if verification succeeds
git tag phase-1-complete
git tag -d phase-1-start
```

**Pros:**
- Simple - just tags and reset
- No branch switching required
- Clear recovery points
- Lightweight (tags are cheap)

**Cons:**
- Destructive reset (loses all phase work)
- Unsafe for pushed commits
- Cannot recover individual task commits
- Must be on single branch (no isolation)

**Use case:** Local-only development, experimental phases.

### 2.3 Phase Rollback with Partial Success

**Scenario:**
```
Phase 2: Advanced Features
  [x] 2.1 [x] 2.2 [x] 2.3 [!] 2.4 [ ] 2.5 [ ] 2.6
```

Task 2.4 failed. Options:

**Option 1: Preserve successful tasks**
- Keep commits for 2.1-2.3
- Rollback only 2.4 (if it committed anything)
- Retry 2.4, continue with 2.5-2.6

**Option 2: Full phase rollback**
- Rollback 2.1-2.4 (even though 2.1-2.3 succeeded)
- Reason: 2.4's failure indicates design flaw affecting earlier tasks
- Restart entire phase with new approach

**Decision criteria:**
- If tasks are **independent** -> preserve successful tasks
- If tasks are **sequential/dependent** -> full rollback safer
- If verification tests **entire phase** -> full rollback required

### 2.4 Dependencies Between Tasks

**Problem:** Task 2.3 depends on 2.1 and 2.2.

If rollback 2.2:
- Must also rollback 2.3 (dependent)
- Can keep 2.1 (independent)

**Dependency graph required:**
```json
{
  "2.3": {
    "depends_on": ["2.1", "2.2"],
    "rollback_cascades": true
  }
}
```

---

## 3. Per-Plan Rollback

### 3.1 Scenarios Requiring Plan-Level Rollback

**When needed:**
- Entire plan approach is wrong (fundamental design flaw)
- Plan conflicts with concurrent work on main branch
- Plan cancelled/abandoned mid-execution
- Need to return to clean pre-plan state
- External requirements changed, plan no longer valid

**Current challenges:**
- All work on master branch (no plan isolation)
- Multiple plans executed serially on same branch
- No clear "pre-plan" marker
- Manual recovery requires knowing commit history

### 3.2 Git Operations for Plan-Level Rollback

#### Option A: Branch-Per-Plan with Delete (Recommended)

**Workflow:**
```bash
# At plan start
git checkout main
git checkout -b plan/implement-authentication

# ... execute all phases and tasks ...

# Plan completion - merge to main
git checkout main
git merge --squash plan/implement-authentication
git commit -m "plan: Complete implement-authentication plan (12 tasks across 3 phases)"
git branch -D plan/implement-authentication

# OR plan rollback - delete branch
git checkout main
git branch -D plan/implement-authentication  # All plan work discarded
```

**Pros:**
- Perfect isolation - plan work never touches main until approved
- Zero-risk rollback - just delete branch
- Can work on multiple plans in parallel (different branches)
- Clean main history (squash merge = one commit per plan)
- Easy to resume abandoned plans (branch still exists)

**Cons:**
- Requires branch discipline
- Loses per-task/phase commits after squash (but preserved in branch until deleted)
- Merge conflicts if main diverged during plan
- Orphaned branches if plan never completed

**Use case:** DEFAULT strategy for all plans.

#### Option B: Main Branch with Revert

**Workflow:**
```bash
# All work on main branch
# ... execute plan tasks, commit as you go ...

# Find first commit of plan
git log --grep="plan: Start implement-authentication" --oneline -1

# Rollback entire plan
git revert <first-commit>..HEAD
```

**Pros:**
- Simple - no branch management
- Safe - forward-only history
- Preserves all history (both work and rollback)

**Cons:**
- Messy history (N task commits + N revert commits)
- Main branch has failed work visible
- Harder to distinguish plan boundaries
- Merge conflicts between plans

**Use case:** When branch-per-plan discipline failed, manual recovery.

### 3.3 Plan Rollback with Multi-Phase Completion

**Scenario:**
```
Plan: implement-authentication (3 phases)
  Phase 1: Core Implementation [x] (completed, merged)
  Phase 2: Security Enhancements [x] (completed, merged)
  Phase 3: Integration Testing [!] (failed verification)
```

**Problem:** First 2 phases succeeded and merged to main. Phase 3 failed.

**Options:**

**Option 1: Partial rollback (phase-3 only)**
```bash
# Rollback phase 3 only
git revert <phase-3-start-commit>..HEAD

# Phases 1-2 remain in main
# Retry phase 3 or abandon it
```

**Option 2: Full plan rollback**
```bash
# Revert all 3 phases
git revert <phase-1-start-commit>..HEAD

# Requires coordinated revert of 3 phases worth of commits
```

**Recommendation:** Branch-based approach provides most flexibility.

---

## 4. Comparison Matrix

| Aspect | Per-Task Rollback | Per-Phase Rollback | Per-Plan Rollback |
|--------|-------------------|-------------------|-------------------|
| **Granularity** | Single task | 3-10 tasks | Entire plan |
| **Trigger** | Task output wrong | Verification failed | Plan approach wrong |
| **Git Operation** | `git revert <task-commit>` | `git branch -D phase-N` | `git branch -D plan/name` |
| **Risk Level** | Low | Medium | High |
| **History Impact** | +1 revert commit | No impact (branch delete) | No impact (branch delete) |
| **Requires** | Per-task commits | Phase branches | Plan branches |
| **Recovery** | Retry task | Redo phase | New plan |
| **Data Loss** | None (history preserved) | Phase work (unless backup) | Plan work (unless backup) |
| **Concurrent Safety** | Safe | Safe if isolated | Safe if isolated |
| **Implementation Complexity** | Low | Medium | Medium |

---

## 5. Recommendations by Scenario

### 5.1 Task Rollback Decision Tree

```
Task completed with bad output?
|-- YES -> Is this latest commit?
|   |-- YES -> git reset --hard HEAD~1 (simple, local only)
|   +-- NO -> git revert <task-commit> (safe, preserves history)
+-- NO -> Are files partially changed?
    +-- YES -> git checkout <before-commit> -- files... (surgical restore)
```

### 5.2 Phase Rollback Decision Tree

```
Phase verification failed?
|-- YES -> All tasks failed?
|   |-- YES -> git reset --hard phase-start-tag (full redo)
|   +-- NO -> Rollback failed tasks only (preserve successful)
+-- NO -> Using phase branches?
    |-- YES -> git branch -D plan/name/phase-N (clean delete)
    +-- NO -> git revert <phase-commits> (safe fallback)
```

### 5.3 Plan Rollback Decision Tree

```
Abandon entire plan?
|-- YES -> Pushed to remote?
|   |-- YES -> git revert <plan-commits> (safe, public)
|   +-- NO -> git branch -D plan/name (clean, local)
+-- NO -> Partial phases complete?
    |-- YES -> Keep completed phases, rollback in-progress phase
    +-- NO -> Consider plan restart from checkpoint
```

---

## 6. Implementation Requirements

### 6.1 Commit Granularity (CRITICAL)

**Current state:** Per-task commits NOT enforced.

**Required changes:**
1. **Enforce commits in /plan:implement**
2. **Commit verification after task completion**
3. **Status.json tracking of commit SHA**

### 6.2 Branch Strategy

**Hierarchy:**
```
main
  +-- plan/implement-authentication
       |-- plan/implement-authentication/phase-1
       |-- plan/implement-authentication/phase-2
       +-- plan/implement-authentication/phase-3
```

**OR flatter:**
```
main
  +-- plan/implement-authentication
       (tasks commit directly to this branch)
       (use tags for phase boundaries)
```

**Recommendation:** Flat plan branch + phase tags (simpler, fewer branches).

### 6.3 New Commands Required

**1. /plan:rollback**
```bash
# Rollback specific task
/plan:rollback task 1.2

# Rollback entire phase
/plan:rollback phase 2

# Rollback entire plan
/plan:rollback plan --confirm

# Rollback and retry
/plan:rollback task 1.2 --retry
```

**2. /plan:complete (with merge strategy)**
```bash
# Complete plan, squash merge to main
/plan:complete --merge squash

# Complete plan, keep detailed history
/plan:complete --merge merge-commit

# Complete plan, rebase onto main
/plan:complete --merge rebase
```

**3. Enhanced /plan:set**
```bash
# Switch plans with safety checks
/plan:set new-plan
# -> Check for uncommitted changes
# -> Offer to stash
# -> Switch to plan branch (create if needed)
```

### 6.4 Safety Mechanisms

**Pre-rollback checks:**
- Verify task has commit
- Check for dependent tasks
- Create backup branch before destructive operations
- Update status.json after rollback

### 6.5 History Preservation

**Backup strategy:**
```bash
# Before destructive rollback
git tag rollback-backup-$(date +%s)

# OR create backup branch
git branch backup/before-rollback-phase-2

# After confirming rollback successful
git tag -d rollback-backup-*
git branch -D backup/before-rollback-*
```

**Retention policy:**
- Keep backup tags for 7 days
- Keep backup branches until plan complete
- Archive deleted plan branches for 30 days

---

## 7. Trade-offs Summary

### 7.1 Revert vs Reset vs Branch Delete

| Approach | History Cleanliness | Safety | Flexibility | Ease of Use |
|----------|-------------------|--------|-------------|-------------|
| **git revert** | Low (noisy) | High (safe) | High (flexible) | High (easy) |
| **git reset** | High (clean) | Low (risky) | Low (limited) | Medium (complex) |
| **branch delete** | High (clean) | High (safe) | High (very flexible) | High (simple) |

**Recommendation by context:**
- **Solo dev, local work:** Branch delete (simple, clean)
- **Team, shared repo:** Git revert (safe, transparent)
- **Experimental features:** Git reset (clean, temporary)

### 7.2 Granular vs Clean History

**Granular (per-task commits):**
- Precise rollback (undo task 3 without affecting task 4)
- Audit trail (see exactly what each task changed)
- Messy history (100-task plan = 100+ commits)

**Clean (squashed):**
- Readable history (1 commit per plan or phase)
- Easy to review (git log shows high-level changes)
- Cannot rollback individual tasks
- Lost granularity (debugging harder)

**Best of both worlds:**
1. Work on plan branch with per-task commits
2. Squash merge to main on plan completion
3. Keep plan branch for N days for rollback reference
4. Delete plan branch after grace period

---

## 8. Conclusion

### Recommended Rollback Strategy

**Layered approach by granularity:**

1. **Per-Task Rollback:**
   - **Method:** `git revert <task-commit>`
   - **Requirement:** Enforce per-task commits in /plan:implement
   - **Use when:** Single task needs redo, rest of phase valid

2. **Per-Phase Rollback:**
   - **Method:** Delete phase branch OR `git reset --hard phase-start-tag`
   - **Requirement:** Phase isolation (branches or tags)
   - **Use when:** Verification failed, entire phase needs rework

3. **Per-Plan Rollback:**
   - **Method:** `git branch -D plan/name` (if not merged) OR `git revert <plan-commits>` (if merged)
   - **Requirement:** Branch-per-plan strategy
   - **Use when:** Plan approach fundamentally wrong

### Critical Prerequisites

**Must implement before rollback works:**

1. **Enforce per-task commits** (currently not enforced)
2. **Branch-per-plan strategy** (currently all on master)
3. **Commit tracking in status.json** (currently missing)
4. **Phase boundary markers** (tags or branches)
5. **Pre-rollback backups** (safety net)

### Next Steps

**Phase 1 (MVP):**
- Implement branch-per-plan in /plan:create and /plan:set
- Enforce task commits in /plan:implement
- Add /plan:rollback command for tasks

**Phase 2 (Enhanced):**
- Phase branch isolation
- Dependency-aware rollback
- Automatic backups before rollback

**Phase 3 (Advanced):**
- Conflict detection and resolution
- Concurrent plan coordination
- Rollback analytics (which tasks/phases fail most)

**Success metrics:**
- Rollback completion time < 30 seconds
- Zero data loss in rollback operations
- User can rollback any task without affecting others
- History remains readable (< 10% noise from rollback commits)
