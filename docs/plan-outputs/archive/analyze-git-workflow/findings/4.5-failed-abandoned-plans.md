# Task 4.5: Failed and Abandoned Plan Handling

## Overview

This design specifies how the plan orchestration system detects, handles, and recovers from failed and abandoned plans. It covers detection mechanisms, user notifications, recovery workflows, status updates, branch cleanup, and garbage collection.

---

## 1. Plan Lifecycle State Machine

```
CREATED → ACTIVE → COMPLETED → ARCHIVED
              ↓           ↓
           FAILED    (merge to main)
              ↓
         ABANDONED → ARCHIVED
              ↓
           STALE → ARCHIVED (auto)
```

### State Definitions

| State | Description | Branch Status |
|-------|-------------|---------------|
| CREATED | Plan file exists | No branch yet |
| ACTIVE | Tasks in progress | Branch exists |
| COMPLETED | All tasks done | Ready to merge |
| FAILED | Task failed 3+ times | Blocked |
| ABANDONED | User gave up | Pending cleanup |
| STALE | 60+ days inactive | Warning issued |
| ARCHIVED | Work preserved | Branch deleted, tag exists |

---

## 2. Failed Plans

### Detection Mechanisms

**1. Task Execution Failure (3 consecutive)**
```javascript
if (failCount >= 3) {
  updatePlanState('failed', {
    failedTaskId: taskId,
    failureCount: failCount,
    lastError: error.message
  });
  notifyUser('TASK_FAILURE_THRESHOLD', { taskId, failCount });
}
```

**2. Verification Checkpoint Failure**
```javascript
if (!verifyPhase(phaseNumber).success) {
  updatePlanState('failed', {
    failureType: 'verification',
    failedPhase: phaseNumber
  });
}
```

**3. Stuck Plan Detection (7+ days inactive)**
```javascript
// Daily cron check
if (daysSinceActivity >= 7) {
  notifyUser('PLAN_INACTIVE', { planName, daysSinceActivity });
}
```

### Recovery Options

| Option | Command | Effect |
|--------|---------|--------|
| Retry task | `/plan:retry 3.4` | Revert commit, re-execute |
| Skip task | `/plan:skip 3.4 --reason "..."` | Mark skipped, continue |
| Rollback to before | `/plan:rollback task 3.4` | Undo and reset to pending |
| Rollback phase | `/plan:rollback phase 3` | Undo entire phase |
| Abandon plan | `/plan:abandon` | Archive and cleanup |

### User Notification Format

```
⚠️  Plan Failure Detected
────────────────────────────────
Plan: implement-authentication
State: FAILED
Reason: Task 3.4 failed 3 times

Last Error:
  Build verification failed: type errors

Recovery Options:
  [R] Retry task 3.4
  [S] Skip task 3.4
  [B] Rollback to before task 3.4
  [P] Rollback entire phase 3
  [A] Abandon plan

Your choice [R/S/B/P/A]:
```

---

## 3. Abandoned Plans

### Abandonment Triggers

1. **Explicit**: User runs `/plan:abandon`
2. **Context switch**: User switches to different plan
3. **Requirements changed**: Plan becomes obsolete

### Cleanup Options

| Option | Flag | Effect |
|--------|------|--------|
| Archive (RECOMMENDED) | `--archive` | Tag preserved, branch deleted |
| Keep | `--keep` | Branch remains, marked abandoned |
| Delete | `--delete` | Permanent deletion (reflog only) |
| Salvage | `--salvage` | Cherry-pick completed tasks |

### Archive Workflow

```bash
# 1. Create archive tag with metadata
git tag -a "archive/abandoned-my-plan" plan/my-plan -m "
Plan: my-plan
Status: abandoned
Completed: 18/25 tasks (72%)
Reason: Requirements changed
Recovery: git checkout -b recovered archive/abandoned-my-plan
"

# 2. Push tag to remote
git push origin archive/abandoned-my-plan

# 3. Delete branches
git checkout main
git branch -D plan/my-plan
git push origin --delete plan/my-plan

# 4. Update status.json
{
  "planState": "archived",
  "abandonment": {
    "abandonedAt": "2025-12-24T12:00:00Z",
    "reason": "Requirements changed",
    "archiveTag": "archive/abandoned-my-plan"
  }
}
```

### Salvage Workflow

```bash
# Interactive: select tasks to keep
/plan:abandon my-plan --salvage

# Creates new branch from main
git checkout -b plan/my-plan-v2

# Cherry-picks completed tasks
git cherry-pick <commit-1> <commit-2> ...

# Archives original branch
git tag archive/abandoned-my-plan plan/my-plan
git branch -D plan/my-plan
```

---

## 4. Branch Cleanup Policies

### Stale Detection Timeline

| Days Inactive | Action |
|---------------|--------|
| 0-60 | Active (no action) |
| 60 | Warning email: "Archive or resume?" |
| 75 | Final warning: "Auto-archive in 15 days" |
| 90 | Auto-archive triggered |

### Archive Tag Retention

| Plan Type | Retention |
|-----------|-----------|
| Completed plans | 365 days |
| Abandoned (substantial work) | 180 days |
| Abandoned (minimal work) | 90 days |
| Failed plans | 30 days |
| Stale auto-archived | 90 days |

### Garbage Collection

```bash
#!/bin/bash
# Weekly cron: Sunday 3 AM

# 1. Delete expired archive tags
./scripts/cleanup-expired-tags.sh

# 2. Detect and warn stale branches
./scripts/detect-stale-branches.sh

# 3. Clean orphaned plan outputs
./scripts/cleanup-orphaned-outputs.sh

# 4. Prune git reflog (180 days)
git reflog expire --expire=180.days --all
git gc --prune=180.days
```

---

## 5. Commands

### `/plan:cleanup`

```bash
# List stale branches
/plan:cleanup --list

# Auto-cleanup all stale (dry run)
/plan:cleanup --auto --dry-run

# Execute cleanup
/plan:cleanup --auto --confirm

# Cleanup specific plan
/plan:cleanup my-old-plan --archive
```

### `/plan:archive`

```bash
# Archive current plan
/plan:archive --reason "Switching to higher priority"

# Archive with custom retention
/plan:archive my-plan --retention 180days
```

### `/plan:recover`

```bash
# List archived plans
/plan:recover --list

# Recover specific plan
/plan:recover my-old-plan
# → Creates branch from archive tag
# → Restores status.json
# → Sets state to active
```

---

## 6. Status.json Schema Extension

```json
{
  "planState": "active|completed|failed|abandoned|stale|archived",
  "planStateChangedAt": "2025-12-24T12:00:00Z",
  "planStateReason": "Optional description",
  "gitBranch": "plan/my-feature",
  "gitArchiveTag": "archive/plan-my-feature",
  "failureInfo": {
    "failedTaskId": "3.4",
    "failureCount": 3,
    "lastFailureAt": "2025-12-24T11:30:00Z",
    "lastError": "Build verification failed"
  },
  "abandonment": {
    "abandonedAt": "2025-12-24T12:00:00Z",
    "abandonedBy": "user",
    "reason": "Requirements changed",
    "salvageAction": "archive|delete|keep"
  }
}
```

---

## 7. Safety Mechanisms

### Pre-Deletion Backup

```bash
# ALWAYS create backup before destructive operations
function safeDeleteBranch() {
  # 1. Verify branch is not main/master
  # 2. Create archive tag if not exists
  # 3. Push tag to remote
  # 4. Create temporary 30-day backup tag
  # 5. Delete branch
}
```

### Confirmation for Substantial Work

```javascript
if (completedTasks >= 5 || completionPercent >= 50) {
  console.log("WARNING: This plan has substantial work");
  const confirm = prompt("Type plan name to confirm deletion:");
  if (confirm !== planName) {
    throw new Error("Deletion cancelled");
  }
}
```

### Audit Logging

```bash
# All destructive operations logged
echo "$(date)|delete|plan/my-plan|Requirements changed" >> audit.log
```

---

## 8. Implementation Priorities

### Phase 1: Basic Failure Handling
- [ ] Add `planState` to status.json
- [ ] Task failure counter
- [ ] `/plan:retry` command
- [ ] `/plan:skip` command

### Phase 2: Abandonment Workflow
- [ ] `/plan:abandon` with options
- [ ] Archive tag creation
- [ ] Salvage workflow
- [ ] Confirmation prompts

### Phase 3: Automated Cleanup
- [ ] Stale branch detection
- [ ] Notification system
- [ ] Auto-archive at 90 days
- [ ] `/plan:cleanup` command

### Phase 4: Recovery
- [ ] `/plan:recover` command
- [ ] Audit logging
- [ ] Cleanup reports

---

## Summary

### Handling Matrix

| Scenario | Detection | Action | Outcome |
|----------|-----------|--------|---------|
| Task fails 3x | Auto | Notify user | Retry/skip/abandon |
| VERIFY fails | Auto | Block phase | Rollback/fix |
| 60 days inactive | Cron | Email warning | Resume/abandon |
| 90 days inactive | Cron | Auto-archive | Branch deleted |
| User abandons | Manual | Prompt options | Archive/keep/delete |

### Key Principles

1. **No data loss**: Always archive before deletion
2. **Clear recovery paths**: Every state has exit options
3. **Automated cleanup**: Stale branches handled automatically
4. **Flexible policies**: Retention configurable per project
5. **Audit trail**: All transitions logged
