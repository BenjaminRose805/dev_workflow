# Task 6.3: Design Recovery from Interrupted Commits/Merges

## Executive Summary

Interruptions during git operations (Ctrl+C, crash, timeout) can leave the repository in an inconsistent state. This document defines **detection**, **cleanup**, and **recovery** procedures for all git operation types.

**Key Principle:** Detect inconsistent state early, clean up safely, resume from last known good state.

---

## 1. Interruption Scenarios

### 1.1 Commit Interruption

**Causes:**
- Ctrl+C during `git commit`
- Process crash during write
- Disk full during object creation
- Pre-commit hook timeout

**Symptoms:**
- `.git/index.lock` exists
- Partial commit objects
- Staged changes still present
- No new commit created

### 1.2 Merge Interruption

**Causes:**
- Ctrl+C during `git merge`
- Process crash during merge
- Out of memory
- Manual abort forgotten

**Symptoms:**
- `.git/MERGE_HEAD` exists
- Conflict markers in files
- Partial merge state
- `.git/MERGE_MSG` present

### 1.3 Rebase Interruption

**Causes:**
- Ctrl+C during `git rebase`
- Process crash
- Conflict resolution abandoned

**Symptoms:**
- `.git/rebase-merge/` directory exists
- `.git/rebase-apply/` directory exists
- Detached HEAD state
- Incomplete rebase sequence

### 1.4 Checkout Interruption

**Causes:**
- Ctrl+C during `git checkout`
- Disk full during file write

**Symptoms:**
- Mixed file states
- Partially updated working tree
- Possible data loss

### 1.5 Push Interruption

**Causes:**
- Network failure
- Ctrl+C during upload
- Server timeout

**Symptoms:**
- Partial refs updated
- Local/remote mismatch
- Pack file issues

---

## 2. State Detection

### 2.1 Comprehensive State Check

```javascript
function detectGitState() {
  const state = {
    isGitRepo: false,
    isClean: true,
    hasLockFile: false,
    mergeInProgress: false,
    rebaseInProgress: false,
    cherryPickInProgress: false,
    bisectInProgress: false,
    revertInProgress: false,
    conflicts: [],
    stashes: 0,
    issues: []
  };

  // Check if git repo
  try {
    execSync('git rev-parse --git-dir', { stdio: 'ignore' });
    state.isGitRepo = true;
  } catch {
    return state;
  }

  // Check for lock files
  const lockFiles = [
    '.git/index.lock',
    '.git/HEAD.lock',
    '.git/config.lock'
  ];

  for (const lock of lockFiles) {
    if (fs.existsSync(lock)) {
      state.hasLockFile = true;
      state.issues.push(`Lock file exists: ${lock}`);
    }
  }

  // Check for in-progress operations
  state.mergeInProgress = fs.existsSync('.git/MERGE_HEAD');
  state.rebaseInProgress =
    fs.existsSync('.git/rebase-merge') ||
    fs.existsSync('.git/rebase-apply');
  state.cherryPickInProgress = fs.existsSync('.git/CHERRY_PICK_HEAD');
  state.bisectInProgress = fs.existsSync('.git/BISECT_LOG');
  state.revertInProgress = fs.existsSync('.git/REVERT_HEAD');

  // Check for conflicts
  try {
    const status = execSync('git status --porcelain').toString();
    const conflictLines = status.split('\n').filter(l => l.startsWith('UU'));
    state.conflicts = conflictLines.map(l => l.substring(3));
  } catch {}

  // Check stash count
  try {
    const stashList = execSync('git stash list').toString();
    state.stashes = stashList.split('\n').filter(Boolean).length;
  } catch {}

  // Check working tree
  try {
    execSync('git diff --quiet');
    execSync('git diff --cached --quiet');
  } catch {
    state.isClean = false;
  }

  return state;
}
```

### 2.2 State Summary Display

```
Git State Check
═══════════════════════════════════

Repository:     /home/user/project
Current Branch: plan/my-plan
HEAD:           abc1234 "Latest commit message"

Status:
  ✓ No lock files
  ⚠ Merge in progress
  ✓ No rebase in progress
  ⚠ 2 unresolved conflicts

Conflicts:
  • src/lib/auth.ts
  • src/routes/api.ts

Stashes: 3

Recommended Action:
  Complete or abort the merge before continuing.
  Run: git merge --abort
```

---

## 3. Lock File Cleanup

### 3.1 Stale Lock Detection

```javascript
function isLockFileStale(lockPath) {
  try {
    const stats = fs.statSync(lockPath);
    const ageMs = Date.now() - stats.mtimeMs;

    // Lock files older than 10 minutes are likely stale
    const STALE_THRESHOLD_MS = 10 * 60 * 1000;

    return ageMs > STALE_THRESHOLD_MS;
  } catch {
    return false;
  }
}
```

### 3.2 Safe Lock Removal

```javascript
async function cleanupLockFiles() {
  const locks = [
    { path: '.git/index.lock', critical: true },
    { path: '.git/HEAD.lock', critical: true },
    { path: '.git/config.lock', critical: false },
    { path: '.git/refs/heads/*.lock', critical: false }
  ];

  for (const lock of locks) {
    const files = glob.sync(lock.path);

    for (const file of files) {
      if (!isLockFileStale(file)) {
        console.log(`⚠ Lock file is recent, may be in use: ${file}`);
        console.log('  Created: ' + fs.statSync(file).mtime);
        continue;
      }

      if (lock.critical) {
        console.log(`Removing stale lock: ${file}`);
        fs.unlinkSync(file);
      } else {
        console.log(`Found stale lock (manual removal recommended): ${file}`);
      }
    }
  }
}
```

### 3.3 User Prompt for Lock Removal

```
⚠ Lock file detected: .git/index.lock

This lock file is 45 minutes old and likely stale.

Options:
  [R] Remove lock file and continue
  [W] Wait and check again
  [A] Abort

A running git process may have created this lock.
Check with: ps aux | grep git
```

---

## 4. Operation-Specific Recovery

### 4.1 Merge Recovery

**State:** `.git/MERGE_HEAD` exists

```javascript
async function recoverFromMerge() {
  const mergeHead = fs.readFileSync('.git/MERGE_HEAD', 'utf8').trim();
  const mergeMsg = fs.existsSync('.git/MERGE_MSG')
    ? fs.readFileSync('.git/MERGE_MSG', 'utf8')
    : 'Unknown merge';

  console.log('Merge in progress detected');
  console.log(`  Merging: ${mergeHead.substring(0, 8)}`);
  console.log(`  Message: ${mergeMsg.split('\n')[0]}`);

  // Check for conflicts
  const conflicts = getConflictFiles();

  if (conflicts.length === 0) {
    console.log('\nNo conflicts detected. Merge can be completed.');
    console.log('  Run: git commit');
    return { action: 'complete' };
  }

  console.log(`\nConflicts in ${conflicts.length} files:`);
  for (const file of conflicts) {
    console.log(`  • ${file}`);
  }

  console.log('\nOptions:');
  console.log('  1. Resolve conflicts and run: git add <files> && git commit');
  console.log('  2. Abort merge: git merge --abort');

  return { action: 'user_decision', conflicts };
}
```

### 4.2 Rebase Recovery

**State:** `.git/rebase-merge/` or `.git/rebase-apply/` exists

```javascript
async function recoverFromRebase() {
  const isInteractive = fs.existsSync('.git/rebase-merge');
  const isNonInteractive = fs.existsSync('.git/rebase-apply');

  if (isInteractive) {
    const todoPath = '.git/rebase-merge/git-rebase-todo';
    const donePath = '.git/rebase-merge/done';

    const todo = fs.readFileSync(todoPath, 'utf8');
    const done = fs.existsSync(donePath)
      ? fs.readFileSync(donePath, 'utf8')
      : '';

    const remaining = todo.split('\n').filter(l => l && !l.startsWith('#')).length;
    const completed = done.split('\n').filter(l => l && !l.startsWith('#')).length;

    console.log('Interactive rebase in progress');
    console.log(`  Completed: ${completed} commits`);
    console.log(`  Remaining: ${remaining} commits`);
  }

  console.log('\nOptions:');
  console.log('  Continue: git rebase --continue');
  console.log('  Skip:     git rebase --skip');
  console.log('  Abort:    git rebase --abort');

  return { action: 'user_decision', type: 'rebase' };
}
```

### 4.3 Cherry-Pick Recovery

**State:** `.git/CHERRY_PICK_HEAD` exists

```javascript
async function recoverFromCherryPick() {
  const cherryPickHead = fs.readFileSync('.git/CHERRY_PICK_HEAD', 'utf8').trim();

  console.log('Cherry-pick in progress');
  console.log(`  Commit: ${cherryPickHead.substring(0, 8)}`);

  // Get commit info
  const commitInfo = execSync(
    `git log -1 --format="%s" ${cherryPickHead}`
  ).toString().trim();
  console.log(`  Message: ${commitInfo}`);

  console.log('\nOptions:');
  console.log('  Continue: git cherry-pick --continue');
  console.log('  Abort:    git cherry-pick --abort');

  return { action: 'user_decision', type: 'cherry-pick' };
}
```

---

## 5. Automatic Recovery Procedures

### 5.1 Safe Auto-Recovery Matrix

| State | Auto-Recovery? | Action | Risk |
|-------|---------------|--------|------|
| Stale index.lock | YES | Remove lock | LOW |
| Merge (no conflicts) | NO | User must commit | MEDIUM |
| Merge (with conflicts) | NO | User must resolve | HIGH |
| Rebase in progress | NO | User must decide | HIGH |
| Dirty working tree | NO | User must decide | MEDIUM |
| Detached HEAD | NO | User must decide | MEDIUM |

### 5.2 Auto-Recovery Function

```javascript
async function attemptAutoRecovery(state) {
  const recovered = [];
  const needsUser = [];

  // Auto-recover: stale lock files
  if (state.hasLockFile) {
    const cleaned = await cleanupStaleLocks();
    if (cleaned) {
      recovered.push('Removed stale lock files');
    } else {
      needsUser.push('Lock files may be in use');
    }
  }

  // Cannot auto-recover: merge in progress
  if (state.mergeInProgress) {
    needsUser.push('Merge in progress - must complete or abort');
  }

  // Cannot auto-recover: rebase in progress
  if (state.rebaseInProgress) {
    needsUser.push('Rebase in progress - must continue, skip, or abort');
  }

  // Cannot auto-recover: conflicts
  if (state.conflicts.length > 0) {
    needsUser.push(`${state.conflicts.length} unresolved conflicts`);
  }

  return { recovered, needsUser };
}
```

---

## 6. Recovery Command: /plan:recover

### 6.1 Command Specification

```bash
/plan:recover [--auto] [--abort-all]
```

**Behavior:**
1. Detect git state
2. Report issues found
3. Attempt safe auto-recovery
4. Guide user through remaining issues
5. Verify recovery complete

### 6.2 Implementation Outline

```javascript
async function runRecovery(options) {
  console.log('Plan Recovery Tool');
  console.log('═'.repeat(50));

  // Step 1: Detect state
  const state = detectGitState();
  displayState(state);

  if (isClean(state)) {
    console.log('\n✓ Repository is in a clean state. No recovery needed.');
    return { success: true };
  }

  // Step 2: Auto-recovery
  const { recovered, needsUser } = await attemptAutoRecovery(state);

  if (recovered.length > 0) {
    console.log('\nAuto-recovered:');
    for (const item of recovered) {
      console.log(`  ✓ ${item}`);
    }
  }

  // Step 3: User intervention needed
  if (needsUser.length > 0) {
    console.log('\nRequires manual intervention:');
    for (const item of needsUser) {
      console.log(`  ⚠ ${item}`);
    }

    if (options.abortAll) {
      await abortAllOperations(state);
    } else {
      displayRecoveryGuidance(state);
    }
  }

  // Step 4: Verify
  const finalState = detectGitState();
  return { success: isClean(finalState), state: finalState };
}
```

### 6.3 Recovery Guidance

```
╔═══════════════════════════════════════════════════════════════╗
║  RECOVERY GUIDANCE                                             ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                 ║
║  Issue: Merge in progress with 2 conflicts                     ║
║                                                                 ║
║  Option A: Complete the merge                                  ║
║    1. Edit conflicting files:                                  ║
║       • src/lib/auth.ts                                        ║
║       • src/routes/api.ts                                      ║
║    2. Remove conflict markers (<<<<, ====, >>>>)               ║
║    3. Stage resolved files: git add <files>                    ║
║    4. Commit: git commit                                       ║
║                                                                 ║
║  Option B: Abort the merge                                     ║
║    git merge --abort                                           ║
║    (Returns to state before merge started)                     ║
║                                                                 ║
║  After recovery, run /plan:status to continue.                 ║
║                                                                 ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## 7. State Persistence

### 7.1 Pre-Operation Snapshot

Before any git operation, save state:

```javascript
function saveOperationState(operation, context) {
  const state = {
    operation,
    startedAt: new Date().toISOString(),
    currentBranch: getCurrentBranch(),
    headCommit: getHeadCommit(),
    dirtyFiles: getDirtyFiles(),
    context
  };

  const statePath = '.git/orchestrator-state.json';
  fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

  return state;
}
```

### 7.2 State File Schema

```json
{
  "operation": "commit",
  "startedAt": "2025-12-24T15:30:00Z",
  "currentBranch": "plan/my-plan",
  "headCommit": "abc1234567890",
  "dirtyFiles": [
    "src/lib/auth.ts",
    "src/routes/api.ts"
  ],
  "context": {
    "taskId": "2.3",
    "batchId": "batch-5",
    "planPath": "docs/plans/my-plan.md"
  }
}
```

### 7.3 Recovery from State File

```javascript
function recoverFromStateFile() {
  const statePath = '.git/orchestrator-state.json';

  if (!fs.existsSync(statePath)) {
    return null;
  }

  const state = JSON.parse(fs.readFileSync(statePath, 'utf8'));

  // Check if operation was interrupted
  const elapsed = Date.now() - new Date(state.startedAt).getTime();
  const MAX_OPERATION_TIME = 5 * 60 * 1000; // 5 minutes

  if (elapsed > MAX_OPERATION_TIME) {
    console.log('Found interrupted operation state:');
    console.log(`  Operation: ${state.operation}`);
    console.log(`  Started: ${state.startedAt}`);
    console.log(`  Task: ${state.context.taskId}`);

    return state;
  }

  return null;
}
```

---

## 8. Integration with Orchestrator

### 8.1 Pre-Session Check

```python
# In plan_orchestrator.py

def pre_session_check(self) -> bool:
    """Check for and handle interrupted operations."""
    state = self.detect_git_state()

    if state.has_issues:
        self.logger.warning("Git state issues detected")

        if self.use_tui:
            self.tui.set_status("⚠ Recovery needed")

        # Attempt auto-recovery
        recovered = self.attempt_auto_recovery(state)

        if not recovered:
            self.logger.error("Manual recovery required")
            return False

    return True
```

### 8.2 Post-Session Cleanup

```python
def post_session_cleanup(self):
    """Clean up after session, handle any partial state."""
    # Remove operation state file
    state_file = '.git/orchestrator-state.json'
    if os.path.exists(state_file):
        os.remove(state_file)

    # Check for any lingering issues
    final_state = self.detect_git_state()
    if final_state.has_issues:
        self.logger.warning(f"Session ended with git issues: {final_state.issues}")
```

### 8.3 Crash Recovery

```python
def handle_crash_recovery(self):
    """Called on orchestrator startup after crash."""
    state = self.recover_from_state_file()

    if state:
        print(f"Recovering from interrupted {state['operation']}")
        print(f"Task: {state['context']['taskId']}")

        # Mark task as failed (can be retried)
        self.mark_task_failed(
            state['context']['taskId'],
            f"Interrupted during {state['operation']}"
        )

        # Clean up git state
        self.cleanup_interrupted_operation(state)
```

---

## 9. Testing Recovery

### 9.1 Simulated Interruption Tests

```javascript
describe('Git Recovery', () => {
  it('should recover from stale index.lock', async () => {
    // Create stale lock
    fs.writeFileSync('.git/index.lock', '');
    await sleep(11 * 60 * 1000); // Make it stale

    const result = await runRecovery({ auto: true });
    expect(result.success).toBe(true);
    expect(fs.existsSync('.git/index.lock')).toBe(false);
  });

  it('should detect merge in progress', async () => {
    // Simulate merge state
    fs.writeFileSync('.git/MERGE_HEAD', 'abc123');
    fs.writeFileSync('.git/MERGE_MSG', 'Merge branch main');

    const state = detectGitState();
    expect(state.mergeInProgress).toBe(true);
  });
});
```

---

## 10. Summary

### Recovery Action Matrix

| Scenario | Detection | Auto-Recovery | Manual Steps |
|----------|-----------|---------------|--------------|
| Stale lock | File age > 10min | Remove file | None |
| Merge (clean) | MERGE_HEAD, no conflicts | No | `git commit` |
| Merge (conflicts) | MERGE_HEAD + UU status | No | Resolve + commit |
| Rebase | rebase-merge/ dir | No | continue/skip/abort |
| Cherry-pick | CHERRY_PICK_HEAD | No | continue/abort |
| Crash recovery | State file + age | Partial | Mark failed + cleanup |

### Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| State file before operations | Enables crash recovery |
| Conservative auto-recovery | Only safe actions automated |
| Detailed guidance | Users need clear steps |
| Abort option always available | Escape hatch for complex situations |

### New Commands

- `/plan:recover` - Detect and recover from interrupted state
- `node scripts/status-cli.js git-state` - Show detailed git state

**Estimated Effort:** 4-6 hours for complete implementation.
