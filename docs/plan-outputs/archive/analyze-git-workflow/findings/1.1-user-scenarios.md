# Task 1.1: User Scenarios Analysis

## Overview

This analysis documents three primary user scenarios that a git workflow strategy must support in the plan orchestration system. Each scenario has distinct requirements, pain points, and workflow patterns that will inform the design of git integration.

## Scenario 1: Solo Developer

### Profile

**Context:**
- Single developer working on personal or private projects
- Full control over repository and git history
- No external collaboration or code review requirements
- Often working on multiple plans/features simultaneously

**Examples:**
- Personal tool development (like this orchestrator itself)
- Experimentation and prototyping
- Learning projects
- Internal utilities and scripts

### Typical Workflow Patterns

1. **Rapid Iteration**
   - Frequent small changes without ceremony
   - May want to try multiple approaches to same problem
   - Often switches between different tasks/plans
   - Values speed over process

2. **Checkpoint-Based Work**
   - Creates manual checkpoints before risky operations
   - Uses git as "undo" mechanism more than collaboration tool
   - May batch multiple related tasks into single commit
   - History primarily for personal reference

3. **Branch Usage** (Variable)
   - **Conservative**: Works mainly on master/main
   - **Organized**: Uses branches for different features/experiments
   - **Pragmatic**: Branches for risky changes only

### Git Feature Requirements

| Feature | Priority | Rationale |
|---------|----------|-----------|
| Automatic commits per task | MEDIUM | Safety net, but solo dev may prefer manual control |
| Branch per plan | LOW-MEDIUM | Nice for organization, not required for solo work |
| Clean history (squashing) | LOW | Solo dev often doesn't care about history cleanliness |
| Rollback commands | HIGH | Essential for recovering from mistakes |
| PR workflow | NONE | No code review needed |
| Conflict resolution | LOW | Rare when working alone |
| Git hooks integration | MEDIUM | Useful for automation, but can be bypassed |

### Commit Granularity Preferences

**Options** (Solo dev might want choice):
1. **Per-task commits** (default)
   - Automatic safety checkpoints
   - Easy rollback to specific task
   - Granular history for debugging

2. **Per-phase commits**
   - Less clutter in history
   - Logical grouping of related work
   - Fewer commits to manage

3. **Manual commits only**
   - Full control over when to commit
   - Can batch work as desired
   - More flexible but risky

**Recommendation**: Configurable, default to per-task with option to disable

### Merge/Integration Preferences

- **Default**: Fast-forward merges (if using branches)
- **History**: Linear preferred, but not critical
- **Squashing**: Optional, typically not needed

### Rollback Needs

| Granularity | Priority | Use Case |
|-------------|----------|----------|
| Task-level rollback | HIGH | "That task broke something, undo just that change" |
| Phase-level rollback | MEDIUM | "Phase 2 was wrong approach, back to Phase 1" |
| Plan-level rollback | HIGH | "Abandon entire plan, restore to before I started" |
| File-level selective rollback | MEDIUM | "Keep most changes but revert this one file" |

### Pain Points with Existing Automation

**From analysis of current system**:

1. **No automatic commits in practice**
   - implement.md documents workflow, but not followed
   - Easy to lose work if orchestrator crashes
   - Manual checkpoint tasks required (cleanup-deprecated-code plan)

2. **Branch isolation not enforced**
   - All work on master creates risk
   - Can't experiment safely
   - Hard to context-switch between plans

3. **No structured rollback**
   - Must manually use git commands
   - Requires knowing commit hashes/tags
   - No orchestrator-level "undo" command

4. **Lost work risk**
   - Interrupted execution leaves uncommitted changes
   - No auto-stash on plan switching
   - Status tracking doesn't guarantee git safety

### Ideal Workflow

```bash
# Start new plan - creates branch automatically
/plan:set feature-x
# -> git checkout -b plan/feature-x (if not exists)

# Execute tasks - automatic commits after each
/plan:implement 1.1
# -> Task completes
# -> git add -A && git commit -m "task 1.1: ..." (automatic)

# Switch to different plan - handles uncommitted work
/plan:set urgent-fix
# -> Checks for uncommitted changes
# -> Offers: [Commit] [Stash] [Cancel]
# -> git checkout plan/urgent-fix

# Rollback a mistake
/plan:rollback task 2.3
# -> git revert <commit-for-task-2.3>
# -> Updates status.json to mark task as pending

# Complete plan - merge workflow
/plan:complete
# -> git checkout master
# -> git merge --ff plan/feature-x (or squash if preferred)
# -> Cleanup branch (optional)
```

---

## Scenario 2: Team Developer

### Profile

**Context:**
- Multiple developers working on same repository
- Shared codebase with branch protection rules
- Code review required (pull requests)
- CI/CD pipeline integration
- Need visibility into teammates' work

**Examples:**
- Product development teams
- Enterprise software projects
- Collaborative open source projects (core team)
- Consulting/agency development

### Typical Workflow Patterns

1. **Branch-Based Development**
   - Feature branches required for code review
   - Branch protection on main/master
   - PR workflow is mandatory
   - Multiple developers may work on related plans

2. **Review-Centric Process**
   - All changes reviewed before merge
   - Clean, understandable commits required
   - Commit messages must be informative
   - History matters for team understanding

3. **Coordination Needs**
   - Avoid conflicts on shared files
   - Visibility into what others are doing
   - Integration testing before merge
   - Synchronization with CI/CD

### Git Feature Requirements

| Feature | Priority | Rationale |
|---------|----------|-----------|
| Automatic commits per task | HIGH | Required for reviewable units of work |
| Branch per plan | CRITICAL | Mandatory for PR workflow |
| Clean history (squashing) | HIGH | Makes review easier, cleaner main branch |
| Rollback commands | HIGH | Team needs to undo merged work safely |
| PR workflow integration | CRITICAL | Core to team collaboration |
| Conflict resolution | CRITICAL | Common with multiple developers |
| Git hooks integration | HIGH | Enforce standards, run linters/tests |
| Conventional commits | HIGH | Standardize messages across team |

### Commit Granularity Preferences

**Required**: Per-task commits
- Each task is reviewable unit
- CI runs per task commit
- Easy to identify what broke tests
- Clear attribution of changes

**Commit Message Standards**:
```
task(1.1): Create authentication middleware

Plan: implement-authentication
Phase: Phase 1: Core Implementation
Assignee: @developer

- Implemented JWT validation
- Added middleware tests
- Updated API documentation
```

### Merge/Integration Preferences

**Branch Strategy**: Plan per branch
```
main (protected)
  |-- plan/feature-auth      <- PR #123 (in review)
  |-- plan/refactor-api      <- PR #124 (draft)
  +-- plan/add-logging       <- Working (no PR yet)
```

**Merge Strategy**: Squash merge preferred
- One commit per plan on main branch
- Preserves task-level history in branch
- Clean main branch history
- Easy to revert entire plan if needed

**Example**:
```bash
# During development: 15 task commits in plan/feature-auth
git log plan/feature-auth --oneline
# a1b2c3d task 1.5: Add logout endpoint
# e4f5g6h task 1.4: Add refresh token logic
# i7j8k9l task 1.3: Create JWT middleware
# ... (12 more)

# After squash merge to main: single commit
git log main --oneline
# m1n2o3p Plan: Implement authentication system (15 tasks)
```

### PR Creation Requirements

**Automatic PR Creation**:
```bash
/plan:complete
# -> Checks all tasks completed
# -> Commits any uncommitted changes
# -> Creates PR using gh CLI
```

### Rollback Needs

| Scenario | Priority | Solution |
|----------|----------|----------|
| Rollback merged plan | CRITICAL | `git revert <merge-commit>` + status cleanup |
| Rollback task in PR | HIGH | Amend/rebase before merge |
| Fix conflicts before merge | CRITICAL | Rebase on main, resolve conflicts |
| Rollback failed deployment | CRITICAL | Quick revert of merge commit |

### CI/CD Integration Requirements

**Required Hooks**:

1. **On Push to Plan Branch**:
   - Run tests for changed code
   - Run linters
   - Build artifacts
   - Update PR with status

2. **On PR Creation**:
   - Run full test suite
   - Check code coverage
   - Security scanning
   - Dependency analysis

3. **Before Merge**:
   - All checks must pass
   - Required reviews met
   - No merge conflicts
   - Branch up to date with main

---

## Scenario 3: Open Source Contributor

### Profile

**Context:**
- Contributing to external repositories
- Must follow project's git conventions
- Fork-based workflow
- Unknown/variable review timeline
- May need to update PR multiple times

**Examples:**
- Contributing bug fixes to libraries
- Adding features to open source tools
- Documentation improvements
- Responding to issues in public repos

### Typical Workflow Patterns

1. **Fork-Based Development**
   - Fork the upstream repository
   - Clone personal fork
   - Create branch for contribution
   - Push to personal fork
   - Create PR to upstream

2. **Convention Following**
   - Must match project's commit style
   - May require specific branch naming
   - Squashing often required before merge
   - Sign-off or DCO may be required

3. **Iterative Review Process**
   - PR may require multiple revisions
   - Force-push updates common
   - Rebase on upstream changes
   - Address review comments

### Git Feature Requirements

| Feature | Priority | Rationale |
|---------|----------|-----------|
| Automatic commits per task | MEDIUM | Helpful for WIP, but may need squashing |
| Branch per plan | HIGH | Required for PR isolation |
| Clean history (squashing) | CRITICAL | Most projects require clean commits |
| Rollback commands | HIGH | Easy iteration on PR feedback |
| Fork workflow support | CRITICAL | Different remote structure |
| Rebase support | CRITICAL | Keep PR up to date with upstream |
| Commit message customization | HIGH | Match project conventions |
| GPG signing | MEDIUM | Some projects require signed commits |

### Fork Workflow Considerations

**Remote Structure**:
```bash
# Upstream (original repo)
git remote -v
upstream  https://github.com/original/repo.git (fetch)
upstream  https://github.com/original/repo.git (push)

# Origin (personal fork)
origin    https://github.com/contributor/repo.git (fetch)
origin    https://github.com/contributor/repo.git (push)
```

**Branch Strategy**:
```
upstream/main (can't push)
  | fetch
fork/main (keep in sync)
  | branch
fork/plan/fix-bug-123 (work here)
  | push
origin/plan/fix-bug-123
  | PR
upstream/main (eventually merged)
```

### Commit Granularity Preferences

**During Development**: Per-task commits
- Track progress
- Easy to iterate
- Can rollback individual tasks

**Before PR Submission**: Squash to clean commits
- Follow project's contribution guidelines
- May need single commit per PR
- Or logical commits (e.g., "Add feature" + "Add tests" + "Update docs")

### Project Convention Matching

**Common Requirements**:

1. **Conventional Commits**:
   ```
   feat: add support for X
   fix: resolve issue with Y
   docs: update README
   test: add tests for Z
   ```

2. **Sign-off (DCO)**:
   ```
   git commit -s

   # Results in:
   Signed-off-by: Contributor Name <email@example.com>
   ```

3. **Reference Issues**:
   ```
   fix: resolve timeout in connection pool

   Fixes #123
   Closes #456
   ```

4. **GPG Signing**:
   ```
   git commit -S
   # Requires GPG key setup
   ```

---

## Cross-Scenario Comparison

### Summary Matrix

| Feature | Solo Dev | Team Dev | OSS Contributor |
|---------|----------|----------|-----------------|
| **Branch per plan** | Nice-to-have | Required | Required |
| **Auto commits** | Optional | Required | For WIP only |
| **Clean history** | Not important | Important | Critical |
| **PR workflow** | Not needed | Required | Required |
| **Squashing** | Rare | Common | Always |
| **Commit conventions** | Flexible | Team standard | Project standard |
| **Conflict resolution** | Rare | Common | Common |
| **Fork support** | Never | Rare | Always |
| **Rebase support** | Rare | Sometimes | Common |
| **GPG signing** | Optional | Sometimes | Sometimes |

### Workflow Complexity

```
Solo Developer:     ##........ (2/10) - Simple, flexible
Team Developer:     ######.... (6/10) - Structured, coordinated
OSS Contributor:    ########.. (8/10) - Strict, convention-heavy
```

### Configuration Requirements

**Solo Developer**:
```yaml
git_workflow:
  auto_commit: true          # Can be disabled
  branch_per_plan: false     # Can work on main
  commit_template: simple    # task {id}: {description}
  merge_strategy: fast-forward
  require_pr: false
```

**Team Developer**:
```yaml
git_workflow:
  auto_commit: true          # Enforced
  branch_per_plan: true      # Required
  commit_template: conventional  # Standardized
  merge_strategy: squash
  require_pr: true
  pr_reviewers: [team-leads]
  ci_required: true
```

**OSS Contributor**:
```yaml
git_workflow:
  auto_commit: true          # For WIP
  branch_per_plan: true      # Required
  commit_template: project   # Detect from repo
  merge_strategy: squash     # Before PR
  require_pr: true
  fork_workflow: true
  upstream_remote: upstream
  sign_commits: detect       # From project config
  reference_issues: true
```

---

## Key Insights for Git Workflow Design

### 1. Configuration Over Convention

The orchestrator must support **multiple workflow modes** rather than enforcing one approach:

- **Default mode**: Reasonable for all scenarios (branch per plan, auto commits)
- **Solo mode**: Relaxed rules, more flexibility
- **Team mode**: Enforced standards, PR workflow
- **Fork mode**: OSS contribution patterns

### 2. Progressive Enhancement

Start simple, add complexity as needed:

1. **Phase 1**: Basic auto-commits and branch per plan
2. **Phase 2**: PR workflow and squashing
3. **Phase 3**: Fork support and convention detection

### 3. Safety First, Convenience Second

All scenarios need:
- Automatic checkpoints (commits)
- Easy rollback mechanisms
- Clear state management
- No data loss on interruption

### 4. Commit Granularity Trade-offs

| Granularity | Solo Pro | Solo Con | Team Pro | Team Con | OSS Pro | OSS Con |
|-------------|----------|----------|----------|----------|---------|---------|
| **Per-task** | Safe rollback | Messy history | Reviewable units | Too granular | Good WIP tracking | Must squash |
| **Per-phase** | Cleaner history | Lost granularity | Logical grouping | Too coarse | Easier to review | Less trackable |
| **Manual** | Full control | Easy to forget | Not viable | - | Not viable | - |

**Recommendation**: Default to per-task with tooling to squash for team/OSS workflows

### 5. Context Awareness

Orchestrator should detect workflow context:
- Check for `CODEOWNERS` -> team mode
- Check for upstream remote -> fork mode
- Check for branch protection -> team mode
- Check for `.github/CONTRIBUTING.md` -> project conventions

---

## Recommendations for Implementation

### Priority 1: Universal Features (All Scenarios)

1. **Automatic commits after task completion**
   - Configurable (can disable for solo dev)
   - Safe default for preventing data loss

2. **Branch per plan**
   - Isolation for concurrent work
   - Required for team/OSS, optional for solo

3. **Rollback commands**
   - `/plan:rollback task 1.1`
   - `/plan:rollback phase 2`
   - `/plan:rollback plan` (to initial state)

4. **Git state validation**
   - Check clean state before plan operations
   - Warn about uncommitted changes
   - Offer stash/commit before switch

### Priority 2: Team Features

5. **PR workflow integration**
   - `/plan:complete` creates PR
   - Template PR body with task summary
   - Link to findings and test results

6. **Squash merge support**
   - Combine task commits for clean history
   - Interactive squash with preview
   - One commit per plan on main

7. **Conventional commit format**
   - Standardized messages
   - Tooling to enforce conventions
   - Integration with changelog generation

### Priority 3: OSS Contributor Features

8. **Fork workflow support**
   - Upstream/origin remote management
   - Sync with upstream
   - Rebase workflow

9. **Convention detection**
   - Analyze project's commit patterns
   - Apply project-specific templates
   - Support DCO, GPG signing, issue linking

10. **Squashing tooling**
    - Prepare PR mode
    - Interactive commit combining
    - Preview before force push

---

## Conclusion

The three user scenarios--solo developer, team developer, and open source contributor--have overlapping but distinct needs. A successful git workflow integration must:

1. **Support all three** with configuration rather than separate implementations
2. **Default to safe practices** (auto-commits, branches) that work for everyone
3. **Provide flexibility** for solo developers to opt out of overhead
4. **Enforce standards** for team workflows where coordination is critical
5. **Adapt to project norms** for open source contributions

The next phase of requirements gathering should translate these scenario insights into specific technical requirements and decision criteria for the git workflow design.
