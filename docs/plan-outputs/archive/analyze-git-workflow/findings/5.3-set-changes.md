# Task 5.3: Map Changes Needed in /plan:set

## Executive Summary

**Current State:** The `/plan:set` command selects plans, writes to `.claude/current-plan.txt`, and initializes status tracking. It has no git integration.

**Recommendation:** `/plan:set` is the ideal entry point for branch management. When a plan is selected, the command should create or switch to the corresponding plan branch.

**Key Challenge:** Handling uncommitted changes when switching between plans.

---

## 1. Current State Analysis

### What /plan:set Does Now

1. **Plan Discovery**: Executes `node scripts/scan-plans.js` to get available plans
2. **User Selection**: Presents options via `AskUserQuestion`
3. **Plan Activation**: Writes plan path to `.claude/current-plan.txt`
4. **Status Initialization**: Calls `node scripts/status-cli.js init`
5. **Summary Display**: Shows plan overview with progress

### Current Limitations

- No git branch management
- All work happens on current branch (typically `master`)
- No isolation between plans
- No protection against context switching issues

---

## 2. Branch Workflow to Add

### Branch Creation Flow

**When user runs `/plan:set my-plan`:**

```bash
# Step 1: Check for uncommitted changes (see section 3)
git diff --quiet || prompt_user_for_uncommitted_changes()

# Step 2: Derive branch name from plan name
branch_name="plan/$(basename $plan_path .md)"

# Step 3: Check if branch exists
if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
  # Branch exists - switch to it
  git checkout "$branch_name"
  echo "✓ Switched to existing plan branch: $branch_name"
else
  # Branch doesn't exist - create from main
  git checkout main || git checkout master
  git checkout -b "$branch_name"
  echo "✓ Created new plan branch: $branch_name"
fi

# Step 4: Update status tracking (existing behavior)
node scripts/status-cli.js init

# Step 5: Show summary with branch info (enhanced)
```

### Branch Name Sanitization

```javascript
function sanitizeBranchName(planName) {
  return planName
    .toLowerCase()
    .replace(/[_\s]+/g, '-')     // spaces/underscores to hyphens
    .replace(/[^a-z0-9-]/g, '')   // remove special chars
    .replace(/^-+|-+$/g, '')      // trim leading/trailing hyphens
    .substring(0, 240);            // enforce max length
}
```

### Main Branch Detection

```bash
if git rev-parse --verify main >/dev/null 2>&1; then
  base_branch="main"
elif git rev-parse --verify master >/dev/null 2>&1; then
  base_branch="master"
else
  base_branch=$(git rev-parse --abbrev-ref HEAD)
fi
```

---

## 3. Uncommitted Changes Handling

### Detection

```bash
if ! git diff --quiet || ! git diff --cached --quiet; then
  # Uncommitted changes detected
  handle_uncommitted_changes()
fi
```

### User Options

```
⚠ Uncommitted changes detected (5 files modified)

Options:
  [C] Commit changes to current plan branch
  [S] Stash changes (git stash with auto-generated message)
  [A] Abort - stay on current branch
  [F] Force switch (WARNING: may lose work)

Choose an option [C/S/A/F]:
```

### Option Implementations

**Option C: Commit to Current Plan**
```bash
if [[ $current_branch == plan/* ]]; then
  git add -A
  git commit -m "WIP: Auto-commit before switching plans"
  echo "✓ Changes committed to $current_branch"
fi
```

**Option S: Stash Changes**
```bash
stash_message="Auto-stash from /plan:set - $current_branch -> $new_branch"
git stash push -u -m "$stash_message"
echo "✓ Changes stashed. Restore with: git stash pop"
```

**Option A: Abort**
```bash
echo "⚠ Plan switch cancelled. Staying on current branch."
exit 0
```

**Option F: Force Switch (Dangerous)**
```bash
git checkout -f "$new_branch"
echo "✓ Forced switch (changes discarded)"
```

### Auto-Commit for Current Plan

If changes belong to currently active plan:
```javascript
if (currentBranch === expectedBranch) {
  console.log('ℹ Auto-committing changes to current plan branch...');
  execSync('git add -A');
  execSync(`git commit -m "WIP: Auto-commit before switching to ${newPlan}"`);
}
```

---

## 4. status.json Schema Additions

### New Git Section

```json
{
  "git": {
    "branchName": "plan/analyze-git-workflow",
    "branchCreatedAt": "2025-12-24T20:00:00Z",
    "branchStatus": "active",
    "baseBranch": "main",
    "isRemoteTracked": false,
    "remoteBranch": null,
    "lastSyncedAt": null,
    "divergenceStatus": {
      "aheadBy": 12,
      "behindBy": 0,
      "lastChecked": "2025-12-24T22:30:00Z"
    }
  }
}
```

### Branch Status Values

- `active` - Plan is in progress, branch active
- `completed` - Plan finished, branch merged to main
- `abandoned` - Plan abandoned, branch may be deleted
- `archived` - Plan archived, branch deleted but tag exists
- `stale` - No activity for >60 days

---

## 5. Existing Branch Sync

### Check for Remote Updates

```bash
if git config --get branch.$branch_name.remote >/dev/null; then
  git fetch origin "$branch_name" 2>/dev/null

  ahead=$(git rev-list --count origin/$branch_name..$branch_name)
  behind=$(git rev-list --count $branch_name..origin/$branch_name)

  if [[ $behind -gt 0 ]]; then
    echo "⚠ Remote branch is $behind commits ahead"
    prompt_pull_remote()
  fi
fi
```

### Handle Diverged Branches

```
⚠ Branch has diverged from remote

Local: 3 commits ahead
Remote: 2 commits ahead

Options:
  [P] Pull and merge (git pull)
  [R] Pull and rebase (git pull --rebase)
  [L] Use local (ignore remote updates)
  [C] Cancel switch
```

---

## 6. Main Branch Protection

### Detect Work on Main

```bash
current_branch=$(git rev-parse --abbrev-ref HEAD)

if [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
  echo "⚠ WARNING: You are on the $current_branch branch"
  echo "Creating plan branch: plan/$plan_name"
  git checkout -b "plan/$plan_name"
fi
```

### Optional Pre-Commit Hook

```bash
#!/bin/bash
# .git/hooks/pre-commit

current_branch=$(git rev-parse --abbrev-ref HEAD)

if [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
  echo "ERROR: Direct commits to $current_branch not allowed"
  exit 1
fi
```

---

## 7. Status Display Enhancement

### Current Output

```
Active plan set to: docs/plans/test-suite-implementation.md
Output directory: docs/plan-outputs/test-suite-implementation/

Plan Summary:
- Phase 1: Critical Unit Tests (5 tasks, 2 completed)
...

Progress: [████████░░░░░░░░░░░░] 40%
```

### Enhanced Output with Git Info

```
✓ Switched to plan: docs/plans/test-suite-implementation.md
  Branch: plan/test-suite-implementation (active)
  Output: docs/plan-outputs/test-suite-implementation/

Git Status:
  ◉ On branch: plan/test-suite-implementation
  ↑ 3 commits ahead of main
  ↓ 0 commits behind main
  ⚡ Last updated: 5 minutes ago

Plan Summary:
- Phase 1: Critical Unit Tests (5 tasks, 2 completed)
...
```

### Warning Messages

```
⚠ Warning: This plan branch hasn't been updated in 45 days
⚠ Uncommitted changes: 5 files modified
⚠ Remote branch diverged: Local 3 ahead | Remote 2 ahead
```

---

## 8. Implementation Priority

### Phase 1: Core Branch Creation (MVP) - 6-8 hours

- [ ] Detect git repository
- [ ] Implement branch name sanitization
- [ ] Add branch creation logic (create if new, switch if exists)
- [ ] Update current-plan.txt AFTER branch switch
- [ ] Basic error handling
- [ ] Update status display with branch name

**Deliverable:** `/plan:set my-plan` creates/switches to `plan/my-plan` branch

### Phase 2: Uncommitted Changes Handling - 4-6 hours

- [ ] Add git diff check before branch switch
- [ ] Implement interactive prompt (Commit/Stash/Abort/Force)
- [ ] Add auto-commit logic for current plan branch
- [ ] Add stash logic with descriptive message

**Deliverable:** Safe branch switching with no data loss

### Phase 3: status.json Git Integration - 3-4 hours

- [ ] Add `git` section to status.json schema
- [ ] Update `initializePlanStatus()` to populate git fields
- [ ] Track branchName, branchCreatedAt, baseBranch
- [ ] Store divergence status

**Deliverable:** status.json tracks git state

### Phase 4: Remote Branch Sync - 4-5 hours

- [ ] Detect remote tracking branch
- [ ] Fetch remote updates on switch
- [ ] Calculate ahead/behind divergence
- [ ] Prompt for pull/rebase if behind

**Deliverable:** Branch sync with remote repositories

### Phase 5: Main Branch Protection - 2-3 hours

- [ ] Detect base branch (main vs master)
- [ ] Check if currently on main after switch
- [ ] Auto-create plan branch if on main
- [ ] Optional pre-commit hook installation

**Deliverable:** Prevent accidental work on main

### Phase 6: Enhanced Status Display - 2-3 hours

- [ ] Add git section to status output
- [ ] Show branch name and status
- [ ] Display ahead/behind counts
- [ ] Add warning for stale branches

**Total Estimated Effort: 22-30 hours**

---

## 9. User-Facing Messages

### Success Messages

```
✓ Created plan branch: plan/analyze-git-workflow
✓ Switched to existing plan branch: plan/implement-auth
✓ Changes stashed: Auto-stash from /plan:set
```

### Error Messages

```
✗ Error: Not a git repository
✗ Error: Failed to create branch
✗ Error: Git state is dirty (merge in progress)
```

---

## 10. Summary

The `/plan:set` command is the ideal entry point for git workflow integration:

**Key Changes:**
1. **Branch creation** - Create `plan/{plan-name}` on first set
2. **Branch switching** - Switch to existing branch on re-select
3. **Uncommitted changes** - Safe handling with user options
4. **Status tracking** - Record branch in status.json
5. **Main protection** - Prevent work on main branch
6. **Enhanced display** - Show git info in status output

**Benefits:**
- Automatic isolation per plan
- Zero risk of mixing changes
- Clean rollback (abandon = delete branch)
- Matches industry-standard workflow
