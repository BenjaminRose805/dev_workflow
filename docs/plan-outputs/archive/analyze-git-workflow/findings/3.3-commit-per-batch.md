# Task 3.3: Commit-Per-Batch Strategy Analysis

## Overview

This analysis evaluates the **commit-per-batch** strategy, where git commits are aligned with orchestrator iteration boundaries rather than task or phase boundaries. A "batch" represents a group of tasks executed together in a single orchestrator iteration, typically 2-5 parallel tasks.

## Executive Summary

**Key Finding:** Commit-per-batch is **NOT RECOMMENDED** as a primary strategy due to critical semantic misalignment. Batches are **execution-centric** (based on parallelism) rather than **plan-centric** (based on semantic grouping).

**Critical Flaw:** 30-50% of batches cross phase boundaries, destroying semantic clarity in git history.

**Recommendation:** Keep per-task commits, add batch markers (tags) for orchestrator tracking.

---

## 1. Definition: What is Commit-Per-Batch?

**Commit-per-batch** means creating a single git commit after the orchestrator completes an iteration (batch) of tasks, regardless of how many tasks were executed or which phases they belong to.

### Batch Boundaries

- **Start:** Orchestrator selects next N tasks
- **End:** All parallel agents complete, results collected
- **Commit:** After batch end, before next batch start

### Example Batch Sequence

```bash
# Batch 1: [1.1, 1.2, 1.3] - same phase (good)
# Batch 2: [1.4, 1.5, 2.1] - crosses Phase 1 → Phase 2 (bad)
# Batch 3: [2.2, 2.3, 2.4] - same phase (good)
```

---

## 2. Orchestrator Iteration Model

### How Batches Are Formed

| Plan Size | Batch Size |
|-----------|------------|
| < 10 tasks | 2-3 |
| 10-30 tasks | 3-4 |
| > 30 tasks | 4-5 |

### Key Problem: Batches Don't Respect Phases

```
Plan with 15 tasks, 3 phases, batch size = 4

Batch 1: [1.1, 1.2, 1.3, 1.4] ← Phase 1 only ✓
Batch 2: [1.5, 2.1, 2.2, 2.3] ← Phase 1 + Phase 2 ✗
Batch 3: [2.4, 2.5, 3.1, 3.2] ← Phase 2 + Phase 3 ✗
Batch 4: [3.3, 3.4, 3.5]      ← Phase 3 only ✓

Result: 50% of commits have semantically mixed content
```

---

## 3. Advantages of Commit-Per-Batch

### 3.1 Natural Alignment with Execution Model
- 1:1 mapping between orchestrator cycles and commits
- Easy to understand orchestrator behavior from git log

**Score: 8/10** for orchestrator developers

### 3.2 Atomic Checkpoints Per Cycle
- Each iteration is a recoverable checkpoint
- Can restart from last committed batch

**Score: 7/10** for resilience

### 3.3 Fewer Commits Than Per-Task
- 100 tasks with batch size 4 = 20-25 commits (vs 100)
- 75-80% reduction in commit count

**Score: 8/10** for performance

---

## 4. Disadvantages of Commit-Per-Batch

### 4.1 Batches Don't Respect Phase Boundaries (CRITICAL)
- Cross-phase batches create incoherent commits
- "batch 2: tasks 1.5, 2.1-2.3" - what does this represent?

**Severity: 9/10**

### 4.2 Confusing History
- Can't easily identify phase boundaries
- Can't rollback just Phase 3
- Git history doesn't reflect plan structure

**Severity: 8/10**

### 4.3 Arbitrary Task Grouping
- Grouping based on parallelism, not semantics
- Can't revert just task 2.1 without reverting 1.5, 2.2, 2.3

**Severity: 9/10**

### 4.4 Harder to Find Specific Task Changes
- `git log --grep="2.3"` returns batch commit
- Must parse large diff to find task 2.3's changes

**Severity: 8/10**

---

## 5. When Batch Commit Makes Sense

### Acceptable Use Cases

1. **Truly atomic batch operations**
   - Tasks form tightly coupled unit (all or nothing)
   - Partial completion is invalid

2. **Orchestrator-centric rollback only**
   - No human debugging needed
   - Pure automation recovery

3. **Short-lived batches (2 tasks)**
   - Minimal granularity loss
   - Fast execution

### Frequency: ~10-20% of scenarios

---

## 6. When Batch Commit Is Problematic

### 6.1 Cross-Phase Batches
- 30-50% of batches cross phases
- Destroys plan structure visibility

### 6.2 Large Batches (10+ tasks)
- 45+ files, 1400+ lines
- Impossible to review or debug

### 6.3 Debugging Individual Task Failures
- Which task in batch 2 broke X?
- git bisect points to batch, not task
- 4x longer debugging time

---

## 7. Comparison: Task vs Batch vs Phase

| Aspect | Per-Task | Per-Batch | Per-Phase |
|--------|----------|-----------|-----------|
| **Commits** (100 tasks) | 100 | 20-25 | 5-10 |
| **Semantic clarity** | High | Low | High |
| **Rollback granularity** | Single task | 4-5 tasks | 10-20 tasks |
| **Debugging** | Excellent | Poor | Good |
| **Phase boundary respect** | N/A | No | Yes |
| **Commit overhead** | High | Low | Very low |

### Verdict

Per-batch is a **local optimum** for orchestrator mechanics but **global suboptimum** for plan workflows.

---

## 8. Recommended Alternative

### Keep Per-Task Commits + Add Batch Markers

```bash
# Per-task commits (granular history)
git commit -m "task 1.1: Create auth middleware"
git commit -m "task 1.2: Add user model"
git commit -m "task 1.3: Implement login"

# Batch marker (tag for orchestrator tracking)
git tag -a batch-1 -m "Orchestrator iteration 1: tasks 1.1-1.3"
```

### Benefits

- ✓ Task-level rollback
- ✓ Semantic clarity (tasks preserve plan structure)
- ✓ Batch tracking (tags mark iterations)
- ✓ Debugging precision (per-task bisect)

---

## 9. Final Recommendation

### DO NOT Implement Commit-Per-Batch as Primary Strategy

**Critical Flaws:**
1. Cross-phase batches destroy semantic clarity
2. Arbitrary task grouping prevents precise rollback
3. Debugging requires analyzing multi-task commits
4. Git history doesn't reflect plan structure

### Instead: Per-Task Commits + Batch Tags

**Implementation:**
```javascript
function completeBatch(tasks, batchNum) {
  // Tasks already committed individually

  // Add batch marker
  execSync(`git tag -a batch-${batchNum} -m "Iteration ${batchNum}"`);

  // Track in status.json
  recordBatchCompletion(batchNum, tasks);
}
```

---

## 10. Summary Score

| Criterion | Score |
|-----------|-------|
| Orchestrator alignment | 10/10 |
| Semantic clarity | 2/10 |
| Debugging | 3/10 |
| Rollback granularity | 4/10 |
| History readability | 5/10 |
| Performance | 9/10 |
| Team workflows | 3/10 |
| Plan structure visibility | 2/10 |
| **Overall** | **4.5/10** |

**Verdict: NOT RECOMMENDED**

Better alternatives exist (per-task + batch tags, per-phase via branching).
