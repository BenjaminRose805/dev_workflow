# Task 4.1: Merge Strategy Evaluation

## Overview

This analysis evaluates three primary merge strategies for integrating plan branches into the main branch: **merge commit**, **squash merge**, and **rebase**. Based on the established context (branch-per-plan workflow, commit-per-task granularity, and rollback requirements), **squash merge is the RECOMMENDED default strategy** with merge commit as an optional alternative for specific scenarios.

---

## 1. Merge Commit Strategy (`git merge --no-ff`)

### Definition

Creates a merge commit that preserves the entire branch history and shows the branching structure in the commit graph.

```bash
git checkout main
git merge --no-ff plan/implement-auth
# Result: Creates merge commit + all task commits visible from main
```

### Advantages

| Benefit | Score | Description |
|---------|-------|-------------|
| Complete history preservation | 10/10 | Every task commit visible from main |
| Branch context visibility | 9/10 | Git graph shows plan boundaries |
| Rollback flexibility | 10/10 | Can revert entire plan OR individual tasks |
| Team understanding | 8/10 | Reviewers see incremental decisions |

### Disadvantages

| Problem | Severity | Mitigation |
|---------|----------|------------|
| History noise on main | 7/10 | Use `git log --first-parent` |
| Cluttered timeline | 6/10 | Filter by `--grep="Plan:"` |
| Merge commit overhead | 2/10 | Minor (one per plan) |

### Best For

- Plans with high historical value (major refactors)
- Debugging-heavy projects (need task-level bisect)
- Compliance requiring granular audit trail

---

## 2. Squash Merge Strategy (`git merge --squash`)

### Definition

Combines all commits from the plan branch into a single commit on main, discarding branch history from main's perspective.

```bash
git checkout main
git merge --squash plan/implement-auth
git commit -m "Plan: implement-auth (20 tasks)"
# Result: Single commit on main, plan branch history preserved via archive tag
```

### Advantages

| Benefit | Score | Description |
|---------|-------|-------------|
| Clean main history | 10/10 | One commit per plan |
| Simple plan rollback | 9/10 | Single revert point |
| Industry alignment | 9/10 | Matches GitHub "Squash and merge" |
| Flexible commit message | 10/10 | Craft perfect summary |

### Disadvantages

| Problem | Severity | Mitigation |
|---------|----------|------------|
| Loses granular history on main | 8/10 | Archive tags preserve it |
| No task-level rollback post-merge | 7/10 | Rollback before merge |
| Archive tag management | 5/10 | Automate in orchestrator |

### Best For

- Team development (clean main for everyone)
- Public OSS projects (professional history)
- Most plans (< 20 tasks) - DEFAULT choice

---

## 3. Rebase Strategy (`git rebase` + fast-forward)

### Definition

Replays plan branch commits on top of main, creating linear history without merge commits.

```bash
git checkout plan/implement-auth
git rebase main
git checkout main
git merge --ff-only plan/implement-auth
```

### Advantages

| Benefit | Score | Description |
|---------|-------|-------------|
| Linear history | 8/10 | No merge commits |
| Task-level granularity | 9/10 | Each task visible on main |
| Fewer total commits | 6/10 | Marginal efficiency gain |

### Disadvantages

| Problem | Severity | Mitigation |
|---------|----------|------------|
| Rewrites history | 9/10 | DANGEROUS for teams |
| Requires force push | 8/10 | Easy to lose work |
| Conflict resolution per commit | 8/10 | Tedious for large plans |
| Lost branch context | 7/10 | Can't identify plan boundaries |

### NOT Recommended

- Automation (can't handle conflicts)
- Team workflows (shared branches)
- Any plan already pushed to remote

---

## Comparison Matrix

| Aspect | Merge Commit | Squash Merge | Rebase |
|--------|-------------|--------------|--------|
| Main branch readability | 3/10 | **10/10** | 6/10 |
| Task-level rollback (post-merge) | Yes | No | Yes |
| Plan-level rollback | Easy | Easy | Hard |
| Team collaboration | Good | **Excellent** | Poor |
| Automation feasibility | Easy | **Easy** | Hard |
| Force push required | No | No | **Yes** |

### Fit Scores

| Criteria | Merge Commit | Squash Merge | Rebase |
|----------|-------------|--------------|--------|
| Branch-per-plan workflow | 9 | **10** | 5 |
| Commit-per-task strategy | 10 | 8 | 10 |
| Team collaboration | 8 | **9** | 2 |
| Rollback requirements | 10 | 7 | 4 |
| **TOTAL** | 57/70 | **63/70** | 34/70 |

---

## Recommendation

### Default Strategy: SQUASH MERGE

**Score: 9/10 overall fit**

**Rationale:**
1. Clean main branch (highest priority for teams and OSS)
2. Matches plan-as-atomic-unit philosophy
3. Industry standard (GitHub/GitLab default)
4. Easy to automate
5. Simple plan-level rollback

### Alternative: MERGE COMMIT

**Use when:**
- Plans with high historical/debugging value
- Compliance requiring granular audit trail on main
- User explicitly requests `--merge commit`

### NOT RECOMMENDED: REBASE

Risks outweigh benefits for automated workflows.

---

## Configuration

```json
{
  "git_workflow": {
    "merge_strategy": "squash",
    "archive_branches": true,
    "archive_retention_days": 90,
    "allow_merge_override": true,
    "valid_merge_strategies": ["squash", "commit"]
  }
}
```

## Command Interface

```bash
# Default: squash
/plan:complete

# Override to merge commit
/plan:complete --merge commit
```
