# Task 3.1: Commit-Per-Task Strategy Evaluation

## Overview

This analysis evaluates the commit-per-task strategy for the plan orchestration system, examining granularity trade-offs, message format, performance implications, and optimal use cases. The goal is to determine when and how to implement per-task commits as part of the overall git workflow.

## Context

**Current State:**
- Commit-per-task workflow is **documented** in `/plan:implement` (lines 430-481)
- Workflow is **NOT enforced** in practice (analysis of recent history shows batched commits)
- Message format specified: `task {id}: {description}` with plan/phase in body
- Recent commits show manual batching: "task 0.1-0.4", "39 tasks", etc.

**Critical Dependencies:**
- Rollback requirements demand per-task commits for surgical reverts (see Task 1.2)
- Hybrid A strategy (granular on branch + squash on merge) requires this foundation (see Task 1.3)
- Branch-per-plan strategy depends on predictable commit structure (see Task 2.1)

---

## 1. Definition: What is Commit-Per-Task?

### Formal Definition

**Commit-per-task** is a git workflow pattern where:

1. **After each task completion**, the orchestrator automatically stages all changes and creates a commit
2. **Each commit represents exactly one task** from the plan's task list
3. **Commit messages follow a structured format** linking to task metadata
4. **No batching occurs** - tasks 1.1, 1.2, 1.3 create three separate commits, never combined

### Operational Workflow

```bash
# Task 1.1 execution begins
/plan:implement 1.1

# Task 1.1 completes successfully
# Orchestrator automatically executes:
git status --porcelain  # Check for changes
if [[ -n $(git status --porcelain) ]]; then
  git add -A
  git commit -m "task 1.1: Create authentication middleware

Plan: implement-auth
Phase: Phase 1: Core Implementation
Duration: 34s
Status: completed"
fi
```

### Boundary Conditions

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| Task completes with no file changes | **Skip commit** | Analysis tasks don't pollute history |
| Task fails but partial changes exist | **Commit with status: failed** | Preserve state for debugging |
| Multiple tasks run in parallel/batch | **One commit per task** | Maintain granularity even in batch mode |
| Task modifies only whitespace | **Commit anyway** | Formatting changes are real changes |
| Task creates .gitignore'd files only | **Skip commit** | No staged changes to commit |
| Commit hook rejects commit | **Log warning, continue** | Don't fail task due to hook issues |

---

## 2. Granularity Analysis

### 2.1 Advantages (Pros)

#### A. Traceability

**Capability**: Precisely identify what each task changed.

```bash
# Find exactly what task 1.3 did
git show $(git log --grep="task 1.3:" --format="%H" -1)
```

**Value**: In a 100-task plan, ability to isolate 1/100th of changes vs. examining entire plan diff.

#### B. Rollback Capability

**Capability**: Surgical revert of individual tasks without affecting others.

```bash
# Task 2.3 introduced a bug, but tasks 2.4-2.9 are fine
git revert $(git log --grep="task 2.3:" --format="%H" -1) --no-edit
# Only task 2.3 undone, rest of plan intact
```

**Value**: No collateral damage to working tasks, no rework needed.

#### C. Debugging & Bisect

**Capability**: Use `git bisect` to find which task broke functionality.

```bash
git bisect start
git bisect bad HEAD
git bisect good plan/auth-start
# Binary search: ~7 iterations for 100-task plan
```

**Value**: Minutes instead of hours to find regression.

#### D. Incremental Safety

**Capability**: Automatic checkpoint after each task completion.

**Value**: In 2-hour plan with 50 tasks, crash loses at most 1 task worth of work (~2.4 min average).

#### E. Audit Trail

**Capability**: Complete record of what orchestrator did and when.

**Value**: Compliance (HIPAA, SOC2), incident response, performance metrics.

### 2.2 Disadvantages (Cons)

#### A. History Noise

**Problem**: 100-task plan creates 100 commits on branch.

**Mitigation**: Squash on merge to main keeps main readable.

#### B. Log Clutter

**Problem**: `git log` requires filtering to find relevant information.

**Solution**: Use `git log --grep="Plan: auth"` or squash merge.

#### C. Commit Overhead (Performance)

| Plan Size | Total Git Overhead | As % of Plan Runtime |
|-----------|-------------------|---------------------|
| 10 tasks | 7-20 seconds | 0.5-2% |
| 50 tasks | 35-100 seconds | 1-3% |
| 100 tasks | 70-200 seconds (1.2-3.3 min) | 2-5% |

**Verdict**: For typical orchestrator use (10-100 task plans), overhead is **acceptable**.

---

## 3. Message Format Evaluation

### 3.1 Current Format

```
task {id}: {description}

Plan: {plan-name}
Phase: {phase-name}
Duration: {duration}
Status: {status}
```

### 3.2 Strengths

- Task ID linkage enables `git log --grep="task 1.1:"`
- Structured metadata in body
- Grep-friendly

### 3.3 Weaknesses

- Not conventional commits compliant
- No semantic type (feat/fix/chore)
- Tooling compatibility limited

### 3.4 Recommendation: Hybrid Format

```
task({id}): {description}

Plan: {plan-name}
Phase: {phase-name}
Duration: {duration}
Type: {feat|fix|refactor|test|docs|chore}

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

---

## 4. When Commit-Per-Task Excels

### High-Risk Tasks
- File deletions, database migrations, refactors
- Easy rollback if deletion was wrong

### Debug/Forensic Requirements
- Regulatory compliance requiring change attribution
- Incident response ("When did this config change?")

### Rollback-Heavy Workflows
- Experimental features (try multiple approaches)
- AI-generated code (higher error rate)

### Long-Running Plans
- Plans >1 hour or spanning multiple sessions
- Crash recovery, progress visibility

---

## 5. When Commit-Per-Task Has Issues

### Very Fast Tasks (Sub-Second Completion)
- Git overhead (1-2s) exceeds task execution time
- **Mitigation**: Batch fast tasks or use async commits

### Analysis-Only Tasks
- No file changes â†’ skip commit automatically
- Already handled by current spec

### Inherently Atomic Batch Operations
- Dependent tasks that must succeed/fail together
- **Solution**: Use VERIFY gates to group dependent tasks

### Plans with Hundreds of Trivial Tasks
- 500 file-formatting tasks = 500 commits
- **Solution**: Redesign plan with fewer, broader tasks

---

## 6. Recommendations

### 6.1 Default Policy

**Enable commit-per-task by default**

- Safety first: Rollback capability critical for AI-generated code
- Matches documentation: `/plan:implement` already specifies this
- Enables Hybrid A strategy: Required foundation for recommended workflow

### 6.2 Skip Conditions

1. No file changes (analysis tasks)
2. Dry-run mode
3. Not a git repository
4. Task failed (commit with failed status for debugging)

### 6.3 Message Format Specification

**Phase 1 (Simple):**
```
task {id}: {description}

Plan: {plan-name}
Phase: {phase-name}
Duration: {duration}
```

**Phase 2 (Hybrid with conventional commits):**
```
task({id}): {description}

Plan: {plan-name}
Phase: {phase-name}
Type: {feat|fix|refactor}
```

---

## 7. Implementation Checklist

**Phase 1: MVP**
- [ ] Enforce commit after each task in `/plan:implement`
- [ ] Implement skip conditions
- [ ] Use simple message format
- [ ] Add commit SHA to status.json

**Phase 2: Rollback**
- [ ] Implement `/plan:rollback task {id}` command
- [ ] Add `findCommitForTask()` utility
- [ ] Update status.json on rollback

**Phase 3: Advanced**
- [ ] Add conventional commits format (opt-in)
- [ ] Implement commit batching for large plans
- [ ] Performance monitoring

---

## 8. Conclusion

**Commit-per-task is the recommended default strategy** because:

1. **Safety**: Automatic checkpoints prevent data loss
2. **Rollback**: Surgical revert of individual tasks
3. **Debugging**: Bisect, blame, audit trail
4. **Performance**: 1-2s overhead per task acceptable
5. **Foundation**: Required for Hybrid A strategy

**Trade-offs accepted:**
- History noise on feature branches (mitigated by squash)
- 2-5% performance overhead (acceptable for safety)

**Priority**: Implement commit-per-task enforcement ASAP - it's the foundation for rollback, bisect, and overall safety.
