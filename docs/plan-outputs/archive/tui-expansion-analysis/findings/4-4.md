# Task 4.4: Phase-Based vs DAG-Based Scheduling Comparison

**Analysis Plan:** TUI Expansion Analysis
**Task Number:** 4.4
**Date:** 2025-12-26
**Scope:** Compare phase-based and DAG-based scheduling approaches

---

## Executive Summary

The current dev_workflow system is **already a hybrid** approach combining:
- **Phase-based organization** for clarity and planning
- **DAG-based execution** for dependency validation and optimal scheduling

The distinction is not binary but represents a spectrum. This analysis compares both approaches and recommends leveraging both for maximum benefit.

---

## 1. Phase-Based Scheduling (Current)

### How It Works

Tasks are organized into sequential phases (Phase 0, 1, 2, etc.). Each phase represents a logical grouping.

```
Phase 0: Setup          [████████████] ✓
Phase 1: Core           [████████░░░░] 67%
Phase 2: API            [████░░░░░░░░] 33%
Phase 3: Testing        [░░░░░░░░░░░░] 0%
```

### Task Selection Algorithm

**Location:** `scripts/lib/plan-status.js:2097-2201` in `getReadyTasks()`

```javascript
readyTasks.sort((a, b) => {
  if (a.phaseNumber !== b.phaseNumber) {
    return a.phaseNumber - b.phaseNumber;  // Phase priority
  }
  return a.id.localeCompare(b.id);
});
```

**Key Behavior:** Phase number is a **sort key**, not a blocking gate. A task in Phase 3 with no dependencies can be selected before a task in Phase 1 with pending dependencies.

### Phase Execution Controls

| Control | Syntax | Effect |
|---------|--------|--------|
| `[SEQUENTIAL]` | `Tasks 3.1-3.4 are [SEQUENTIAL]` | Force sequential execution |
| `[PARALLEL]` | `Phases 1-3 are [PARALLEL]` | Allow cross-phase parallelism |
| `(non-blocking)` | `VERIFY Phase 1: (non-blocking)` | Don't block next phase |
| `pipeline-start` | `Phase 2 (pipeline-start: when 1.3 completes)` | Early phase start |

### Pros and Cons

| Aspect | Pro | Con |
|--------|-----|-----|
| **Simplicity** | Easy to understand | Coarse-grained grouping |
| **Planning** | Natural project breakdown | Misses task-level deps |
| **Documentation** | Clear narrative flow | Limited expressiveness |
| **Parallelism** | Enabled via annotations | May miss opportunities |

---

## 2. DAG-Based Scheduling (Proposed/Partial)

### How It Works

Tasks form a Directed Acyclic Graph (DAG) with explicit dependencies. Scheduling uses topological order.

```
Task 1.1 (Create types)
    ├─→ Task 1.3 (Auth service)
    │   └─→ Task 2.1 (User endpoints)
    └─→ Task 1.2 (DB schema)
        └─→ Task 2.2 (Query builders)
```

### DAG-Aware Task Selection

```javascript
function getReadyTasks_DAG(status, maxTasks = 5) {
  // Return tasks with inDegree = 0 (all dependencies satisfied)
  // No phase-based sorting
}
```

### Current DAG Implementation

**Already Implemented:**
- `parseDependencies()` - Extract `(depends: X.Y)` from descriptions
- `buildDependencyGraph()` - Create DAG structure
- `detectDependencyCycles()` - Find circular dependencies
- Storage in `status.json` with `dependencies` and `dependents` fields

**Not Fully Utilized:**
- Topological sorting without phase-based sorting
- InDegree-based dynamic scheduling
- Cross-phase scheduling optimization

### Pros and Cons

| Aspect | Pro | Con |
|--------|-----|-----|
| **Precision** | Exact task relationships | Requires fine-grained markup |
| **Parallelism** | Automatically maximized | Complex to visualize |
| **Flexibility** | Arbitrary patterns | Harder for non-technical users |
| **Optimization** | Optimal execution order | Higher complexity |

---

## 3. Side-by-Side Comparison

### Execution Model

| Criterion | Phase-Based | DAG-Based |
|-----------|-------------|-----------|
| Schedule Units | Phases | Individual tasks |
| Selection Criteria | Phase order, then task ID | Dependency satisfaction |
| Parallelism Default | Cross-phase if allowed | Maximal (all ready tasks) |
| Explicit Ordering | `[SEQUENTIAL]` annotations | `(depends:)` in descriptions |
| Phase Overlap | Manual `pipeline-start` | Automatic |
| Cycle Prevention | Manual | Automatic via detection |

### Complexity and Maintenance

| Criterion | Phase-Based | DAG-Based |
|-----------|-------------|-----------|
| Plan Syntax | Simple phase headers | Dependencies in descriptions |
| Mental Model | Sequential narrative | Dependency graph |
| Debugging | Easy phase tracing | Graph visualization needed |
| Refactoring | Renumber phases/tasks | Update dependency references |

### Performance

| Criterion | Phase-Based | DAG-Based |
|-----------|-------------|-----------|
| Task Selection | O(n log n) sorting | O(n) inDegree check |
| Parallelism Potential | Limited by phases | Maximal by dependencies |
| Critical Path | Phase count | Longest dependency chain |

---

## 4. Current Implementation Status

### What's Already Built (Hybrid Approach)

The system **already combines** both approaches:

**DAG Components (Fully Functional):**
- Dependency parsing from descriptions
- Graph construction with `buildDependencyGraph()`
- Cycle detection
- Dependency checking in `getReadyTasks()`

**Phase Components (Fully Functional):**
- Phase parsing from markdown
- Phase-based sorting in `getReadyTasks()`
- Sequential constraint parsing and enforcement
- Pipeline triggers and non-blocking VERIFY

### What's Missing

| Gap | Current State | Impact |
|-----|---------------|--------|
| Topological sort option | Sorts by phase after deps | Suboptimal order |
| Cross-phase optimization | No urgency-based selection | Missed parallelism |
| Auto phase overlap | Requires `pipeline-start` | Manual annotation |

---

## 5. Migration Path

### Phase 1: Information Gathering (Weeks 1-2)

- Audit existing plans for dependency patterns
- Analyze execution logs for missed parallelism
- Survey users about phase vs task thinking

### Phase 2: Scheduler Options (Weeks 3-4)

```javascript
function getReadyTasks(status, maxTasks = 5, options = {}) {
  const { scheduler = 'hybrid' } = options;  // 'phase', 'dag', or 'hybrid'

  if (scheduler === 'dag') {
    // Use only dependency-based selection
  } else if (scheduler === 'hybrid') {
    // DAG for readiness, phase for tiebreaking
  } else {
    // Current phase-based behavior
  }
}
```

### Phase 3: Gradual Adoption

- Keep phase-based as default
- Add `--scheduler dag` flag for comparison
- Let users opt-in to full DAG mode

---

## 6. Hybrid Approach Opportunities

### Benefit 1: Phase Planning with DAG Execution

```markdown
## Phase 1: Core Implementation

- [ ] 1.1 Create shared types
- [ ] 1.2 Create database schema
- [ ] 1.3 Implement auth service (depends: 1.1, 1.2)
```

**User thinks in phases** but **system executes with DAG awareness**.

### Benefit 2: Cross-Phase Dependencies

```markdown
## Phase 1: Core
- [ ] 1.1 Types
- [ ] 1.3 Auth (depends: 1.1, 1.2)

## Phase 3: Testing
- [ ] 3.1 Unit tests (depends: 1.1)    [Can start mid-Phase-1]
```

Tasks start as soon as their dependencies are satisfied, regardless of phase.

### Recommended Hybrid Mode

```javascript
if (scheduler === 'hybrid') {
  // 1. Get ready tasks by dependency (DAG-based)
  const readyByDeps = getReadyByDependency(status);

  // 2. Sort by phase (phase-based tiebreaker)
  const sorted = readyByDeps.sort((a, b) => {
    return a.phaseNumber - b.phaseNumber;
  });

  // 3. Apply sequential constraints
  return filterBySequential(sorted);
}
```

---

## 7. TUI Visualization Recommendations

### Default View: Phase-Centric

```
┌─────────────────────────────────────────┐
│ PHASE PROGRESS                          │
├─────────────────────────────────────────┤
│ Phase 0: Setup          [████████████] ✓ │
│ Phase 1: Core           [████████░░░░] 67%│
│ Phase 2: API            [████░░░░░░░░] 33%│
│ Current: Phase 1 (in progress)          │
│ Active Phases: 1, 2 (cross-phase)       │
└─────────────────────────────────────────┘
```

### Optional View: DAG-Centric

```
┌─────────────────────────────────────────┐
│ DEPENDENCY STATUS                       │
├─────────────────────────────────────────┤
│ Ready: 3 tasks                          │
│ Blocked: 2 tasks                        │
│ Critical Path: 1.1 → 1.3 → 2.1 → 3.1   │
│ Est. Remaining: 45 min                  │
└─────────────────────────────────────────┘
```

### Supporting Both Paradigms

The TUI should support both without forcing users to choose:
- Phase tab (current, familiar)
- DAG tab (new, advanced)
- Hybrid tab (balanced default)

---

## 8. Recommendations

### Short Term (Weeks 1-4)

1. **Document current hybrid state** (this document)
2. **Add DAG visualization** to TUI (optional view)
3. **Enhance status-cli.js** with `--scheduler dag` flag

### Medium Term (Weeks 4-8)

4. **Implement topological sort option**
5. **Auto-detect scheduler** from plan content
6. **TUI multi-view support** (phase/DAG/hybrid tabs)

### Long Term (Weeks 8+)

7. **Migration tooling** (convert phase-based to DAG)
8. **Performance optimization** (cache dependency graph)
9. **Critical path estimation** for completion time

---

## 9. Quick Reference Matrix

### When to Use Phase-Based

- Small projects (< 20 tasks)
- Clear sequential phases
- Non-technical stakeholders
- Simple dependencies

### When to Use DAG-Based

- Complex projects (> 50 tasks)
- Highly interconnected tasks
- Need maximum parallelism
- Technical teams

### When to Use Hybrid

- Medium projects (20-100 tasks)
- Mix of phase and task thinking
- Want both familiarity AND optimal parallelism
- Evolving project structure

---

## Summary

| Approach | Organization | Scheduling | Best For |
|----------|--------------|------------|----------|
| **Phase-Based** | Phases | Sort by phase | Simple, familiar |
| **DAG-Based** | Dependencies | Topological order | Maximum parallelism |
| **Hybrid** | Phases + Dependencies | DAG-aware, phase-sorted | Balanced |

**Recommendation:** Continue with hybrid approach, enhancing DAG visualization and providing scheduler options for different use cases.
