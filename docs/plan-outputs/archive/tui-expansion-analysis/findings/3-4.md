# Task 3.4: Conflict Data in `next` Command Output

## Summary

The `cmdNext()` function in `scripts/status-cli.js:697-978` integrates file conflict detection into its JSON output. This analysis documents the conflict-related fields, their structure, and how they affect task batching recommendations.

## Command Overview

```bash
node scripts/status-cli.js next [count] [--ignore-deps] [--phase-priority]
```

**Purpose:** Returns the next N recommended tasks based on dependencies, phase ordering, and execution constraints.

**Conflict Integration:** Automatically detects file conflicts among returned tasks and annotates each task with conflict metadata.

## Output Structure

### Basic Output (No Conflicts)

```json
{
  "count": 3,
  "tasks": [
    {
      "id": "2.1",
      "description": "Create authentication module",
      "phase": 2,
      "status": "pending",
      "reason": "pending - ready to implement",
      "dependencies": [],
      "dependents": ["2.3", "2.4"],
      "sequential": false
    },
    ...
  ]
}
```

### Output With Conflicts

```json
{
  "count": 3,
  "tasks": [
    {
      "id": "2.1",
      "description": "Update `src/api.ts` with endpoint",
      "phase": 2,
      "status": "pending",
      "reason": "pending - ready to implement",
      "dependencies": [],
      "dependents": [],
      "sequential": false,
      "fileConflict": true,
      "conflictsWith": ["2.2"],
      "conflictingFiles": ["src/api.ts"]
    },
    {
      "id": "2.2",
      "description": "Modify `src/api.ts` for auth",
      "phase": 2,
      "status": "pending",
      "reason": "pending - ready to implement",
      "dependencies": [],
      "dependents": [],
      "sequential": false,
      "fileConflict": true,
      "conflictsWith": ["2.1"],
      "conflictingFiles": ["src/api.ts"]
    }
  ],
  "fileConflicts": [
    {
      "file": "src/api.ts",
      "taskIds": ["2.1", "2.2"]
    }
  ]
}
```

## Conflict-Related Fields

### Per-Task Fields

| Field | Type | Condition | Description |
|-------|------|-----------|-------------|
| `fileConflict` | `boolean` | When conflict exists | `true` if task conflicts with another |
| `conflictsWith` | `string[]` | When conflict exists | Array of task IDs this task conflicts with |
| `conflictingFiles` | `string[]` | When conflict exists | Array of file paths causing conflicts |

### Top-Level Fields

| Field | Type | Condition | Description |
|-------|------|-----------|-------------|
| `fileConflicts` | `array` | When any conflicts exist | Complete conflict list with file→tasks mapping |
| `blockedTaskCount` | `number` | When blocked tasks exist | Count of tasks blocked by dependencies |

## Implementation Details

### Conflict Detection Flow

```
cmdNext()
    │
    ├── Load status.json
    ├── Parse execution constraints from plan
    ├── Get next tasks (DAG-aware)
    │
    ├── Call detectFileConflicts(tasks)  ────────────────┐
    │                                                     │
    ├── Build conflictMap: taskId → {files, conflictsWith}│
    │         ↑                                           │
    │         └────────── From conflicts array ───────────┘
    │
    ├── Add conflict fields to each task
    │
    └── Output JSON with tasks + fileConflicts
```

### Code Walkthrough

**Step 1: Detect conflicts** (lines 894-912)
```javascript
const conflicts = detectFileConflicts(next);

// Build lookup of task ID -> conflicting task IDs
const conflictMap = new Map();
for (const conflict of conflicts) {
  for (const taskId of conflict.taskIds) {
    if (!conflictMap.has(taskId)) {
      conflictMap.set(taskId, {
        files: [],
        conflictsWith: new Set()
      });
    }
    conflictMap.get(taskId).files.push(conflict.file);
    for (const otherId of conflict.taskIds) {
      if (otherId !== taskId) {
        conflictMap.get(taskId).conflictsWith.add(otherId);
      }
    }
  }
}
```

**Step 2: Annotate tasks** (lines 916-927)
```javascript
const tasksWithConflicts = next.map(task => {
  const conflict = conflictMap.get(task.id);
  if (conflict) {
    return {
      ...task,
      fileConflict: true,
      conflictsWith: Array.from(conflict.conflictsWith),
      conflictingFiles: conflict.files
    };
  }
  return task;
});
```

**Step 3: Include in output** (lines 934-937)
```javascript
if (conflicts.length > 0) {
  output.fileConflicts = conflicts;
}
```

## How Conflicts Affect Task Batching

### Orchestrator Interpretation

When the orchestrator receives the `next` output, it should:

1. **Check for `fileConflicts` field** at top level
2. **If present**, run conflicting tasks sequentially (not in parallel)
3. **Use `conflictsWith` arrays** to determine execution order

### Example Orchestrator Logic

```python
def get_batch(next_output):
    tasks = next_output['tasks']
    conflicts = next_output.get('fileConflicts', [])

    if not conflicts:
        # No conflicts - all tasks can run in parallel
        return tasks

    # Build conflict groups
    conflict_groups = []
    for task in tasks:
        if task.get('fileConflict'):
            # Find or create conflict group
            group = find_group_for_task(conflict_groups, task)
            if group:
                group.append(task)
            else:
                conflict_groups.append([task])
        else:
            # Independent task - can run in parallel
            conflict_groups.append([task])

    # Run each group sequentially, tasks within group based on dependency
    return conflict_groups
```

### Conflict Grouping Example

**Input:** Tasks 2.1, 2.2 conflict on file A; Task 2.3 independent

```
Output from next:
├── 2.1 (fileConflict: true, conflictsWith: [2.2])
├── 2.2 (fileConflict: true, conflictsWith: [2.1])
└── 2.3 (no conflicts)

Execution groups:
├── Group 1 (sequential): [2.1, 2.2]
└── Group 2 (parallel): [2.3]
```

## Additional Output Fields

### Parallel Phase Information

When parallel phases are detected:

```json
{
  "parallelPhases": [
    {
      "phases": [1, 2, 3],
      "reason": "independent work"
    }
  ]
}
```

### Cross-Phase Execution

When tasks from multiple phases are ready:

```json
{
  "crossPhaseExecution": true,
  "activePhases": [1, 2]
}
```

### Pipeline-Start Triggers

When pipeline-start annotations are present:

```json
{
  "pipelineStartTriggers": [
    {
      "phase": 2,
      "triggerTask": "1.3"
    }
  ]
}
```

### Dependency Bypass Mode

When `--ignore-deps` is used:

```json
{
  "ignoreDeps": true,
  "tasks": [
    {
      "id": "2.3",
      "blockedBy": ["2.1", "2.2"],
      "reason": "pending - has unmet dependencies (ignored with --ignore-deps)"
    }
  ]
}
```

## In-Progress Task Handling

When tasks are already in progress:

```json
{
  "count": 1,
  "tasks": [
    {
      "id": "3.4",
      "status": "in_progress",
      "reason": "in_progress - should be completed first"
    }
  ]
}
```

Conflicts are still detected for in-progress tasks (lines 783-817).

## Failed Task Handling

Failed tasks are returned before pending tasks:

```json
{
  "count": 1,
  "tasks": [
    {
      "id": "2.1",
      "status": "failed",
      "reason": "failed - needs retry or manual intervention"
    }
  ]
}
```

## TUI Integration Points

### Data Available for TUI

| Data Point | Field Path | Use Case |
|------------|------------|----------|
| Conflict indicator | `task.fileConflict` | Show warning badge |
| Conflicting tasks | `task.conflictsWith[]` | Link to related tasks |
| Conflicting files | `task.conflictingFiles[]` | Show in detail panel |
| All conflicts | `output.fileConflicts[]` | Populate conflict matrix panel |
| Blocked count | `output.blockedTaskCount` | Show dependency status |
| Parallel phases | `output.parallelPhases[]` | Highlight parallel groups |
| Cross-phase | `output.crossPhaseExecution` | Show multi-phase indicator |

### Suggested TUI Displays

**Task List with Conflict Badges:**
```
┌────────────────────────────────────────┐
│ NEXT TASKS                             │
├────────────────────────────────────────┤
│ ◯ 2.1 Update API endpoint        ⚠    │
│ ◯ 2.2 Add auth middleware        ⚠    │
│ ◯ 2.3 Create utility helpers           │
└────────────────────────────────────────┘

⚠ = File conflict - run sequentially
```

**Conflict Detail Panel:**
```
┌────────────────────────────────────────┐
│ FILE CONFLICTS                         │
├────────────────────────────────────────┤
│ src/api.ts                             │
│   ├── 2.1: Update API endpoint         │
│   └── 2.2: Add auth middleware         │
│                                        │
│ Recommendation: Run 2.1 before 2.2    │
└────────────────────────────────────────┘
```

## Command Examples

```bash
# Get next 5 tasks with conflict info
node scripts/status-cli.js next 5

# Get tasks ignoring dependencies (shows blockedBy)
node scripts/status-cli.js next 5 --ignore-deps

# Get tasks from earliest phase only
node scripts/status-cli.js next 5 --phase-priority

# Parse output in scripts
node scripts/status-cli.js next 3 | jq '.fileConflicts'
```

## Summary Table

| Output Field | Level | Present When | Data Type |
|--------------|-------|--------------|-----------|
| `fileConflict` | task | Conflict exists | `boolean` |
| `conflictsWith` | task | Conflict exists | `string[]` |
| `conflictingFiles` | task | Conflict exists | `string[]` |
| `fileConflicts` | top | Any conflicts | `{file, taskIds}[]` |
| `parallelPhases` | top | [PARALLEL] annotation | `{phases, reason}[]` |
| `crossPhaseExecution` | top | Multi-phase ready | `boolean` |
| `activePhases` | top | Multi-phase ready | `number[]` |
| `pipelineStartTriggers` | top | pipeline-start annotation | `{phase, triggerTask}[]` |
| `blockedTaskCount` | top | Dependencies blocked | `number` |
| `ignoreDeps` | top | `--ignore-deps` flag | `boolean` |
| `phasePriority` | top | `--phase-priority` flag | `boolean` |
