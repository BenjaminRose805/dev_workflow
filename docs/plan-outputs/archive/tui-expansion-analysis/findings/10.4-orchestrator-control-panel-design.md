# Task 10.4: Orchestrator Control Panel Design

**Date:** 2025-12-26
**Purpose:** Design TUI panel for orchestrator runtime control
**Scope:** Pause/resume, batch size adjustment, retry controls, manual task selection, stuck task intervention

---

## Executive Summary

The Orchestrator Control Panel is an **architectural-level** expansion that provides runtime control over the orchestrator. This design specifies a control panel with pause/resume, batch size adjustment, retry controls, and stuck task intervention - all requiring IPC integration with the running orchestrator.

**Estimated Effort:** 36-48 hours (High - requires IPC infrastructure)
**Priority:** P1 (Essential for production use)

---

## 1. Panel Overview

### 1.1 Purpose

Enable runtime control of orchestrator execution:
- Pause execution after current task completes
- Resume paused execution
- Stop/shutdown gracefully
- Adjust batch size during execution
- Retry failed tasks
- Skip stuck or problematic tasks
- Manually select next task

### 1.2 IPC Requirements

This panel requires bidirectional communication with the orchestrator process:

| Operation | Direction | Mechanism |
|-----------|-----------|-----------|
| Query status | TUI → Orchestrator | IPC socket/file |
| Pause command | TUI → Orchestrator | IPC command |
| Resume command | TUI → Orchestrator | IPC command |
| Set batch size | TUI → Orchestrator | IPC command |
| Status updates | Orchestrator → TUI | status.json polling |
| Acknowledgments | Orchestrator → TUI | IPC response |

### 1.3 Data Sources

| Data | Source | Update Frequency |
|------|--------|------------------|
| Orchestrator state | IPC status query | 1s polling |
| Current batch size | IPC status query | On demand |
| Iteration count | status.json runs | 500ms |
| Failed tasks | status.json tasks | 500ms |
| Stuck detection | cmdDetectStuck() | 30s |
| Retry attempts | status.json retryCount | Per task |

---

## 2. Visual Design

### 2.1 Collapsed Control Bar

Always-visible control bar in footer or header:

```
┌─ Orchestrator ────────────────────────────────────────────────────────┐
│ ● RUNNING │ Iter: 12/50 │ Batch: 5 │ [P]ause [S]kip [+/-]Size [?]Help │
└───────────────────────────────────────────────────────────────────────┘
```

**State Indicators:**
| Symbol | State | Style |
|--------|-------|-------|
| `●` | RUNNING | Green |
| `⏸` | PAUSED | Yellow |
| `⏹` | STOPPED | Red |
| `⟳` | STARTING | Cyan |
| `⚠` | STUCK | Red blink |

### 2.2 Expanded Control Panel (Toggle with `Ctrl+O`)

Full control panel with all options:

```
┌─ Orchestrator Control Panel ──────────────────────────────────────────┐
│                                                                        │
│  ┌─ Execution State ───────────────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  State: ● RUNNING                                                │  │
│  │  Iteration: 12 of 50                                             │  │
│  │  Elapsed: 1h 23m 45s                                             │  │
│  │  Active Tasks: 3.1, 3.2, 4.1                                     │  │
│  │                                                                  │  │
│  │  [P] Pause after current  [R] Resume  [Q] Quit/Stop              │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  ┌─ Batch Size ────────────────────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  Current: 5 tasks per batch                                      │  │
│  │                                                                  │  │
│  │  [◄────────●─────────►]                                         │  │
│  │   1         5         10                                         │  │
│  │                                                                  │  │
│  │  [-] Decrease  [+] Increase  [Enter] Apply                       │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  ┌─ Task Actions ──────────────────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  Failed (2):                                                     │  │
│  │    ✗ 2.3 Create validation logic    [Retry 1/3]                 │  │
│  │    ✗ 2.5 Add error handling         [Retry 3/3 - Exhausted]     │  │
│  │                                                                  │  │
│  │  Actions:                                                        │  │
│  │    [r] Retry selected  [s] Skip selected  [e] Show error        │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  ┌─ Stuck Detection ───────────────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  ⚠ Task 3.1 may be stuck                                        │  │
│  │                                                                  │  │
│  │  Time: 28:45 / 30:00 threshold                                  │  │
│  │  Last activity: 5 min ago (Edit tool)                           │  │
│  │  Claude status: idle                                             │  │
│  │                                                                  │  │
│  │  [x] Extend +15 min  [k] Skip now  [r] Retry now                │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  [Esc] Close  [?] Help                                                │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.3 Pause/Resume States

When paused:

```
┌─ Orchestrator ────────────────────────────────────────────────────────┐
│ ⏸ PAUSED │ Will pause after: 3.1, 3.2 complete │ [R]esume [Q]uit     │
└───────────────────────────────────────────────────────────────────────┘
```

```
┌─ ⏸ Execution Paused ──────────────────────────────────────────────────┐
│                                                                        │
│  Paused at: 2:34:56 PM                                                 │
│  Duration: 5m 23s                                                      │
│                                                                        │
│  Waiting for completion:                                               │
│    ⏳ 3.1 Merge ORCHESTRATOR.md  [12:34 elapsed]                       │
│    ⏳ 3.2 Merge ARCHITECTURE.md  [8:21 elapsed]                        │
│                                                                        │
│  Next batch (when resumed):                                            │
│    ◯ 3.3 Create redirect file                                         │
│    ◯ 4.1 Add git status panel                                         │
│                                                                        │
│  [R] Resume now  [Q] Quit after current  [F] Force quit               │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.4 Batch Size Control

Interactive slider:

```
┌─ Batch Size Control ──────────────────────────────────────────────────┐
│                                                                        │
│  Current: 5 tasks per batch                                            │
│                                                                        │
│     1   2   3   4   5   6   7   8   9  10                             │
│    [◄───────────●─────────────────────►]                              │
│                 ▲                                                      │
│           Current setting                                              │
│                                                                        │
│  Impact preview:                                                       │
│    • 8 pending tasks → 2 more iterations                              │
│    • Parallelism: up to 5 concurrent tasks                            │
│    • Estimated: ~24 min remaining                                      │
│                                                                        │
│  [-] Decrease (4)  [+] Increase (6)  [Enter] Apply  [Esc] Cancel      │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.5 Failed Task Actions

```
┌─ Failed Tasks ────────────────────────────────────────────────────────┐
│                                                                        │
│  ┌─ ✗ 2.3 Create validation logic ─────────────────────────────────┐  │
│  │                                                                  │  │
│  │  Status: Failed (Retry 1/3)                                      │  │
│  │  Failed at: 2:15:32 PM                                           │  │
│  │  Duration: 12m 34s                                               │  │
│  │                                                                  │  │
│  │  Error:                                                          │  │
│  │  ┌────────────────────────────────────────────────────────────┐  │  │
│  │  │ TypeScript compilation failed:                              │  │  │
│  │  │   src/lib/validate.ts:45:12                                │  │  │
│  │  │   Property 'email' does not exist on type 'User'           │  │  │
│  │  └────────────────────────────────────────────────────────────┘  │  │
│  │                                                                  │  │
│  │  [r] Retry now  [s] Skip  [e] Full error  [d] Dependencies      │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  ┌─ ✗ 2.5 Add error handling ───────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  Status: Exhausted (Retry 3/3)                                   │  │
│  │  Next action: Manual intervention required                       │  │
│  │                                                                  │  │
│  │  [r] Force retry  [s] Skip  [e] Full error  [m] Manual mode      │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.6 Stuck Task Intervention

```
┌─ ⚠ Stuck Task Detected ───────────────────────────────────────────────┐
│                                                                        │
│  Task 3.1: Merge ORCHESTRATOR.md                                       │
│                                                                        │
│  ┌─ Stuck Indicators ──────────────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  Time Running:     28:45 / 30:00 threshold                       │  │
│  │  Progress Bar:     [████████████████████████░░░░░░] 96%         │  │
│  │                                                                  │  │
│  │  Last Tool:        Edit (12 min ago)                             │  │
│  │  Last Output:      "Updating section headers..." (8 min ago)     │  │
│  │  Claude Status:    Idle / Waiting                                │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  ┌─ Intervention Options ──────────────────────────────────────────┐  │
│  │                                                                  │  │
│  │  ○ [x] Extend threshold +15 min                                  │  │
│  │        Give more time, task may still be working                 │  │
│  │                                                                  │  │
│  │  ○ [k] Skip this task                                            │  │
│  │        Mark as skipped, continue with next                       │  │
│  │                                                                  │  │
│  │  ○ [r] Retry from beginning                                      │  │
│  │        Stop current attempt, start fresh                         │  │
│  │                                                                  │  │
│  │  ○ [m] Manual mode                                               │  │
│  │        Pause orchestrator, take manual control                   │  │
│  │                                                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                        │
│  Auto-action in: 1:15 (will skip)                                     │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

---

## 3. Implementation Specification

### 3.1 IPC Protocol

#### Command Format

```python
class IPCCommand:
    """IPC command structure."""

    # Commands
    STATUS = "status"
    PAUSE = "pause"
    RESUME = "resume"
    SHUTDOWN = "shutdown"
    SET_BATCH_SIZE = "set_batch_size"
    RETRY_TASK = "retry_task"
    SKIP_TASK = "skip_task"
    EXTEND_THRESHOLD = "extend_threshold"

    def __init__(self, command: str, payload: Optional[Dict] = None):
        self.command = command
        self.payload = payload or {}
        self.timestamp = datetime.now().isoformat()
        self.id = str(uuid.uuid4())[:8]

    def to_json(self) -> str:
        return json.dumps({
            "id": self.id,
            "command": self.command,
            "payload": self.payload,
            "timestamp": self.timestamp
        })
```

#### Response Format

```python
class IPCResponse:
    """IPC response structure."""

    def __init__(self, command_id: str, success: bool, data: Optional[Dict] = None, error: Optional[str] = None):
        self.command_id = command_id
        self.success = success
        self.data = data or {}
        self.error = error
        self.timestamp = datetime.now().isoformat()

    def to_json(self) -> str:
        return json.dumps({
            "command_id": self.command_id,
            "success": self.success,
            "data": self.data,
            "error": self.error,
            "timestamp": self.timestamp
        })
```

### 3.2 New Python Classes

#### OrchestratorControlPanel

```python
from enum import Enum
from typing import Optional, Dict, List, Callable

class OrchestratorState(Enum):
    RUNNING = "running"
    PAUSED = "paused"
    PAUSING = "pausing"  # Waiting for current tasks
    STOPPED = "stopped"
    STARTING = "starting"
    STUCK = "stuck"

class OrchestratorControlPanel:
    """Orchestrator control panel for TUI."""

    def __init__(self, ipc_client: 'IPCClient', config: Optional[Dict] = None):
        self.ipc = ipc_client
        self.config = config or {}
        self.expanded = False

        # State
        self.state = OrchestratorState.STOPPED
        self.iteration = 0
        self.max_iterations = 50
        self.batch_size = 5
        self.pending_batch_size: Optional[int] = None

        # Tasks
        self.active_tasks: List[Dict] = []
        self.failed_tasks: List[Dict] = []
        self.stuck_tasks: List[Dict] = []

        # Selected items
        self.selected_failed = 0
        self.selected_stuck = 0

    def refresh(self) -> None:
        """Query orchestrator state via IPC."""
        response = self.ipc.send(IPCCommand(IPCCommand.STATUS))
        if response.success:
            self._update_from_status(response.data)

    def _update_from_status(self, data: Dict) -> None:
        """Update panel state from IPC response."""
        self.state = OrchestratorState(data.get('state', 'stopped'))
        self.iteration = data.get('iteration', 0)
        self.max_iterations = data.get('maxIterations', 50)
        self.batch_size = data.get('batchSize', 5)
        self.active_tasks = data.get('activeTasks', [])
        self.failed_tasks = data.get('failedTasks', [])
        self.stuck_tasks = data.get('stuckTasks', [])

    # Control Actions

    def pause(self) -> bool:
        """Request pause after current tasks complete."""
        response = self.ipc.send(IPCCommand(IPCCommand.PAUSE))
        if response.success:
            self.state = OrchestratorState.PAUSING
        return response.success

    def resume(self) -> bool:
        """Resume paused execution."""
        response = self.ipc.send(IPCCommand(IPCCommand.RESUME))
        if response.success:
            self.state = OrchestratorState.RUNNING
        return response.success

    def shutdown(self, force: bool = False) -> bool:
        """Request graceful or forced shutdown."""
        response = self.ipc.send(IPCCommand(
            IPCCommand.SHUTDOWN,
            {"force": force}
        ))
        return response.success

    def set_batch_size(self, size: int) -> bool:
        """Set new batch size."""
        if size < 1 or size > 10:
            return False
        response = self.ipc.send(IPCCommand(
            IPCCommand.SET_BATCH_SIZE,
            {"size": size}
        ))
        if response.success:
            self.batch_size = size
        return response.success

    def retry_task(self, task_id: str) -> bool:
        """Retry a failed task."""
        response = self.ipc.send(IPCCommand(
            IPCCommand.RETRY_TASK,
            {"taskId": task_id}
        ))
        return response.success

    def skip_task(self, task_id: str, reason: str = "") -> bool:
        """Skip a stuck or failed task."""
        response = self.ipc.send(IPCCommand(
            IPCCommand.SKIP_TASK,
            {"taskId": task_id, "reason": reason}
        ))
        return response.success

    def extend_threshold(self, task_id: str, minutes: int = 15) -> bool:
        """Extend stuck threshold for a task."""
        response = self.ipc.send(IPCCommand(
            IPCCommand.EXTEND_THRESHOLD,
            {"taskId": task_id, "minutes": minutes}
        ))
        return response.success

    # Rendering

    def render_collapsed(self) -> Text:
        """Render collapsed control bar."""
        text = Text()

        # State indicator
        state_display = {
            OrchestratorState.RUNNING: ("●", "green"),
            OrchestratorState.PAUSED: ("⏸", "yellow"),
            OrchestratorState.PAUSING: ("⏸", "yellow blink"),
            OrchestratorState.STOPPED: ("⏹", "red"),
            OrchestratorState.STARTING: ("⟳", "cyan"),
            OrchestratorState.STUCK: ("⚠", "red blink"),
        }
        symbol, style = state_display.get(self.state, ("?", "dim"))
        text.append(f"{symbol} {self.state.value.upper()}", style=style)

        text.append("  │  ", style="dim")

        # Iteration
        text.append(f"Iter: {self.iteration}/{self.max_iterations}", style="cyan")
        text.append("  │  ", style="dim")

        # Batch size
        text.append(f"Batch: {self.batch_size}", style="cyan")
        text.append("  │  ", style="dim")

        # Controls hint
        controls = "[P]ause " if self.state == OrchestratorState.RUNNING else "[R]esume "
        controls += "[S]kip [+/-]Size [?]Help"
        text.append(controls, style="dim")

        return text

    def render_expanded(self) -> Panel:
        """Render full control panel."""
        layout = Layout()

        layout.split(
            Layout(name="state", size=8),
            Layout(name="middle", size=8),
            Layout(name="bottom", size=10)
        )

        layout["middle"].split_row(
            Layout(name="batch"),
            Layout(name="actions")
        )

        layout["state"].update(self._render_state())
        layout["batch"].update(self._render_batch_control())
        layout["actions"].update(self._render_task_actions())
        layout["bottom"].update(self._render_stuck_panel())

        return Panel(layout, title="Orchestrator Control", border_style="cyan")

    def _render_state(self) -> Panel:
        """Render execution state section."""
        table = Table(show_header=False, box=None, expand=True)
        table.add_column("Key", width=15, style="dim")
        table.add_column("Value")

        # State
        state_display = {
            OrchestratorState.RUNNING: ("● RUNNING", "green"),
            OrchestratorState.PAUSED: ("⏸ PAUSED", "yellow"),
            OrchestratorState.PAUSING: ("⏸ PAUSING...", "yellow"),
            OrchestratorState.STOPPED: ("⏹ STOPPED", "red"),
        }
        state_text, style = state_display.get(self.state, ("?", "dim"))
        table.add_row("State:", Text(state_text, style=style))

        # Iteration
        table.add_row("Iteration:", f"{self.iteration} of {self.max_iterations}")

        # Active tasks
        if self.active_tasks:
            task_ids = ", ".join(t['id'] for t in self.active_tasks[:3])
            if len(self.active_tasks) > 3:
                task_ids += f" +{len(self.active_tasks) - 3}"
            table.add_row("Active:", task_ids)

        table.add_row("", "")

        # Controls
        if self.state == OrchestratorState.RUNNING:
            table.add_row("", Text("[P] Pause  [Q] Quit", style="dim cyan"))
        elif self.state == OrchestratorState.PAUSED:
            table.add_row("", Text("[R] Resume  [Q] Quit", style="dim cyan"))

        return Panel(table, title="Execution State", border_style="green")

    def _render_batch_control(self) -> Panel:
        """Render batch size control."""
        content = []

        # Current size
        content.append(f"Current: {self.batch_size} tasks per batch\n")

        # Visual slider
        slider = "["
        for i in range(1, 11):
            if i == self.batch_size:
                slider += "●"
            elif i < self.batch_size:
                slider += "─"
            else:
                slider += "─"
        slider += "]"
        content.append(f"  1 {slider} 10\n")

        # Controls
        content.append("\n[-] Decrease  [+] Increase")

        return Panel(
            Text("".join(content)),
            title="Batch Size",
            border_style="blue"
        )

    def _render_task_actions(self) -> Panel:
        """Render failed task actions."""
        if not self.failed_tasks:
            return Panel(
                Text("No failed tasks", style="dim green"),
                title="Task Actions",
                border_style="dim"
            )

        table = Table(show_header=False, box=None, expand=True)
        table.add_column()

        for i, task in enumerate(self.failed_tasks[:3]):
            is_selected = i == self.selected_failed
            retry_count = task.get('retryCount', 0)
            max_retries = 3

            status = f"[Retry {retry_count}/{max_retries}]"
            if retry_count >= max_retries:
                status = "[Exhausted]"

            style = "cyan" if is_selected else "dim"
            table.add_row(Text(f"  {'●' if is_selected else '○'} ✗ {task['id']} {status}", style=style))

        table.add_row("")
        table.add_row(Text("[r] Retry  [s] Skip  [e] Error", style="dim cyan"))

        return Panel(table, title=f"Failed ({len(self.failed_tasks)})", border_style="red")

    def _render_stuck_panel(self) -> Panel:
        """Render stuck task intervention panel."""
        if not self.stuck_tasks:
            return Panel(
                Text("No stuck tasks detected", style="dim green"),
                title="Stuck Detection",
                border_style="dim"
            )

        task = self.stuck_tasks[0]  # Focus on first stuck task

        table = Table(show_header=False, box=None, expand=True)
        table.add_column("Key", width=15, style="dim")
        table.add_column("Value")

        table.add_row("Task:", Text(f"⚠ {task['id']}: {task.get('description', '')[:40]}", style="yellow"))

        # Time info
        elapsed = task.get('elapsed', 0)
        threshold = task.get('threshold', 1800)
        remaining = max(0, threshold - elapsed)
        table.add_row("Time:", f"{elapsed // 60}:{elapsed % 60:02d} / {threshold // 60}:00")
        table.add_row("Remaining:", f"{remaining // 60}:{remaining % 60:02d}")

        # Last activity
        last_tool = task.get('lastTool', 'unknown')
        last_activity = task.get('lastActivityAgo', 'unknown')
        table.add_row("Last Tool:", f"{last_tool} ({last_activity} ago)")

        table.add_row("", "")
        table.add_row("Actions:", Text("[x] Extend  [k] Skip  [r] Retry", style="dim cyan"))

        return Panel(table, title="⚠ Stuck Detection", border_style="red")

    def handle_key(self, key: str) -> bool:
        """Handle keyboard input."""
        if key.lower() == 'p' and self.state == OrchestratorState.RUNNING:
            return self.pause()
        elif key.lower() == 'r' and self.state == OrchestratorState.PAUSED:
            return self.resume()
        elif key.lower() == 'q':
            return self.shutdown()
        elif key == '+':
            return self.set_batch_size(self.batch_size + 1)
        elif key == '-':
            return self.set_batch_size(self.batch_size - 1)
        elif key.lower() == 'x' and self.stuck_tasks:
            return self.extend_threshold(self.stuck_tasks[0]['id'])
        elif key.lower() == 'k' and self.stuck_tasks:
            return self.skip_task(self.stuck_tasks[0]['id'])
        return False

    def toggle(self) -> None:
        """Toggle expanded/collapsed state."""
        self.expanded = not self.expanded
        if self.expanded:
            self.refresh()
```

### 3.3 IPC Client

```python
class IPCClient:
    """Client for communicating with orchestrator via IPC."""

    def __init__(self, socket_path: str = "/tmp/orchestrator.sock"):
        self.socket_path = socket_path
        self.timeout = 5.0

    def send(self, command: IPCCommand) -> IPCResponse:
        """Send command and wait for response."""
        try:
            # File-based IPC (simpler than socket)
            cmd_file = f"{self.socket_path}.cmd.{command.id}"
            resp_file = f"{self.socket_path}.resp.{command.id}"

            # Write command
            with open(cmd_file, 'w') as f:
                f.write(command.to_json())

            # Wait for response
            start = time.time()
            while time.time() - start < self.timeout:
                if os.path.exists(resp_file):
                    with open(resp_file) as f:
                        data = json.load(f)
                    os.remove(resp_file)
                    os.remove(cmd_file)
                    return IPCResponse(
                        command_id=data['command_id'],
                        success=data['success'],
                        data=data.get('data'),
                        error=data.get('error')
                    )
                time.sleep(0.1)

            return IPCResponse(command.id, False, error="Timeout")

        except Exception as e:
            return IPCResponse(command.id, False, error=str(e))

    def is_connected(self) -> bool:
        """Check if orchestrator is running."""
        response = self.send(IPCCommand(IPCCommand.STATUS))
        return response.success
```

### 3.4 Keyboard Mappings

| Key | Context | Action |
|-----|---------|--------|
| `Ctrl+O` | Global | Toggle control panel |
| `P` | Running | Pause after current |
| `R` | Paused | Resume execution |
| `Q` | Any | Quit/shutdown modal |
| `+` | Any | Increase batch size |
| `-` | Any | Decrease batch size |
| `r` | Failed selected | Retry task |
| `s` | Failed selected | Skip task |
| `e` | Failed selected | Show error |
| `x` | Stuck task | Extend threshold |
| `k` | Stuck task | Skip now |

---

## 4. Data Contract

### 4.1 Orchestrator Status Object

```typescript
interface OrchestratorStatus {
  state: 'running' | 'paused' | 'pausing' | 'stopped' | 'starting' | 'stuck';
  iteration: number;
  maxIterations: number;
  batchSize: number;
  startedAt: string;
  elapsed: number;  // seconds
  activeTasks: Array<{
    id: string;
    description: string;
    startedAt: string;
    elapsed: number;
  }>;
  failedTasks: Array<{
    id: string;
    description: string;
    failedAt: string;
    retryCount: number;
    maxRetries: number;
    lastError: string;
  }>;
  stuckTasks: Array<{
    id: string;
    description: string;
    elapsed: number;
    threshold: number;
    lastTool: string;
    lastActivityAgo: string;
  }>;
  stats: {
    completed: number;
    failed: number;
    skipped: number;
    pending: number;
  };
}
```

---

## 5. Effort Estimate

### 5.1 Implementation Breakdown

| Component | Effort | Priority |
|-----------|--------|----------|
| IPC Protocol design | 4 hours | P0 |
| IPC Client class | 4 hours | P0 |
| Orchestrator IPC handlers | 8 hours | P0 |
| OrchestratorControlPanel class | 6 hours | P0 |
| Collapsed control bar | 2 hours | P0 |
| Execution state section | 2 hours | P0 |
| Batch size control | 2 hours | P0 |
| Failed task actions | 3 hours | P0 |
| Stuck detection section | 3 hours | P0 |
| Keyboard handling | 2 hours | P0 |
| **Subtotal Core:** | **36 hours** | - |
| Error detail modal | 3 hours | P1 |
| Skip with reason modal | 2 hours | P1 |
| Force quit confirmation | 2 hours | P1 |
| Batch size impact preview | 3 hours | P2 |
| **Subtotal Enhanced:** | **10 hours** | - |
| **Total:** | **46 hours** | - |

### 5.2 Recommended Implementation

**MVP (Core):** 36 hours
- IPC protocol and client
- Orchestrator IPC handlers
- Basic control panel with all sections
- Pause/resume/quit controls
- Batch size +/- controls
- Retry/skip for failed tasks
- Extend/skip for stuck tasks

**Full Feature:** 46 hours
- All MVP features
- Error detail modal
- Skip with reason
- Force quit confirmation
- Batch size impact preview

---

## 6. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| IPC complexity | HIGH | HIGH | Start with file-based, upgrade later |
| Race conditions | MEDIUM | HIGH | Use atomic operations, proper locking |
| Orphaned commands | LOW | MEDIUM | Command timeout, cleanup |
| State desync | MEDIUM | MEDIUM | Polling + push updates |

---

## 7. Success Criteria

### 7.1 Functional Requirements

- [ ] Pause execution after current tasks
- [ ] Resume paused execution
- [ ] Graceful shutdown
- [ ] Batch size adjustment (1-10)
- [ ] Retry failed tasks
- [ ] Skip stuck/failed tasks
- [ ] Extend stuck threshold
- [ ] Real-time state updates

### 7.2 Quality Requirements

- [ ] IPC latency <100ms
- [ ] Commands acknowledged within 1s
- [ ] No orphaned commands
- [ ] Graceful degradation if orchestrator unreachable

### 7.3 Integration Requirements

- [ ] IPC handlers in plan_orchestrator.py
- [ ] Control panel in TUI
- [ ] Keyboard mappings documented

---

## 8. Related Documents

- Task 8.4: Stuck detection analysis
- Task 8.5: Orchestrator TUI control mapping
- Task 9.4: Orchestrator gaps analysis
- Task 10.2: Parallel Execution Dashboard

---

**End of Design**
