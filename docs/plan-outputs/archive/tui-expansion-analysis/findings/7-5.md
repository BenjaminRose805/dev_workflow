# Task 7.5: Map Batching System to TUI Visualization

## Analysis Overview

This analysis maps the batching system capabilities to potential TUI visualizations, including current batch panels, batch size controls, parallelism indicators, batch history, and batch composition explainers.

## Current TUI Capabilities (Baseline)

### Existing Layout Structure

```python
# scripts/lib/tui.py:213-230
def _create_layout(self) -> Layout:
    """Create the TUI layout structure."""
    layout = Layout()

    layout.split(
        Layout(name="header", size=5),
        Layout(name="progress", size=3),
        Layout(name="activity", size=10),
        Layout(name="tasks", size=8),
        Layout(name="footer", size=2)
    )

    # Split tasks section into two columns
    layout["tasks"].split_row(
        Layout(name="in_progress"),
        Layout(name="completions")
    )

    return layout
```

### Existing Data Available

| Data | Source | Update Frequency |
|------|--------|------------------|
| Tasks in progress | status.json | 500ms polling |
| Recent completions | status.json | 500ms polling |
| Tool activity | Claude runner callbacks | Real-time |
| Progress counts | status.json | 500ms polling |
| Current phase | status.json | 500ms polling |

## Proposed TUI Expansions

### 1. Current Batch Panel

**Purpose**: Show grouped tasks executing in current batch

**Data Source**: `cmdNext()` output + status.json in_progress tasks

**Visualization Design**:

```
â”Œâ”€ Current Batch (3 tasks) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                       â”‚
â”‚ [PARALLEL] Phase 3-4 enabled                          â”‚
â”‚                                                       â”‚
â”‚ â³ 3.1 Merge ORCHESTRATOR.md         [====    ] 45%  â”‚
â”‚ âœ“ 3.2 Merge ARCHITECTURE.md         [========] 100% â”‚
â”‚ â³ 4.1 Add git status panel          [==      ] 25%  â”‚
â”‚                                                       â”‚
â”‚ âš  Held back: 3.3 (sequential with 3.1)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Approach**:

```python
def _render_batch(self) -> Panel:
    """Render current batch panel."""
    table = Table(show_header=False, box=None, expand=True)
    table.add_column("Status", width=3)
    table.add_column("Task", overflow="ellipsis")
    table.add_column("Progress", width=12)

    for task in self.current_batch:
        status_icon = self._get_status_icon(task['status'])
        progress_bar = self._mini_progress(task.get('progress', 0))
        table.add_row(status_icon, f"{task['id']} {task['description']}", progress_bar)

    # Show held back tasks
    if self.held_back_tasks:
        table.add_row("", Text("â”€" * 40, style="dim"), "")
        for task in self.held_back_tasks:
            reason = task.get('heldReason', 'constraint')
            table.add_row("â¸", Text(f"{task['id']} ({reason})", style="dim"), "")

    title = f"Current Batch ({len(self.current_batch)} tasks)"
    if self.parallel_phases_active:
        title += " [PARALLEL]"

    return Panel(table, title=title, border_style="cyan")
```

### 2. Batch Size Adjustment Slider/Control

**Purpose**: Allow runtime adjustment of batch size

**Current Implementation**:
- `--batch-size` CLI flag (default: 5)
- Fixed during orchestrator run

**Proposed Enhancement**:

```
â”Œâ”€ Batch Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                       â”‚
â”‚ Batch Size: [â—„â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â–º] 5                       â”‚
â”‚             1              10                         â”‚
â”‚                                                       â”‚
â”‚ Mode: â—‹ Sequential  â— Parallel  â—‹ Phase-priority      â”‚
â”‚                                                       â”‚
â”‚ [Pause] [Skip Current] [Retry Failed]                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Approach**:

1. Add IPC command for batch size adjustment:
```python
elif command == "set_batch_size":
    new_size = payload.get("size", 5)
    if 1 <= new_size <= 10:
        self.batch_size = new_size
        return {"ack": True, "new_size": new_size}
```

2. TUI keyboard handler:
```python
def handle_key(self, key: str):
    if key == '+':
        self.send_ipc("set_batch_size", {"size": self.batch_size + 1})
    elif key == '-':
        self.send_ipc("set_batch_size", {"size": self.batch_size - 1})
```

### 3. Parallelism Indicator (N tasks running)

**Purpose**: Show real-time concurrency level

**Data Available**:
- `in_progress_count` from status.json
- Agent spawn count from ActivityTracker
- Active tools from ActivityTracker

**Visualization Design**:

```
â”Œâ”€ Parallelism â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                       â”‚
â”‚ Tasks:  [â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘] 3/10 in parallel                 â”‚
â”‚ Agents: [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘] 4/10 active                      â”‚
â”‚ Tools:  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 10 active                        â”‚
â”‚                                                       â”‚
â”‚ Peak: 5 tasks / 8 agents (12:34:56)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Approach**:

```python
class ParallelismTracker:
    def __init__(self):
        self.current_tasks = 0
        self.current_agents = 0
        self.peak_tasks = 0
        self.peak_agents = 0
        self.peak_time = None

    def update(self, tasks: int, agents: int):
        self.current_tasks = tasks
        self.current_agents = agents
        if tasks > self.peak_tasks or agents > self.peak_agents:
            self.peak_tasks = max(self.peak_tasks, tasks)
            self.peak_agents = max(self.peak_agents, agents)
            self.peak_time = datetime.now()
```

### 4. Batch History with Timing Stats

**Purpose**: Show historical batch performance

**Data Source**: Run records from status.json

**Visualization Design**:

```
â”Œâ”€ Batch History â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                       â”‚
â”‚ #12  14:32:15  5 tasks  âœ“âœ“âœ“âœ“âœ“         2m 34s         â”‚
â”‚ #11  14:29:41  4 tasks  âœ“âœ“âœ“âœ—          3m 12s         â”‚
â”‚ #10  14:26:29  5 tasks  âœ“âœ“âœ“âœ“âœ“         1m 45s         â”‚
â”‚ #9   14:24:44  3 tasks  âœ“âœ“âœ“           0m 58s         â”‚
â”‚                                                       â”‚
â”‚ Avg: 4.2 tasks/batch  |  Avg time: 2m 12s            â”‚
â”‚ Success rate: 92% (23/25 tasks)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Data Structure Enhancement**:

```typescript
interface BatchHistory {
  batchNumber: number;
  timestamp: string;
  taskCount: number;
  completed: number;
  failed: number;
  duration: number;  // seconds
}
```

**Implementation Approach**:

```python
def _render_batch_history(self) -> Panel:
    """Render batch history panel."""
    table = Table(show_header=True, box=None, expand=True)
    table.add_column("#", width=4)
    table.add_column("Time", width=10)
    table.add_column("Tasks", width=8)
    table.add_column("Result", width=12)
    table.add_column("Duration", width=10)

    for batch in self.batch_history[-5:]:
        result = "âœ“" * batch.completed + "âœ—" * batch.failed
        duration = f"{batch.duration // 60}m {batch.duration % 60}s"
        table.add_row(
            str(batch.number),
            batch.timestamp.strftime("%H:%M:%S"),
            str(batch.task_count),
            result,
            duration
        )

    # Summary stats
    avg_size = sum(b.task_count for b in self.batch_history) / len(self.batch_history)
    avg_duration = sum(b.duration for b in self.batch_history) / len(self.batch_history)

    return Panel(table, title="Batch History", border_style="blue")
```

### 5. "Why Batched This Way?" Explainer Panel

**Purpose**: Explain batch composition decisions

**Data Sources**:
- Constraint metadata from cmdNext()
- Sequential annotations
- File conflict detection
- Dependency graph

**Visualization Design**:

```
â”Œâ”€ Batch Composition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                       â”‚
â”‚ Current batch includes 3 tasks from 2 phases:         â”‚
â”‚                                                       â”‚
â”‚ âœ“ 3.1, 3.2 - Same phase, no conflicts                â”‚
â”‚ âœ“ 4.1     - [PARALLEL] phases 3-4 enabled            â”‚
â”‚                                                       â”‚
â”‚ Excluded from batch:                                  â”‚
â”‚ â¸ 3.3 - Sequential with 3.1 (same file)              â”‚
â”‚ â¸ 3.4 - Depends on 3.3                               â”‚
â”‚ ğŸš« 5.1 - Depends on 4.2 (not started)                â”‚
â”‚                                                       â”‚
â”‚ [?] Tap for constraint details                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Approach**:

```python
class BatchExplainer:
    def explain(self, selected: List[Task], held_back: List[Task]) -> List[str]:
        explanations = []

        # Group selected by reason
        by_phase = defaultdict(list)
        for task in selected:
            by_phase[task.phase].append(task)

        for phase, tasks in by_phase.items():
            ids = ", ".join(t.id for t in tasks)
            if len(tasks) > 1:
                explanations.append(f"âœ“ {ids} - Same phase, no conflicts")
            else:
                explanations.append(f"âœ“ {ids} - Ready to execute")

        # Explain held back
        for task in held_back:
            if task.get('sequential'):
                group = task.get('sequentialGroup')
                explanations.append(f"â¸ {task.id} - Sequential with {group}")
            elif task.get('blockedBy'):
                deps = ", ".join(task['blockedBy'])
                explanations.append(f"ğŸš« {task.id} - Depends on {deps}")
            elif task.get('fileConflict'):
                explanations.append(f"âš  {task.id} - File conflict with batch")

        return explanations
```

## Layout Integration

### Proposed Full Layout

```
â”Œâ”€ PLAN ORCHESTRATOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Plan: my-plan  |  Phase: 3  |  Iteration: 12/50       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€ Progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 45%          â”‚
â”‚ 23/51 tasks  |  Working: 3  |  Pending: 25  |  â³     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€ Current Batch (3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â³ 3.1 Merge ORCHESTRATOR.md          [====    ] 45%  â”‚
â”‚ âœ“ 3.2 Merge ARCHITECTURE.md          [========]      â”‚
â”‚ â³ 4.1 Add git status panel           [==      ] 25%  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€ Tool Activity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [14:32:15] [OK] Read: orchestrator.md         120ms   â”‚
â”‚ [14:32:16] ... Edit: orchestrator.md          ...     â”‚
â”‚ [14:32:17] [OK] Task: merge content            3.2s   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€ Batch Explainer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€ Batch History â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Current batch:                â”‚ #12 âœ“âœ“âœ“âœ“âœ“  2m 34s    â”‚
â”‚ âœ“ 3.1, 3.2 - Same phase       â”‚ #11 âœ“âœ“âœ“âœ—   3m 12s    â”‚
â”‚ âœ“ 4.1 - [PARALLEL] enabled    â”‚ #10 âœ“âœ“âœ“âœ“âœ“  1m 45s    â”‚
â”‚                               â”‚                       â”‚
â”‚ Held: 3.3 (sequential)        â”‚ Avg: 4.2 tasks/batch  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€ Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Running tasks 3.1, 3.2, 4.1  |  Tools: 47  |  +/-: 5  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Implementation Priority Matrix

| Panel | Value | Effort | Priority |
|-------|-------|--------|----------|
| Current Batch Panel | HIGH | MEDIUM | 1 |
| Parallelism Indicator | MEDIUM | LOW | 2 |
| "Why Batched" Explainer | HIGH | MEDIUM | 3 |
| Batch History | MEDIUM | MEDIUM | 4 |
| Batch Size Controls | LOW | HIGH | 5 |

## Key Data Requirements

### From status.json
- Tasks with in_progress status
- Recent completions
- Run history (for batch history)

### From cmdNext() output
- Selected tasks with constraint metadata
- Held back tasks with reasons
- Parallel phase info
- File conflicts

### From orchestrator
- Current batch size setting
- Sequential filtering decisions
- Iteration count

### From activity tracker
- Active agents count
- Tool invocation counts
- Duration statistics

## Key Findings

1. **Rich Data Available**: cmdNext() already returns all constraint metadata needed for visualization

2. **Current TUI Limited**: Only shows in_progress/completed split; no batch composition view

3. **Explainer High Value**: Understanding "why batched this way" aids debugging and trust

4. **History Enables Optimization**: Batch timing stats can inform batch size tuning

5. **Control Integration Complex**: Runtime batch size changes require IPC infrastructure

6. **Layout Space Constrained**: Need to balance detail vs screen real estate

## Files Analyzed

- `scripts/lib/tui.py:170-464` - Current TUI implementation
- `scripts/status-cli.js:697-978` - cmdNext() output format
- `scripts/plan_orchestrator.py:321-367` - Sequential filtering
- `scripts/plan_orchestrator.py:974-1015` - Batch prompt building
