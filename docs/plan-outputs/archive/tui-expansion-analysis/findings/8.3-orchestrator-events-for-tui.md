# Task 8.3: Orchestrator Events Suitable for TUI Streaming

**Date:** 2025-12-26
**Source:** Analysis of `plan_orchestrator.py`, `claude_runner.py`, `status_monitor.py`, `tui.py`
**Purpose:** Identify all events that can be streamed to TUI for real-time display

---

## Executive Summary

The orchestrator system currently emits events through **3 channels**: StreamingClaudeRunner callbacks, StatusMonitor file watching, and direct TUI method calls. This analysis catalogs all event types and identifies gaps where additional events would enhance TUI visibility.

---

## Current Event Channels

### Channel 1: StreamingClaudeRunner Callbacks

**Source:** `scripts/lib/claude_runner.py`

The streaming runner parses Claude CLI's `stream-json` format and fires callbacks:

| Event | Callback | Data Provided | TUI Usage |
|-------|----------|---------------|-----------|
| Tool Start | `on_tool_start(tool_name, details)` | Tool name, ID, input params | Activity panel |
| Tool End | `on_tool_end(tool_name, tool_id, duration)` | Tool name, ID, duration | Activity panel |
| Text Output | `on_text(text)` | Raw text output | Not currently used |

**Claude CLI Event Types Parsed:**
```python
# From _parse_json_line()
- type: "assistant" + tool_use → Tool invocation starting
- type: "user" + tool_result → Tool completed
- type: "assistant" + text → Text output
- type: "result" → Session completion
```

**TUI Integration Points:**
```python
# In plan_orchestrator.py
self.streaming_runner = StreamingClaudeRunner(
    on_tool_start=self._on_tool_start,
    on_tool_end=self._on_tool_end,
    timeout=self.timeout,
    working_dir=self.working_dir,
    worktree_path=self.worktree_path
)
```

---

### Channel 2: StatusMonitor File Watching

**Source:** `scripts/lib/status_monitor.py`

The status monitor watches `status.json` for changes and invokes a callback:

| Event | Callback | Data Provided | TUI Usage |
|-------|----------|---------------|-----------|
| Status Change | `callback(status_data)` | Full status.json content | Progress, task lists |

**Monitoring Mechanism:**
- Polling: 500ms interval (default)
- inotify: Immediate on file change (Linux)

**Status Data Provided:**
```python
{
  "tasks": [...],          # All tasks with status
  "summary": {
    "totalTasks": N,
    "completed": N,
    "pending": N,
    "in_progress": N,
    "failed": N
  },
  "currentPhase": "Phase 1: ...",
  "runs": [...]
}
```

**TUI Update Flow:**
```python
# In _on_status_update()
self.tui.set_progress(completed, total, pending, failed, in_progress)
self.tui.set_phase(current_phase)
self.tui.update_tasks(in_progress_tasks, completed_tasks)
```

---

### Channel 3: Direct TUI Method Calls

**Source:** `scripts/plan_orchestrator.py` main loop

The orchestrator directly calls TUI methods at key points:

| Event | TUI Method | When Called |
|-------|------------|-------------|
| Iteration Start | `set_iteration(n, max)` | Each loop iteration |
| Claude Session Start | `set_claude_running(True)` | Before Claude spawn |
| Claude Session End | `set_claude_running(False)` | After Claude exits |
| Status Message | `set_status(message)` | Various state changes |
| Progress Update | `set_progress(...)` | After status check |
| Phase Update | `set_phase(phase)` | After status check |
| Stuck Detection | `set_status(f"Detected {n} stuck...")` | When stuck found |
| Retry Attempt | `set_status(f"Retry #{n}...")` | Before retry |
| Completion | `set_status("Plan complete!")` | On success |
| Shutdown | `set_status("Shutdown requested")` | On graceful stop |

---

## Events Currently Captured

### High-Fidelity Events (Real-Time)

| Event Category | Source | Latency | TUI Component |
|----------------|--------|---------|---------------|
| Tool invocations | StreamingRunner | <100ms | Activity panel |
| Tool completions | StreamingRunner | <100ms | Activity panel |
| Claude active state | Direct call | <100ms | Progress spinner |

### Medium-Fidelity Events (Polling)

| Event Category | Source | Latency | TUI Component |
|----------------|--------|---------|---------------|
| Task status changes | StatusMonitor | 500ms | Task lists |
| Progress updates | StatusMonitor | 500ms | Progress bar |
| Phase transitions | StatusMonitor | 500ms | Header |

### Low-Fidelity Events (Periodic)

| Event Category | Source | Latency | TUI Component |
|----------------|--------|---------|---------------|
| Iteration counts | Direct call | Per iteration | Header |
| Status messages | Direct call | Per iteration | Footer |

---

## Events NOT Currently Captured

### Gap 1: Parallel Agent Spawn/Complete

**Missing Event:** When a Task tool spawns sub-agents

**Source:** Claude CLI doesn't emit structured agent lifecycle events
**Workaround:** Parse `Task` tool_use content for agent descriptions
**TUI Opportunity:** Agent tracker panel showing parallel agent status

**Detection Pattern:**
```python
if tool_name == 'Task':
    agent_desc = details.get('description', '')
    # Could track: agent spawn, agent complete, agent failed
```

---

### Gap 2: Sequential Constraint Decisions

**Missing Event:** When orchestrator filters tasks for sequential constraints

**Current Code:**
```python
# In plan_orchestrator.py
filtered_tasks = self._filter_sequential_tasks(next_tasks)
if len(filtered_tasks) < len(next_tasks):
    self.logger.info(f"Filtered {len(next_tasks)} tasks to {len(filtered_tasks)}...")
```

**TUI Opportunity:** Show "Task X.Y held back (sequential with X.Z)" in a constraints panel

---

### Gap 3: Git Commit Events

**Missing Event:** When commits are created

**Source:** Commits happen inside Claude sessions
**Detection:** Could watch `.git/` or parse Claude output for git commands
**TUI Opportunity:** Commit history stream showing recent plan commits

---

### Gap 4: Phase Transitions

**Missing Event:** Explicit phase completion events

**Current:** Phase is read from status.json `currentPhase` field
**Gap:** No event when phase threshold (80%) is reached
**TUI Opportunity:** Phase completion celebration / progress milestone

---

### Gap 5: Batch Composition Decisions

**Missing Event:** Why tasks were grouped together

**Current:** `get_next_tasks()` returns task list without grouping rationale
**Gap:** No visibility into "why these tasks together"
**TUI Opportunity:** Batch explainer panel

---

### Gap 6: IPC Commands Received

**Source:** `scripts/lib/orchestrator_ipc.py`

**Current Events:**
```python
# In _handle_ipc_command()
- "status" command received
- "shutdown" command received
- "pause" command received
- "resume" command received
```

**Gap:** These are logged but not surfaced to TUI
**TUI Opportunity:** Command log showing external control events

---

## Recommended Event Streaming Architecture

### Event Bus Pattern

```python
# Proposed: Centralized event emitter
class OrchestratorEventBus:
    def emit(self, event_type: str, data: dict):
        """Emit event to all subscribers (TUI, logs, etc.)"""
        pass

    def subscribe(self, event_type: str, callback: Callable):
        """Subscribe to specific event type"""
        pass

# Event types:
EVENTS = [
    "iteration.start",
    "iteration.complete",
    "task.started",
    "task.completed",
    "task.failed",
    "task.stuck_detected",
    "task.retry",
    "claude.session.start",
    "claude.session.end",
    "tool.start",
    "tool.end",
    "agent.spawn",
    "agent.complete",
    "phase.progress",
    "phase.complete",
    "batch.composed",
    "constraint.applied",
    "ipc.command_received",
    "shutdown.requested",
    "git.commit",
]
```

### TUI Event Consumption

```python
# Proposed: TUI subscribes to event bus
def setup_tui_event_handlers(tui: RichTUIManager, bus: OrchestratorEventBus):
    bus.subscribe("tool.start", lambda e: tui.add_activity(e["tool_name"], e["details"]))
    bus.subscribe("tool.end", lambda e: tui.complete_activity(e["tool_id"], e["duration"]))
    bus.subscribe("phase.complete", lambda e: tui.show_milestone(f"Phase {e['phase']} complete!"))
    bus.subscribe("constraint.applied", lambda e: tui.show_constraint_badge(e["task_id"], e["reason"]))
```

---

## Priority Matrix for New Events

| Event | Implementation Effort | TUI Value | Priority |
|-------|----------------------|-----------|----------|
| Sequential constraint applied | LOW | HIGH | P1 |
| Phase threshold reached | LOW | MEDIUM | P2 |
| Batch composition rationale | MEDIUM | HIGH | P1 |
| Git commits detected | MEDIUM | MEDIUM | P3 |
| Parallel agent tracking | HIGH | HIGH | P2 |
| IPC commands to TUI | LOW | LOW | P4 |

---

## Implementation Recommendations

### Quick Wins (No Architecture Change)

1. **Add constraint filtering event** - Emit when `_filter_sequential_tasks()` holds back tasks
2. **Surface IPC events** - Call `tui.set_status()` when pause/resume/shutdown received
3. **Phase milestone detection** - Calculate when phase crosses 80% threshold

### Medium Effort (Minor Refactoring)

4. **Event bus abstraction** - Create lightweight event emitter class
5. **Batch composition logging** - Return grouping rationale from `get_next_tasks()`

### Higher Effort (New Components)

6. **Agent lifecycle tracking** - Parse Task tool results for agent completion
7. **Git commit detection** - Watch `.git/logs/HEAD` or parse Claude output

---

## Related Files

- `scripts/lib/claude_runner.py` - StreamingClaudeRunner callbacks
- `scripts/lib/status_monitor.py` - StatusMonitor file watching
- `scripts/lib/tui.py` - TUI update methods
- `scripts/plan_orchestrator.py` - Main orchestration loop
- `scripts/lib/orchestrator_ipc.py` - IPC command handling

---

**End of Analysis**
