# Task 4.2: `depends:` Syntax Analysis

**Analysis Plan:** TUI Expansion Analysis
**Task Number:** 4.2
**Date:** 2025-12-26
**Scope:** Analyze the `(depends: X.Y)` syntax implementation for task-level dependencies

---

## Executive Summary

The dev_workflow system implements a comprehensive task dependency syntax using the `(depends: X.Y)` pattern, which enables fine-grained DAG-based scheduling across task phases. The implementation includes:

1. **Syntax Pattern:** `(depends: X.Y)` or `(depends: X.Y, X.Z, ...)` in task descriptions
2. **Parsing Engine:** Regex-based extraction with validation in `plan-status.js`
3. **Dependency Graph:** Full DAG construction with cycle detection
4. **Validation:** Multi-level checking for invalid references and circular dependencies
5. **Integration:** Full CLI support through `status-cli.js` with `deps` command

This is a **FULLY IMPLEMENTED FEATURE** with comprehensive validation and error handling.

---

## Section 1: Complete Syntax Specification

### 1.1 Pattern Definition

```regex
/\(depends:\s*([\d.,\s]+)\)/i
```

**Components:**
- **Case-insensitive:** `(depends:`, `(Depends:`, `(DEPENDS:` all match
- **Whitespace flexible:** `(depends:1.1)`, `(depends: 1.1)`, `(depends: 1.1, 1.2)` all valid
- **Capture group:** `[\d.,\s]+` captures the dependency list

### 1.2 Task ID Validation Pattern

```regex
/^\d+\.\d+(?:\.\d+)?$/
```

**Matches:**
- `1.1` - Phase.Task format
- `1.2.1` - Phase.Task.Subtask format (optional)

**Rejects:**
- `1` - Missing task number
- `1.a` - Non-numeric task number
- `.1` - Missing phase number

### 1.3 Supported Syntax Variants

| Variant | Example | Parsed As |
|---------|---------|-----------|
| Single dependency | `(depends: 1.1)` | `["1.1"]` |
| Multiple comma-separated | `(depends: 1.1, 1.2, 1.3)` | `["1.1", "1.2", "1.3"]` |
| Whitespace variants | `(depends:1.1,1.2)` | `["1.1", "1.2"]` |
| With extra spaces | `(depends: 1.1 , 1.2 )` | `["1.1", "1.2"]` |
| Case-insensitive | `(DEPENDS: 1.1)` | `["1.1"]` |
| Subtask format | `(depends: 1.1.1, 1.2)` | `["1.1.1", "1.2"]` |

---

## Section 2: Parsing Algorithm Details

### 2.1 Function: `parseDependencies(taskDescription)`

**Location:** `scripts/lib/plan-status.js` (lines 1421-1445)

**Algorithm:**

```javascript
function parseDependencies(taskDescription) {
  // Step 1: Input validation
  if (!taskDescription || typeof taskDescription !== 'string') {
    return [];
  }

  // Step 2: Pattern matching
  const dependsPattern = /\(depends:\s*([\d.,\s]+)\)/i;
  const match = taskDescription.match(dependsPattern);
  if (!match) {
    return [];
  }

  // Step 3: Extract dependency string
  const depString = match[1].trim();

  // Step 4: Parse and validate
  const dependencies = depString
    .split(',')                                          // Split by comma
    .map(id => id.trim())                               // Remove whitespace
    .filter(id => /^\d+\.\d+(?:\.\d+)?$/.test(id));     // Validate format

  return dependencies;
}
```

**Time Complexity:** O(n) where n = length of task description
**Space Complexity:** O(m) where m = number of dependencies

### 2.2 Parsing Examples

**Example 1: Simple dependency**
```javascript
parseDependencies("Setup database (depends: 1.1)")
// Returns: ["1.1"]
```

**Example 2: Multiple dependencies with whitespace**
```javascript
parseDependencies("Implement service (depends: 1.1 , 1.2 , 1.3)")
// Returns: ["1.1", "1.2", "1.3"]
```

**Example 3: No dependencies**
```javascript
parseDependencies("Standalone task")
// Returns: []
```

### 2.3 Current Limitation: Single Match

The `match()` function returns only the FIRST match. If a task description contains multiple `(depends:...)` patterns, only the first is parsed.

**Mitigation:** Plan authors should use comma-separated format:
```markdown
- [ ] 2.3 Task (depends: 1.1, 2.2)
```

---

## Section 3: DAG Construction Process

### 3.1 Function: `buildDependencyGraph(tasks)`

**Location:** `scripts/lib/plan-status.js` (lines 1466-1505)

**Input Format:**
```javascript
tasks = [
  { id: "1.1", description: "Create types" },
  { id: "1.2", description: "Create schema" },
  { id: "1.3", description: "Implement auth (depends: 1.1, 1.2)" }
]
```

**Output Structure:**
```javascript
graph = Map {
  "1.1" → { dependencies: [], dependents: ["1.3"], inDegree: 0 },
  "1.2" → { dependencies: [], dependents: ["1.3"], inDegree: 0 },
  "1.3" → { dependencies: ["1.1", "1.2"], dependents: [], inDegree: 2 }
}
```

### 3.2 Graph Properties

**Topological Sort Order (execution sequence):**
1. Tasks with inDegree=0: 1.1, 1.2 (can start immediately)
2. After 1.1, 1.2 complete: 1.3 (inDegree satisfied)

**Parallelizable Steps:**
- Step 1: 1.1 and 1.2 can run in parallel
- Step 2: Only 1.3 ready after both complete

---

## Section 4: Cycle Detection Mechanism

### 4.1 Function: `detectDependencyCycles(graph)`

**Location:** `scripts/lib/plan-status.js` (lines 1524-1596)

**Algorithm: Depth-First Search with Color Marking**

```javascript
const WHITE = 0;   // Not visited
const GRAY = 1;    // Currently in DFS path (visiting)
const BLACK = 2;   // Fully processed (visited and descendants explored)
```

### 4.2 Cycle Detection Examples

**Simple 2-node cycle:**
```javascript
// Graph: A depends on B, B depends on A
detectDependencyCycles(graph)
// Returns: ["A", "B", "A"]  (cycle path with endpoints)
```

**DAG (no cycle):**
```javascript
detectDependencyCycles(validGraph)
// Returns: null
```

**Time Complexity:** O(V + E) where V = tasks, E = dependencies

---

## Section 5: Integration with status-cli.js

### 5.1 Dependency Validation Command

**Command:** `node scripts/status-cli.js deps <plan-path>`

**Output Format (Success):**
```json
{
  "valid": true,
  "errors": [],
  "hasCycle": false,
  "cyclePath": null,
  "invalidReferences": [],
  "selfDependencies": [],
  "summary": {
    "totalTasks": 12,
    "tasksWithDeps": 8,
    "totalDependencies": 15
  }
}
```

**Output Format (Errors):**
```json
{
  "valid": false,
  "errors": [
    "Task 2.3 depends on itself",
    "Task 2.4 references non-existent dependency '9.9'",
    "Cycle detected: 1.1 → 1.2 → 1.3 → 1.1"
  ],
  "hasCycle": true,
  "cyclePath": ["1.1", "1.2", "1.3", "1.1"]
}
```

---

## Section 6: Implementation Status

### 6.1 Fully Implemented Features

| Component | Status | Location |
|-----------|--------|----------|
| Dependency parsing | ✓ Complete | `plan-status.js:1421-1445` |
| DAG construction | ✓ Complete | `plan-status.js:1466-1505` |
| Cycle detection | ✓ Complete | `plan-status.js:1524-1596` |
| Validation | ✓ Complete | `plan-status.js:1622-1661` |
| CLI integration | ✓ Complete | `status-cli.js:375-455` |

---

## Section 7: Limitations and Gaps

### 7.1 Parsing Limitations

| Gap | Severity | Recommendation |
|-----|----------|----------------|
| Single pattern match only | LOW | Document + enhance to `matchAll()` |
| No weighted edges | MEDIUM | Future: conditional deps syntax |
| No OR dependencies | MEDIUM | Future: `(depends: 1.1 OR 1.2)` |

### 7.2 Integration Gaps

| Gap | Severity | Recommendation |
|-----|----------|----------------|
| DAG not stored in status.json | MEDIUM | Store validation results |
| No DAG-aware scheduling | HIGH | Implement DAG-based `next` command |
| No visualization | MEDIUM | Add graph visualization command |

---

## Section 8: TUI Visualization Opportunities

### 8.1 Dependency Data for TUI

The dependency system provides rich data for TUI visualization:

```javascript
// From buildDependencyGraph()
{
  dependencies: ["1.1", "1.2"],  // What task depends on
  dependents: ["2.1"],           // What depends on this task
  inDegree: 2                    // Count for scheduling
}
```

### 8.2 Proposed TUI Panels

1. **Inline blockers:** Show `[Blocked by: 1.2]` on pending tasks
2. **Dependency tree:** Vertical tree showing task chains
3. **Critical path:** Longest dependency chain for time estimation
4. **Cycle warning:** Alert banner when cycles detected

---

## Summary

The `(depends: X.Y)` syntax is **fully implemented** with:

- Complete parsing algorithm with regex validation
- Full DAG construction with forward and reverse edges
- Robust cycle detection using DFS with color marking
- Comprehensive validation and CLI integration

**Main gaps** are in UX (visualization) and advanced scheduling (DAG-aware task selection). The foundation is solid and ready for TUI integration.
