# Task 1.1: Document current /plan:set implementation

## Current Workflow Steps

The `/plan:set` command is implemented in `.claude/commands/plan/set.md` with the following workflow:

### Step 1: Scan for Plan Files
- Executes `node scripts/scan-plans.js` to get plan data in JSON format
- Parses output to extract plan metadata, titles, and task counts
- Identifies currently active plan from `currentPlan` field
- Falls back to manual scanning on script error (using Glob for `docs/plans/*.md`)

### Step 2: Present Options Using AskUserQuestion
- Shows each plan with title and task counts
- Format: `{filename} - {title} ({incomplete} remaining, {complete} done)`
- Indicates current plan with "(current)"

### Step 3: After User Selection
- Writes selected plan's relative path to `.claude/current-plan.txt`
- Confirms selection to user
- Shows brief summary of plan contents (phases/sections and task counts)

### Step 3.1: Initialize Status Tracking
- Runs `node scripts/status-cli.js init`
- Creates output directory `docs/plan-outputs/{plan-name}/` with:
  - `status.json` - Task status tracking (authoritative source)
  - `findings/` - Task findings/outputs
  - `timestamps/` - Execution timestamps

### Error Handling
- **Script errors**: Logs to `.claude/logs/script-errors.log`, falls back to manual scanning
- **Status init errors**: Shows warning, continues with plan activation (status tracking optional)

## Existing Git-Related Code

**None.** The current implementation has no git-related functionality.

## Identified Insertion Points for Git Operations

### 1. Git Availability Check
**Location**: At the very start, before Step 1 or as new Step 0

**Purpose**: Detect if git is available and set a `GIT_AVAILABLE` flag

**Implementation approach**:
```markdown
### 0. Check Git Availability (Optional)

Before any operations, check if git is available:
```bash
git --version
```

- If command succeeds: Set `GIT_AVAILABLE = true`
- If command fails: Set `GIT_AVAILABLE = false`, skip all git operations
- Log availability status for debugging
```

### 2. Branch Operations
**Location**: In Step 3, after writing to `current-plan.txt` but before status init

**Purpose**: Create or switch to plan-specific branch

**Implementation approach**:
```markdown
### 3.0.2 Switch to Plan Branch (If Git Available)

If `GIT_AVAILABLE`:
1. Derive branch name: `plan/{plan-name}` (e.g., `plan/test-suite-implementation`)
2. Check if branch exists: `git rev-parse --verify plan/{plan-name} 2>/dev/null`
3. If branch doesn't exist: Create with `git checkout -b plan/{plan-name}`
4. If branch exists: Switch with `git checkout plan/{plan-name}`
5. Log which action was taken
```

### 3. Stash Logic (Uncommitted Changes Detection)
**Location**: Before branch switch operations (new Step 3.0.1)

**Purpose**: Handle uncommitted changes before switching branches

**Implementation approach**:
```markdown
### 3.0.1 Handle Uncommitted Changes (If Git Available)

If `GIT_AVAILABLE` and switching plans (not just refreshing current):
1. Check for uncommitted changes: `git status --porcelain | wc -l`
2. If count > 0 and < 10 files:
   - Auto-stash: `git stash push -m "plan-switch: {old-plan} -> {new-plan}"`
   - Log: "Stashed N uncommitted changes"
3. If count >= 10 files:
   - Warn: "Too many uncommitted changes (N files). Commit or stash manually before switching."
   - Abort plan switch
4. If count == 0:
   - Continue normally
```

## Recommended Step Order After Changes

1. **Step 0**: Git availability check
2. **Step 1**: Scan for plan files
3. **Step 2**: Present options to user
4. **Step 3**: After user selection
   - Write to `current-plan.txt`
   - **Step 3.0.1**: Handle uncommitted changes (if git available)
   - **Step 3.0.2**: Switch to plan branch (if git available)
   - **Step 3.1**: Initialize status tracking
   - Show confirmation with git branch info if applicable

## Notes

- All git operations should be skipped gracefully when git is unavailable
- Error messages from git commands should be logged but not block the plan switch
- Branch metadata should be recorded in `status.json` for tracking
