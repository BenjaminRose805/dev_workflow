# Task 4.4: Task Synchronization and Fan-In/Fan-Out Patterns

**Analysis Plan:** Parallel Execution Architecture
**Date:** 2025-12-25

---

## Executive Summary

This document analyzes the synchronization patterns used in the plan execution system, focusing on how parallel tasks coordinate at phase boundaries, spawn work (fan-out), and collect results (fan-in). The system implements implicit synchronization through phase ordering and status polling, rather than explicit barriers or semaphores.

---

## 1. Phase Boundary Synchronization

### 1.1 Synchronization Mechanism: Phase Completion Threshold

The primary synchronization point is at **phase boundaries**. The system uses an 80% completion threshold to determine when tasks from the next phase can begin.

**From `status-cli.js` (cmdNext function):**

```javascript
// 80% threshold for phase advancement
const previousMostlyComplete = previousPhases.every(p => {
  const completed = p.tasks.filter(t =>
    t.status === 'completed' || t.status === 'skipped'
  ).length;
  return completed >= p.tasks.length * 0.8;
});

if (previousIncomplete && !previousMostlyComplete) {
  continue; // Skip this phase for now
}
```

### 1.2 Synchronization Flow

```
Phase N Tasks:        [T1] [T2] [T3] [T4] [T5]
                        âœ“    âœ“    âœ“    âœ“    â—¯   (80% complete)

                                               â†“ Threshold reached

Phase N+1 Tasks:      [T6] [T7] [T8]           (Can now start)
```

### 1.3 Implicit Barrier Pattern

The phase boundary acts as a **soft barrier**:

| Barrier Type | Description | Implementation |
|--------------|-------------|----------------|
| **Soft (80%)** | Next phase starts when current is mostly complete | `getNextTasks()` filter |
| **Hard (100%)** | Would require explicit wait | NOT implemented |

**Key Insight:** This is an implicit barrier - there's no explicit "wait" mechanism. The orchestrator simply gets no tasks from the next phase until the threshold is met.

---

## 2. Fan-Out Patterns

### 2.1 Orchestrator Fan-Out (Main Loop)

The orchestrator spawns multiple parallel Task agents from a single execution loop:

**From `orchestrate.md`:**

```
Step 2.2: Execute Tasks in Parallel

For each batch of tasks (up to 3-5 at a time), launch **parallel Task agents**:

Use the Task tool with subagent_type="general-purpose" for each task.
Launch them IN PARALLEL by including multiple Task tool calls in a single response.
```

**Pattern Diagram:**

```
                    Orchestrator
                         â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â–¼            â–¼            â–¼
       [Agent 1]    [Agent 2]    [Agent 3]
         Task 1.1    Task 1.2     Task 1.3
            â”‚            â”‚            â”‚
            â–¼            â–¼            â–¼
       [Result 1]   [Result 2]   [Result 3]
```

### 2.2 Task-Level Fan-Out (Sub-Agents)

A single task can spawn multiple agents for parallel work:

**From `implement.md` Section 5.1:**

| Scenario | Agent Strategy |
|----------|----------------|
| Single file creation | 1 agent |
| Multiple independent files | Parallel agents (1 per file group) |
| Test + implementation | Parallel agents (test agent + impl agent) |
| Refactoring across files | Parallel agents grouped by module |

**Example from implement.md:**

```
Task "1.1 Add user authentication" might spawn:
Agent 1: Create auth middleware (src/middleware/auth.ts)
Agent 2: Create auth utilities (src/lib/auth-utils.ts)
Agent 3: Create auth tests (tests/unit/auth.test.ts)
Agent 4: Update route handlers (src/routes/*.ts)
```

### 2.3 Batch Size Guidelines for Fan-Out

**From `orchestrate.md`:**

| Plan Size | Batch Size | Rationale |
|-----------|------------|-----------|
| < 10 tasks | 2-3 | Small plan, quick iteration |
| 10-30 tasks | 3-4 | Medium plan, balanced |
| > 30 tasks | 4-5 | Large plan, maximize throughput |

**From `implement.md`:**

> Maximum 5 parallel agents per task

---

## 3. Fan-In Patterns

### 3.1 Orchestrator Result Collection

After spawning parallel agents, the orchestrator collects all results:

**From `orchestrate.md`:**

```
Step 2.3: Collect Results

Wait for all parallel agents to complete using TaskOutput.

For each result:
- If successful: Note completion
- If failed: Log error, may retry later
```

**Pattern:**

```
       [Agent 1]    [Agent 2]    [Agent 3]
            â”‚            â”‚            â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â–¼
                    TaskOutput
                    (Fan-In)
                         â”‚
                         â–¼
              Process All Results
```

### 3.2 Read-Only Agent Pattern (Fan-In Mechanism)

The Read-Only Agent Pattern ensures clean fan-in by having agents return content rather than write files:

**From `implement.md` Section 5.4:**

```
After all agents complete:

1. Review each agent's output for completeness and correctness
2. Check for conflicts - ensure agents didn't generate conflicting code
3. Write files in dependency order - types/interfaces first, then implementations
4. Run verification if applicable (type check, lint, test)
5. Handle failures - if writing fails, report which files succeeded/failed
```

**Agent Output Format:**

```
IMPORTANT: Do NOT write files directly. Instead:
1. Analyze the task requirements
2. Generate the complete code/content
3. Return your output in this format:
   FILE: <path>
   ```<language>
   <content>
   ```
4. The main conversation will handle file writing
```

### 3.3 Status.json as Collection Point

All task results ultimately fan-in to `status.json`:

```javascript
// From plan-status.js
function markTaskCompleted(planPath, taskId, options = {}) {
  const extras = {};
  if (options.notes) {
    extras.notes = options.notes;
  }
  if (options.findings) {
    const findingsPath = writeFindings(planPath, taskId, options.findings);
    if (findingsPath) {
      extras.findingsPath = findingsPath;
    }
  }
  return updateTaskStatus(planPath, taskId, 'completed', extras);
}
```

---

## 4. VERIFY Task Synchronization

### 4.1 Dependency on Prior Completion

VERIFY tasks have implicit dependencies on the tasks they verify:

**From `verify.md`:**

```
Status: âœ… ALREADY DONE
  File exists: tests/unit/lib/websocket-connection.test.ts
  Tests pass: true (12/12 passing)
  Recommendation: Mark as complete in status.json

Status: ğŸš« BLOCKED
  Blocked by: 2.1 mock-claude-cli.ts (not yet created)
  Recommendation: Complete task 2.1 first
```

### 4.2 Verification Synchronization Points

| Check Type | Synchronization Required | Mechanism |
|------------|--------------------------|-----------|
| File existence | After file write | Immediate (filesystem) |
| Test passing | After code complete | Test execution |
| Dependencies met | After predecessor tasks | status.json check |
| Success criteria | After all related tasks | Aggregate verification |

### 4.3 Batch Verification (Parallel)

**From `verify.md`:**

```bash
# Batch verification runs in parallel
echo '["path1", "path2", "path3"]' | node scripts/check-file-status.js --verbose

# With test execution
node scripts/check-file-status.js --files test1.test.ts test2.test.ts --run-tests
```

**Speed comparison:**
- Manual checking: ~2-3 seconds per task
- Batch script: ~0.2-0.5 seconds per task

---

## 5. Sequential Constraint Enforcement

### 5.1 [SEQUENTIAL] Annotation Pattern

Explicit synchronization for tasks that cannot run in parallel:

**From `implement.md`:**

```markdown
**Execution Note:** Tasks 3.1-3.4 are [SEQUENTIAL] - all modify same file
```

**Parsed by `parseExecutionNotes()` in `plan-status.js`:**

```javascript
function parseExecutionNotes(planContent) {
  const constraints = [];
  const notePattern = /\*\*Execution Note:\*\*\s*Tasks?\s+([\d.,\s-]+)\s+(?:are|is)\s+\[SEQUENTIAL\]/gi;

  // Expands "3.1-3.4" â†’ ["3.1", "3.2", "3.3", "3.4"]
  const taskIds = expandTaskRange(cleanRange);

  constraints.push({
    taskRange: cleanRange,
    taskIds,
    reason
  });
}
```

### 5.2 Per-Task Constraint Storage

```json
{
  "sequentialGroups": [
    {
      "taskRange": "3.1-3.4",
      "taskIds": ["3.1", "3.2", "3.3", "3.4"],
      "reason": "all modify same file"
    }
  ],
  "tasks": [
    {
      "id": "3.1",
      "executionConstraints": {
        "sequential": true,
        "sequentialGroup": "3.1-3.4",
        "reason": "all modify same file"
      }
    }
  ]
}
```

### 5.3 Constraint Surfacing in `next` Command

**From `status-cli.js`:**

```javascript
// Helper to get constraint metadata for a task
function getConstraintMetadata(taskId) {
  for (const constraint of constraints) {
    if (constraint.taskIds.includes(taskId)) {
      return {
        sequential: true,
        sequentialGroup: constraint.taskRange,
        sequentialReason: constraint.reason
      };
    }
  }
  return { sequential: false };
}

// Applied when returning next tasks
next.push({
  id: task.id,
  description: task.description,
  phase: phase.number,
  status: task.status,
  reason: 'pending - ready to implement',
  ...getConstraintMetadata(task.id)  // Includes sequential flag
});
```

---

## 6. Error Handling in Synchronization

### 6.1 Failed Task Handling

**From `orchestrate.md`:**

```
Task fails:
1. Mark as failed in status.json
2. Check if blocker for other tasks
3. Continue with non-dependent tasks
4. Retry failed tasks at end (max 2 retries)
```

### 6.2 Dependency Failure Cascade

**From `batch.md`:**

```
If a dependency fails:
- Call markTaskSkipped(planPath, taskId, reason) for all dependent tasks

âœ— 2.1 mock-claude-cli.ts - FAILED

Affected dependent tasks:
  âŠ˜ 2.2 orchestrator.integration.test.ts - SKIPPED (depends on 2.1)
```

### 6.3 Stuck Task Detection

**From `plan-output-utils.js`:**

```javascript
const STUCK_TASK_THRESHOLD_MS = 30 * 60 * 1000; // 30 minutes

function detectAndMarkStuckTasks(planPath, thresholdMs = STUCK_TASK_THRESHOLD_MS) {
  // Marks in_progress tasks as failed if started > 30 min ago
  for (const task of status.tasks) {
    if (task.status === 'in_progress' && task.startedAt) {
      const elapsedMs = now - startedAt;
      if (elapsedMs > thresholdMs) {
        task.status = 'failed';
        task.lastError = `Task stuck: in_progress for ${elapsedMs} ms`;
      }
    }
  }
}
```

### 6.4 Retry Mechanism

```javascript
const MAX_RETRIES = 2;

function getRetryableTasks(planPath) {
  return status.tasks
    .filter(t => t.status === 'failed')
    .filter(t => (t.retryCount || 0) < MAX_RETRIES);
}
```

---

## 7. Synchronization Patterns Summary

### 7.1 Pattern Catalog

| Pattern | Location | Mechanism | Type |
|---------|----------|-----------|------|
| **Phase Barrier** | `cmdNext()` | 80% completion threshold | Implicit/Soft |
| **Parallel Fan-Out** | Orchestrator loop | Multiple Task tool calls | Explicit |
| **Task Sub-Fan-Out** | implement.md | Multiple agents per task | Explicit |
| **Result Fan-In** | TaskOutput | Wait for all agents | Explicit |
| **Content Fan-In** | Read-only pattern | Collect then write | Explicit |
| **Status Fan-In** | status.json | Single source of truth | Persistent |
| **Sequential Lock** | [SEQUENTIAL] | Constraint parsing | Annotation-based |
| **Failure Cascade** | markTaskSkipped | Skip dependents | Reactive |

### 7.2 Synchronization Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYNCHRONIZATION FLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  PHASE N                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Fan-Out: Orchestrator spawns parallel agents           â”‚    â”‚
â”‚  â”‚                                                          â”‚    â”‚
â”‚  â”‚     [T1]â”€â”€â”€â”€â”    [T2]â”€â”€â”€â”€â”    [T3]â”€â”€â”€â”€â”                 â”‚    â”‚
â”‚  â”‚       â”‚     â”‚      â”‚     â”‚      â”‚     â”‚                 â”‚    â”‚
â”‚  â”‚       â–¼     â”‚      â–¼     â”‚      â–¼     â”‚                 â”‚    â”‚
â”‚  â”‚    Agent 1  â”‚   Agent 2  â”‚   Agent 3  â”‚                 â”‚    â”‚
â”‚  â”‚       â”‚     â”‚      â”‚     â”‚      â”‚     â”‚                 â”‚    â”‚
â”‚  â”‚       â”‚     â”‚      â”‚     â”‚      â”‚     â”‚                 â”‚    â”‚
â”‚  â”‚       â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜                 â”‚    â”‚
â”‚  â”‚               â”‚                                          â”‚    â”‚
â”‚  â”‚               â–¼                                          â”‚    â”‚
â”‚  â”‚  Fan-In: TaskOutput collects all results                 â”‚    â”‚
â”‚  â”‚               â”‚                                          â”‚    â”‚
â”‚  â”‚               â–¼                                          â”‚    â”‚
â”‚  â”‚  Main conversation writes files (dependency order)       â”‚    â”‚
â”‚  â”‚               â”‚                                          â”‚    â”‚
â”‚  â”‚               â–¼                                          â”‚    â”‚
â”‚  â”‚  status.json updated (completion fan-in)                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                   â”‚                                              â”‚
â”‚                   â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  PHASE BARRIER: 80% completion threshold                 â”‚    â”‚
â”‚  â”‚  cmdNext() withholds Phase N+1 tasks until threshold    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                   â”‚                                              â”‚
â”‚                   â–¼                                              â”‚
â”‚  PHASE N+1 (repeats pattern)                                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.3 Key Observations

1. **No Explicit Barriers:** The system relies on polling (`getNextTasks`) rather than explicit wait/notify mechanisms.

2. **Soft Boundaries:** The 80% threshold allows pipeline overlap rather than strict sequential phase execution.

3. **Centralized Collection:** `status.json` serves as the synchronization hub where all task completions converge.

4. **Read-Only Agent Pattern:** Prevents race conditions by separating work execution from state mutation.

5. **Annotation-Based Constraints:** Sequential requirements are encoded in plan markdown, parsed at init, and stored in status.json.

6. **Failure Isolation:** Task failures don't block the entire plan - only explicitly dependent tasks are skipped.

---

## 8. Recommendations for Enhancement

### 8.1 Potential Improvements

| Area | Current State | Enhancement Opportunity |
|------|---------------|------------------------|
| Hard barriers | Not implemented | Add explicit phase completion gate |
| Parallel phases | Not supported | Allow independent phases to overlap |
| Dynamic fan-out | Fixed batch sizes | Adaptive batching based on task complexity |
| Explicit dependencies | Implicit only | Add task-level dependency declarations |

### 8.2 Fan-In/Fan-Out Optimization Opportunities

1. **Adaptive Batch Sizing:** Current batch sizes are static (2-5). Could be dynamic based on:
   - Task complexity estimates
   - System resource availability
   - Historical task duration

2. **Dependency Graph:** Currently phase-implicit. Could add explicit task dependency graph for more granular parallelism.

3. **Pipelined Execution:** Start next phase tasks before current phase is 100% complete (already at 80%, could be more aggressive for independent tasks).
