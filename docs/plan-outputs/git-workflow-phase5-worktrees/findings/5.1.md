# Task 5.1: Process Management Design for Multiple Orchestrators

## Overview

This document defines the architecture for managing multiple concurrent orchestrator instances, enabling parallel plan execution across git worktrees.

## Design Goals

1. **Independent Execution**: Each orchestrator runs autonomously in its own worktree
2. **Visibility**: Central registry tracks all running instances
3. **Coordination**: IPC enables cross-orchestrator communication
4. **Graceful Lifecycle**: Clean startup, monitoring, and shutdown
5. **Resilience**: Crash recovery and stale instance cleanup

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          ORCHESTRATOR REGISTRY                               │
│                     (.claude/orchestrator-registry.json)                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  {                                                                           │
│    "instances": [                                                            │
│      {                                                                       │
│        "id": "orch-1735227600000",                                          │
│        "pid": 12345,                                                         │
│        "planPath": "docs/plans/feature-auth.md",                            │
│        "worktreePath": "/repo/worktrees/plan-feature-auth",                 │
│        "startedAt": "2025-12-26T10:00:00.000Z",                             │
│        "lastHeartbeat": "2025-12-26T10:05:00.000Z",                         │
│        "status": "running",                                                  │
│        "port": null,                                                         │
│        "socketPath": "/tmp/orchestrator-orch-1735227600000.sock"            │
│      }                                                                       │
│    ],                                                                        │
│    "lastCleanup": "2025-12-26T09:00:00.000Z"                                │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    │                                       │
    ┌───────────────┼───────────────┐   ┌───────────────────┼───────────────┐
    │               │               │   │                   │               │
    ▼               ▼               ▼   ▼                   ▼               ▼
┌─────────┐   ┌─────────┐   ┌─────────┐ ┌─────────┐   ┌─────────┐   ┌─────────┐
│ Orch 1  │   │ Orch 2  │   │ Orch 3  │ │ Orch 1  │   │ Orch 2  │   │ Orch 3  │
│ (PID 1) │   │ (PID 2) │   │ (PID 3) │ │ Socket  │   │ Socket  │   │ Socket  │
└────┬────┘   └────┬────┘   └────┬────┘ └────┬────┘   └────┬────┘   └────┬────┘
     │             │             │           │             │             │
     ▼             ▼             ▼           └──────┬──────┴─────────────┘
┌─────────┐   ┌─────────┐   ┌─────────┐            │
│Worktree1│   │Worktree2│   │Worktree3│            ▼
│plan-auth│   │plan-api │   │plan-perf│   ┌───────────────────┐
└─────────┘   └─────────┘   └─────────┘   │  IPC Messages     │
                                          │  - status_request │
                                          │  - shutdown       │
                                          │  - heartbeat      │
                                          └───────────────────┘
```

## Components

### 1. Orchestrator Registry (`scripts/lib/orchestrator_registry.py`)

Central file-based registry tracking all running orchestrator instances.

**Registry File Location**: `.claude/orchestrator-registry.json`

**Schema**:
```python
@dataclass
class OrchestratorInstance:
    id: str                     # Unique ID: orch-{timestamp}
    pid: int                    # Process ID
    plan_path: str              # Path to plan file
    worktree_path: Optional[str] # Worktree directory (None if main repo)
    started_at: str             # ISO timestamp
    last_heartbeat: str         # ISO timestamp of last heartbeat
    status: str                 # running | stopping | stopped | crashed
    socket_path: Optional[str]  # Unix socket for IPC
    port: Optional[int]         # TCP port for IPC (Windows fallback)
```

**Operations**:
- `register(instance)`: Add new orchestrator to registry
- `unregister(id)`: Remove orchestrator from registry
- `update_heartbeat(id)`: Update last heartbeat timestamp
- `get_instance(id)`: Get single instance by ID
- `get_all()`: List all registered instances
- `get_by_plan(plan_path)`: Find instance running a specific plan
- `cleanup_stale(threshold_seconds=60)`: Remove crashed/stale entries

### 2. Daemon Mode (`--daemon` flag)

Background execution mode for orchestrators.

**Startup Flow**:
```
1. Fork to background (or use subprocess on Windows)
2. Create PID file: .claude/orchestrator-{id}.pid
3. Redirect stdout/stderr to log file
4. Register with orchestrator registry
5. Start heartbeat thread
6. Begin normal orchestration loop
```

**Daemon Characteristics**:
- Detaches from terminal
- Runs until plan complete or max iterations
- Writes all output to log file
- Responds to IPC commands
- Updates heartbeat every 10 seconds

### 3. IPC System (`scripts/lib/orchestrator_ipc.py`)

Inter-process communication for orchestrator coordination.

**Transport**:
- **Unix**: Unix domain sockets (`/tmp/orchestrator-{id}.sock`)
- **Windows**: Named pipes or TCP localhost ports

**Message Protocol** (JSON-based):
```python
class IPCMessage:
    type: str       # request | response | notification
    command: str    # status | shutdown | pause | resume | heartbeat
    payload: dict   # Command-specific data
    timestamp: str  # ISO timestamp
```

**Commands**:

| Command | Direction | Description |
|---------|-----------|-------------|
| `status` | Request/Response | Get orchestrator status |
| `shutdown` | Request | Graceful shutdown request |
| `pause` | Request | Pause execution |
| `resume` | Request | Resume execution |
| `heartbeat` | Notification | Heartbeat ping |

### 4. Graceful Shutdown Handler

Multi-instance shutdown coordination.

**Shutdown Triggers**:
- SIGTERM/SIGINT signal
- IPC shutdown command
- Plan completion
- Max iterations reached
- Unrecoverable error

**Shutdown Sequence**:
```
1. Update registry status to "stopping"
2. Complete current Claude session (or timeout)
3. Save progress to status.json
4. Close IPC socket
5. Unregister from registry
6. Remove PID file
7. Exit cleanly
```

**Shutdown All Command**:
```bash
python scripts/plan_orchestrator.py --shutdown-all
```
- Iterates all registered instances
- Sends shutdown command via IPC
- Waits for graceful termination (configurable timeout)
- Force-kills unresponsive instances

## Implementation Files

| File | Purpose |
|------|---------|
| `scripts/lib/orchestrator_registry.py` | Registry CRUD operations |
| `scripts/lib/orchestrator_ipc.py` | IPC client/server |
| `scripts/plan_orchestrator.py` | Extended with daemon mode and registry integration |

## Usage Examples

### Start Daemon Orchestrator
```bash
# Start in daemon mode
python scripts/plan_orchestrator.py --daemon --plan docs/plans/feature.md

# Start in specific worktree
python scripts/plan_orchestrator.py --daemon --worktree worktrees/plan-feature
```

### List Running Orchestrators
```bash
python scripts/plan_orchestrator.py --list
```

### Stop Specific Orchestrator
```bash
python scripts/plan_orchestrator.py --stop orch-1735227600000
```

### Stop All Orchestrators
```bash
python scripts/plan_orchestrator.py --shutdown-all
```

## Concurrency Safety

### Registry File Locking

- Uses file-based locking (similar to status.json pattern)
- Prevents race conditions during concurrent registry updates
- Lock timeout: 5 seconds
- Stale lock detection: 30 seconds

### Duplicate Plan Prevention

Before starting, check if plan is already being executed:
```python
existing = registry.get_by_plan(plan_path)
if existing and existing.status == "running":
    raise DuplicatePlanError(f"Plan already running: {existing.id}")
```

## Recovery

### Stale Instance Cleanup

Periodic cleanup of crashed/stale instances:
1. Check if PID is still running
2. Check heartbeat age (>60 seconds = stale)
3. Remove from registry
4. Clean up PID file and socket

### Crash Recovery

On orchestrator startup:
1. Check for orphaned instances (PID not running)
2. Clean registry entries
3. Resume plan from last known state (via status.json)

## Configuration

Added to `.claude/git-workflow.json`:
```json
{
  "orchestrator": {
    "heartbeat_interval": 10,
    "stale_threshold": 60,
    "shutdown_timeout": 30,
    "max_concurrent": 3
  }
}
```

## Monitoring Integration

### Status CLI Extension

```bash
# Show all orchestrators
node scripts/status-cli.js orchestrators

# Show orchestrator for current plan
node scripts/status-cli.js orchestrator-status
```

### TUI Integration

Future: Multi-plan TUI can query registry to display all running plans.

## Security Considerations

1. **Socket Permissions**: Unix sockets created with 0600 permissions
2. **Registry Location**: Inside `.claude/` (typically gitignored)
3. **No Network Exposure**: IPC is local-only (Unix sockets or localhost TCP)
